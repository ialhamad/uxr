(function () {
  // create global namespace for all JS modules
  window.UX = {};

  UX.grid = {
    // Deprecated `$screen-xs` as of v3.0.1
    screenXs: "532",
    // Deprecated `$screen-sm` as of v3.0.1
    screenSm: "768",
    // Deprecated `$screen-md` as of v3.0.1
    screenMd: "1100",
    // Deprecated `$screen-md` as of v3.0.1
    screenLg: "1500",
    // Deprecated `$screen-md` as of v3.0.1
    screenXlg: "1920",
    // Small screen / phone
    containerMobile: "500",
    // For `$screen-sm-min` and up
    containerXs: "",
    // Small screen / tablet
    containerTablet: "736",
    // For `$screen-sm-min` and up
    containerSm: "",
    // Medium screen / desktop
    containerDesktop: "1058",
    // For `$screen-md-min` and up
    containerMd: "",
    // Large screen / wide desktop
    containerLargeDesktop: "1438",
    // For `$screen-lg-min` and up
    containerLg: ""
  };

  // import './services-variables.js'

  /*!
   * jQuery JavaScript Library v3.1.1
   * https://jquery.com/
   *
   * Includes Sizzle.js
   * https://sizzlejs.com/
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license
   *
   * Date: 2016-09-22T22:30Z
   */
  (function (global, factory) {

    if (typeof module === "object" && typeof module.exports === "object") {
      // For CommonJS and CommonJS-like environments where a proper `window`
      // is present, execute the factory and get jQuery.
      // For environments that do not have a `window` with a `document`
      // (such as Node.js), expose a factory as module.exports.
      // This accentuates the need for the creation of a real `window`.
      // e.g. var jQuery = require("jquery")(window);
      // See ticket #14549 for more info.
      module.exports = global.document ? factory(global, true) : function (w) {
        if (!w.document) {
          throw new Error("jQuery requires a window with a document");
        }

        return factory(w);
      };
    } else {
      factory(global);
    } // Pass this if window is not defined yet

  })(typeof window !== "undefined" ? window : window, function (window, noGlobal) {

    var arr = [];
    var document = window.document;
    var getProto = Object.getPrototypeOf;
    var slice = arr.slice;
    var concat = arr.concat;
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var fnToString = hasOwn.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var support = {};

    function DOMEval(code, doc) {
      doc = doc || document;
      var script = doc.createElement("script");
      script.text = code;
      doc.head.appendChild(script).parentNode.removeChild(script);
    }
    /* global Symbol */
    // Defining this global in .eslintrc.json would create a danger of using the global
    // unguarded in another place, it seems safer to define global only for this module


    var version = "3.1.1",
        // Define a local copy of jQuery
    jQuery = function (selector, context) {
      // The jQuery object is actually just the init constructor 'enhanced'
      // Need init if jQuery is called (just allow error to be thrown if not included)
      return new jQuery.fn.init(selector, context);
    },
        // Support: Android <=4.0 only
    // Make sure we trim BOM and NBSP
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
        // Matches dashed string for camelizing
    rmsPrefix = /^-ms-/,
        rdashAlpha = /-([a-z])/g,
        // Used by jQuery.camelCase as callback to replace()
    fcamelCase = function (all, letter) {
      return letter.toUpperCase();
    };

    jQuery.fn = jQuery.prototype = {
      // The current version of jQuery being used
      jquery: version,
      constructor: jQuery,
      // The default length of a jQuery object is 0
      length: 0,
      toArray: function () {
        return slice.call(this);
      },
      // Get the Nth element in the matched element set OR
      // Get the whole matched element set as a clean array
      get: function (num) {
        // Return all the elements in a clean array
        if (num == null) {
          return slice.call(this);
        } // Return just the one element from the set


        return num < 0 ? this[num + this.length] : this[num];
      },
      // Take an array of elements and push it onto the stack
      // (returning the new matched element set)
      pushStack: function (elems) {
        // Build a new jQuery matched element set
        var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)

        ret.prevObject = this; // Return the newly-formed element set

        return ret;
      },
      // Execute a callback for every element in the matched set.
      each: function (callback) {
        return jQuery.each(this, callback);
      },
      map: function (callback) {
        return this.pushStack(jQuery.map(this, function (elem, i) {
          return callback.call(elem, i, elem);
        }));
      },
      slice: function () {
        return this.pushStack(slice.apply(this, arguments));
      },
      first: function () {
        return this.eq(0);
      },
      last: function () {
        return this.eq(-1);
      },
      eq: function (i) {
        var len = this.length,
            j = +i + (i < 0 ? len : 0);
        return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
      },
      end: function () {
        return this.prevObject || this.constructor();
      },
      // For internal use only.
      // Behaves like an Array's method, not like a jQuery method.
      push: push,
      sort: arr.sort,
      splice: arr.splice
    };

    jQuery.extend = jQuery.fn.extend = function () {
      var options,
          name,
          src,
          copy,
          copyIsArray,
          clone,
          target = arguments[0] || {},
          i = 1,
          length = arguments.length,
          deep = false; // Handle a deep copy situation

      if (typeof target === "boolean") {
        deep = target; // Skip the boolean and the target

        target = arguments[i] || {};
        i++;
      } // Handle case when target is a string or something (possible in deep copy)


      if (typeof target !== "object" && !jQuery.isFunction(target)) {
        target = {};
      } // Extend jQuery itself if only one argument is passed


      if (i === length) {
        target = this;
        i--;
      }

      for (; i < length; i++) {
        // Only deal with non-null/undefined values
        if ((options = arguments[i]) != null) {
          // Extend the base object
          for (name in options) {
            src = target[name];
            copy = options[name]; // Prevent never-ending loop

            if (target === copy) {
              continue;
            } // Recurse if we're merging plain objects or arrays


            if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && jQuery.isArray(src) ? src : [];
              } else {
                clone = src && jQuery.isPlainObject(src) ? src : {};
              } // Never move original objects, clone them


              target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values
            } else if (copy !== undefined) {
              target[name] = copy;
            }
          }
        }
      } // Return the modified object


      return target;
    };

    jQuery.extend({
      // Unique for each copy of jQuery on the page
      expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
      // Assume jQuery is ready without the ready module
      isReady: true,
      error: function (msg) {
        throw new Error(msg);
      },
      noop: function () {},
      isFunction: function (obj) {
        return jQuery.type(obj) === "function";
      },
      isArray: Array.isArray,
      isWindow: function (obj) {
        return obj != null && obj === obj.window;
      },
      isNumeric: function (obj) {
        // As of jQuery 3.0, isNumeric is limited to
        // strings and numbers (primitives or objects)
        // that can be coerced to finite numbers (gh-2662)
        var type = jQuery.type(obj);
        return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        !isNaN(obj - parseFloat(obj));
      },
      isPlainObject: function (obj) {
        var proto, Ctor; // Detect obvious negatives
        // Use toString instead of jQuery.type to catch host objects

        if (!obj || toString.call(obj) !== "[object Object]") {
          return false;
        }

        proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain

        if (!proto) {
          return true;
        } // Objects with prototype are plain iff they were constructed by a global Object function


        Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
        return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
      },
      isEmptyObject: function (obj) {
        /* eslint-disable no-unused-vars */
        // See https://github.com/eslint/eslint/issues/6125
        var name;

        for (name in obj) {
          return false;
        }

        return true;
      },
      type: function (obj) {
        if (obj == null) {
          return obj + "";
        } // Support: Android <=2.3 only (functionish RegExp)


        return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
      },
      // Evaluates a script in a global context
      globalEval: function (code) {
        DOMEval(code);
      },
      // Convert dashed to camelCase; used by the css and data modules
      // Support: IE <=9 - 11, Edge 12 - 13
      // Microsoft forgot to hump their vendor prefix (#9572)
      camelCase: function (string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
      },
      nodeName: function (elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
      },
      each: function (obj, callback) {
        var length,
            i = 0;

        if (isArrayLike(obj)) {
          length = obj.length;

          for (; i < length; i++) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        }

        return obj;
      },
      // Support: Android <=4.0 only
      trim: function (text) {
        return text == null ? "" : (text + "").replace(rtrim, "");
      },
      // results is for internal usage only
      makeArray: function (arr, results) {
        var ret = results || [];

        if (arr != null) {
          if (isArrayLike(Object(arr))) {
            jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
          } else {
            push.call(ret, arr);
          }
        }

        return ret;
      },
      inArray: function (elem, arr, i) {
        return arr == null ? -1 : indexOf.call(arr, elem, i);
      },
      // Support: Android <=4.0 only, PhantomJS 1 only
      // push.apply(_, arraylike) throws on ancient WebKit
      merge: function (first, second) {
        var len = +second.length,
            j = 0,
            i = first.length;

        for (; j < len; j++) {
          first[i++] = second[j];
        }

        first.length = i;
        return first;
      },
      grep: function (elems, callback, invert) {
        var callbackInverse,
            matches = [],
            i = 0,
            length = elems.length,
            callbackExpect = !invert; // Go through the array, only saving the items
        // that pass the validator function

        for (; i < length; i++) {
          callbackInverse = !callback(elems[i], i);

          if (callbackInverse !== callbackExpect) {
            matches.push(elems[i]);
          }
        }

        return matches;
      },
      // arg is for internal usage only
      map: function (elems, callback, arg) {
        var length,
            value,
            i = 0,
            ret = []; // Go through the array, translating each of the items to their new values

        if (isArrayLike(elems)) {
          length = elems.length;

          for (; i < length; i++) {
            value = callback(elems[i], i, arg);

            if (value != null) {
              ret.push(value);
            }
          } // Go through every key on the object,

        } else {
          for (i in elems) {
            value = callback(elems[i], i, arg);

            if (value != null) {
              ret.push(value);
            }
          }
        } // Flatten any nested arrays


        return concat.apply([], ret);
      },
      // A global GUID counter for objects
      guid: 1,
      // Bind a function to a context, optionally partially applying any
      // arguments.
      proxy: function (fn, context) {
        var tmp, args, proxy;

        if (typeof context === "string") {
          tmp = fn[context];
          context = fn;
          fn = tmp;
        } // Quick check to determine if target is callable, in the spec
        // this throws a TypeError, but we will just return undefined.


        if (!jQuery.isFunction(fn)) {
          return undefined;
        } // Simulated bind


        args = slice.call(arguments, 2);

        proxy = function () {
          return fn.apply(context || this, args.concat(slice.call(arguments)));
        }; // Set the guid of unique handler to the same of original handler, so it can be removed


        proxy.guid = fn.guid = fn.guid || jQuery.guid++;
        return proxy;
      },
      now: Date.now,
      // jQuery.support is not used in Core but other projects attach their
      // properties to it so it needs to exist.
      support: support
    });

    if (typeof Symbol === "function") {
      jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    } // Populate the class2type map


    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
      class2type["[object " + name + "]"] = name.toLowerCase();
    });

    function isArrayLike(obj) {
      // Support: real iOS 8.2 only (not reproducible in simulator)
      // `in` check used to prevent JIT error (gh-2145)
      // hasOwn isn't used here due to false negatives
      // regarding Nodelist length in IE
      var length = !!obj && "length" in obj && obj.length,
          type = jQuery.type(obj);

      if (type === "function" || jQuery.isWindow(obj)) {
        return false;
      }

      return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }

    var Sizzle =
    /*!
     * Sizzle CSS Selector Engine v2.3.3
     * https://sizzlejs.com/
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     * Date: 2016-08-08
     */
    function (window) {
      var i,
          support,
          Expr,
          getText,
          isXML,
          tokenize,
          compile,
          select,
          outermostContext,
          sortInput,
          hasDuplicate,
          // Local document vars
      setDocument,
          document,
          docElem,
          documentIsHTML,
          rbuggyQSA,
          rbuggyMatches,
          matches,
          contains,
          // Instance-specific data
      expando = "sizzle" + 1 * new Date(),
          preferredDoc = window.document,
          dirruns = 0,
          done = 0,
          classCache = createCache(),
          tokenCache = createCache(),
          compilerCache = createCache(),
          sortOrder = function (a, b) {
        if (a === b) {
          hasDuplicate = true;
        }

        return 0;
      },
          // Instance methods
      hasOwn = {}.hasOwnProperty,
          arr = [],
          pop = arr.pop,
          push_native = arr.push,
          push = arr.push,
          slice = arr.slice,
          // Use a stripped-down indexOf as it's faster than native
      // https://jsperf.com/thor-indexof-vs-for/5
      indexOf = function (list, elem) {
        var i = 0,
            len = list.length;

        for (; i < len; i++) {
          if (list[i] === elem) {
            return i;
          }
        }

        return -1;
      },
          booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
          // Regular expressions
      // http://www.w3.org/TR/css3-selectors/#whitespace
      whitespace = "[\\x20\\t\\r\\n\\f]",
          // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
      identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
          // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
      attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
      "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
      "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
          pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
      // 1. quoted (capture 3; capture 4 or capture 5)
      "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
      "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
      ".*" + ")\\)|)",
          // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
      rwhitespace = new RegExp(whitespace + "+", "g"),
          rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
          rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
          rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
          rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
          rpseudo = new RegExp(pseudos),
          ridentifier = new RegExp("^" + identifier + "$"),
          matchExpr = {
        "ID": new RegExp("^#(" + identifier + ")"),
        "CLASS": new RegExp("^\\.(" + identifier + ")"),
        "TAG": new RegExp("^(" + identifier + "|[*])"),
        "ATTR": new RegExp("^" + attributes),
        "PSEUDO": new RegExp("^" + pseudos),
        "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
        "bool": new RegExp("^(?:" + booleans + ")$", "i"),
        // For use in libraries implementing .is()
        // We use this for POS matching in `select`
        "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
      },
          rinputs = /^(?:input|select|textarea|button)$/i,
          rheader = /^h\d$/i,
          rnative = /^[^{]+\{\s*\[native \w/,
          // Easily-parseable/retrievable ID or TAG or CLASS selectors
      rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
          rsibling = /[+~]/,
          // CSS escapes
      // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
      runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
          funescape = function (_, escaped, escapedWhitespace) {
        var high = "0x" + escaped - 0x10000; // NaN means non-codepoint
        // Support: Firefox<24
        // Workaround erroneous numeric interpretation of +"0x"

        return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint
        String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)
        String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
      },
          // CSS string/identifier serialization
      // https://drafts.csswg.org/cssom/#common-serializing-idioms
      rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
          fcssescape = function (ch, asCodePoint) {
        if (asCodePoint) {
          // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
          if (ch === "\0") {
            return "\uFFFD";
          } // Control characters and (dependent upon position) numbers get escaped as code points


          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        } // Other potentially-special ASCII characters get backslash-escaped


        return "\\" + ch;
      },
          // Used for iframes
      // See setDocument()
      // Removing the function wrapper causes a "Permission Denied"
      // error in IE
      unloadHandler = function () {
        setDocument();
      },
          disabledAncestor = addCombinator(function (elem) {
        return elem.disabled === true && ("form" in elem || "label" in elem);
      }, {
        dir: "parentNode",
        next: "legend"
      }); // Optimize for push.apply( _, NodeList )


      try {
        push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0
        // Detect silently failing push.apply

        arr[preferredDoc.childNodes.length].nodeType;
      } catch (e) {
        push = {
          apply: arr.length ? // Leverage slice if possible
          function (target, els) {
            push_native.apply(target, slice.call(els));
          } : // Support: IE<9
          // Otherwise append directly
          function (target, els) {
            var j = target.length,
                i = 0; // Can't trust NodeList.length

            while (target[j++] = els[i++]) {}

            target.length = j - 1;
          }
        };
      }

      function Sizzle(selector, context, results, seed) {
        var m,
            i,
            elem,
            nid,
            match,
            groups,
            newSelector,
            newContext = context && context.ownerDocument,
            // nodeType defaults to 9, since context defaults to document
        nodeType = context ? context.nodeType : 9;
        results = results || []; // Return early from calls with invalid selector or context

        if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
          return results;
        } // Try to shortcut find operations (as opposed to filters) in HTML documents


        if (!seed) {
          if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
            setDocument(context);
          }

          context = context || document;

          if (documentIsHTML) {
            // If the selector is sufficiently simple, try using a "get*By*" DOM method
            // (excepting DocumentFragment context, where the methods don't exist)
            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
              // ID selector
              if (m = match[1]) {
                // Document context
                if (nodeType === 9) {
                  if (elem = context.getElementById(m)) {
                    // Support: IE, Opera, Webkit
                    // TODO: identify versions
                    // getElementById can match elements by name instead of ID
                    if (elem.id === m) {
                      results.push(elem);
                      return results;
                    }
                  } else {
                    return results;
                  } // Element context

                } else {
                  // Support: IE, Opera, Webkit
                  // TODO: identify versions
                  // getElementById can match elements by name instead of ID
                  if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } // Type selector

              } else if (match[2]) {
                push.apply(results, context.getElementsByTagName(selector));
                return results; // Class selector
              } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                push.apply(results, context.getElementsByClassName(m));
                return results;
              }
            } // Take advantage of querySelectorAll


            if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
              if (nodeType !== 1) {
                newContext = context;
                newSelector = selector; // qSA looks outside Element context, which is not what we want
                // Thanks to Andrew Dupont for this workaround technique
                // Support: IE <=8
                // Exclude object elements
              } else if (context.nodeName.toLowerCase() !== "object") {
                // Capture the context ID, setting it first if necessary
                if (nid = context.getAttribute("id")) {
                  nid = nid.replace(rcssescape, fcssescape);
                } else {
                  context.setAttribute("id", nid = expando);
                } // Prefix every selector in the list


                groups = tokenize(selector);
                i = groups.length;

                while (i--) {
                  groups[i] = "#" + nid + " " + toSelector(groups[i]);
                }

                newSelector = groups.join(","); // Expand context for sibling selectors

                newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
              }

              if (newSelector) {
                try {
                  push.apply(results, newContext.querySelectorAll(newSelector));
                  return results;
                } catch (qsaError) {} finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          }
        } // All others


        return select(selector.replace(rtrim, "$1"), context, results, seed);
      }
      /**
       * Create key-value caches of limited size
       * @returns {function(string, object)} Returns the Object data after storing it on itself with
       *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
       *	deleting the oldest entry
       */


      function createCache() {
        var keys = [];

        function cache(key, value) {
          // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
          if (keys.push(key + " ") > Expr.cacheLength) {
            // Only keep the most recent entries
            delete cache[keys.shift()];
          }

          return cache[key + " "] = value;
        }

        return cache;
      }
      /**
       * Mark a function for special use by Sizzle
       * @param {Function} fn The function to mark
       */


      function markFunction(fn) {
        fn[expando] = true;
        return fn;
      }
      /**
       * Support testing using an element
       * @param {Function} fn Passed the created element and returns a boolean result
       */


      function assert(fn) {
        var el = document.createElement("fieldset");

        try {
          return !!fn(el);
        } catch (e) {
          return false;
        } finally {
          // Remove from its parent by default
          if (el.parentNode) {
            el.parentNode.removeChild(el);
          } // release memory in IE


          el = null;
        }
      }
      /**
       * Adds the same handler for all of the specified attrs
       * @param {String} attrs Pipe-separated list of attributes
       * @param {Function} handler The method that will be applied
       */


      function addHandle(attrs, handler) {
        var arr = attrs.split("|"),
            i = arr.length;

        while (i--) {
          Expr.attrHandle[arr[i]] = handler;
        }
      }
      /**
       * Checks document order of two siblings
       * @param {Element} a
       * @param {Element} b
       * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
       */


      function siblingCheck(a, b) {
        var cur = b && a,
            diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes

        if (diff) {
          return diff;
        } // Check if b follows a


        if (cur) {
          while (cur = cur.nextSibling) {
            if (cur === b) {
              return -1;
            }
          }
        }

        return a ? 1 : -1;
      }
      /**
       * Returns a function to use in pseudos for input types
       * @param {String} type
       */


      function createInputPseudo(type) {
        return function (elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === type;
        };
      }
      /**
       * Returns a function to use in pseudos for buttons
       * @param {String} type
       */


      function createButtonPseudo(type) {
        return function (elem) {
          var name = elem.nodeName.toLowerCase();
          return (name === "input" || name === "button") && elem.type === type;
        };
      }
      /**
       * Returns a function to use in pseudos for :enabled/:disabled
       * @param {Boolean} disabled true for :disabled; false for :enabled
       */


      function createDisabledPseudo(disabled) {
        // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
        return function (elem) {
          // Only certain elements can match :enabled or :disabled
          // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
          // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
          if ("form" in elem) {
            // Check for inherited disabledness on relevant non-disabled elements:
            // * listed form-associated elements in a disabled fieldset
            //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
            //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
            // * option elements in a disabled optgroup
            //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
            // All such elements have a "form" property.
            if (elem.parentNode && elem.disabled === false) {
              // Option elements defer to a parent optgroup if present
              if ("label" in elem) {
                if ("label" in elem.parentNode) {
                  return elem.parentNode.disabled === disabled;
                } else {
                  return elem.disabled === disabled;
                }
              } // Support: IE 6 - 11
              // Use the isDisabled shortcut property to check for disabled fieldset ancestors


              return elem.isDisabled === disabled || // Where there is no isDisabled, check manually

              /* jshint -W018 */
              elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
            }

            return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.
            // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
            // even exist on them, let alone have a boolean value.
          } else if ("label" in elem) {
            return elem.disabled === disabled;
          } // Remaining elements are neither :enabled nor :disabled


          return false;
        };
      }
      /**
       * Returns a function to use in pseudos for positionals
       * @param {Function} fn
       */


      function createPositionalPseudo(fn) {
        return markFunction(function (argument) {
          argument = +argument;
          return markFunction(function (seed, matches) {
            var j,
                matchIndexes = fn([], seed.length, argument),
                i = matchIndexes.length; // Match elements found at the specified indexes

            while (i--) {
              if (seed[j = matchIndexes[i]]) {
                seed[j] = !(matches[j] = seed[j]);
              }
            }
          });
        });
      }
      /**
       * Checks a node for validity as a Sizzle context
       * @param {Element|Object=} context
       * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
       */


      function testContext(context) {
        return context && typeof context.getElementsByTagName !== "undefined" && context;
      } // Expose support vars for convenience


      support = Sizzle.support = {};
      /**
       * Detects XML nodes
       * @param {Element|Object} elem An element or a document
       * @returns {Boolean} True iff elem is a non-HTML XML node
       */

      isXML = Sizzle.isXML = function (elem) {
        // documentElement is verified for cases where it doesn't yet exist
        // (such as loading iframes in IE - #4833)
        var documentElement = elem && (elem.ownerDocument || elem).documentElement;
        return documentElement ? documentElement.nodeName !== "HTML" : false;
      };
      /**
       * Sets document-related variables once based on the current document
       * @param {Element|Object} [doc] An element or document object to use to set the document
       * @returns {Object} Returns the current document
       */


      setDocument = Sizzle.setDocument = function (node) {
        var hasCompare,
            subWindow,
            doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected

        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
          return document;
        } // Update global variables


        document = doc;
        docElem = document.documentElement;
        documentIsHTML = !isXML(document); // Support: IE 9-11, Edge
        // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)

        if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
          // Support: IE 11, Edge
          if (subWindow.addEventListener) {
            subWindow.addEventListener("unload", unloadHandler, false); // Support: IE 9 - 10 only
          } else if (subWindow.attachEvent) {
            subWindow.attachEvent("onunload", unloadHandler);
          }
        }
        /* Attributes
        ---------------------------------------------------------------------- */
        // Support: IE<8
        // Verify that getAttribute really returns attributes and not properties
        // (excepting IE8 booleans)


        support.attributes = assert(function (el) {
          el.className = "i";
          return !el.getAttribute("className");
        });
        /* getElement(s)By*
        ---------------------------------------------------------------------- */
        // Check if getElementsByTagName("*") returns only elements

        support.getElementsByTagName = assert(function (el) {
          el.appendChild(document.createComment(""));
          return !el.getElementsByTagName("*").length;
        }); // Support: IE<9

        support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10
        // Check if getElementById returns elements by name
        // The broken getElementById methods don't pick up programmatically-set names,
        // so use a roundabout getElementsByName test

        support.getById = assert(function (el) {
          docElem.appendChild(el).id = expando;
          return !document.getElementsByName || !document.getElementsByName(expando).length;
        }); // ID filter and find

        if (support.getById) {
          Expr.filter["ID"] = function (id) {
            var attrId = id.replace(runescape, funescape);
            return function (elem) {
              return elem.getAttribute("id") === attrId;
            };
          };

          Expr.find["ID"] = function (id, context) {
            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
              var elem = context.getElementById(id);
              return elem ? [elem] : [];
            }
          };
        } else {
          Expr.filter["ID"] = function (id) {
            var attrId = id.replace(runescape, funescape);
            return function (elem) {
              var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
              return node && node.value === attrId;
            };
          }; // Support: IE 6 - 7 only
          // getElementById is not reliable as a find shortcut


          Expr.find["ID"] = function (id, context) {
            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
              var node,
                  i,
                  elems,
                  elem = context.getElementById(id);

              if (elem) {
                // Verify the id attribute
                node = elem.getAttributeNode("id");

                if (node && node.value === id) {
                  return [elem];
                } // Fall back on getElementsByName


                elems = context.getElementsByName(id);
                i = 0;

                while (elem = elems[i++]) {
                  node = elem.getAttributeNode("id");

                  if (node && node.value === id) {
                    return [elem];
                  }
                }
              }

              return [];
            }
          };
        } // Tag


        Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
          if (typeof context.getElementsByTagName !== "undefined") {
            return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN
          } else if (support.qsa) {
            return context.querySelectorAll(tag);
          }
        } : function (tag, context) {
          var elem,
              tmp = [],
              i = 0,
              // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
          results = context.getElementsByTagName(tag); // Filter out possible comments

          if (tag === "*") {
            while (elem = results[i++]) {
              if (elem.nodeType === 1) {
                tmp.push(elem);
              }
            }

            return tmp;
          }

          return results;
        }; // Class

        Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
          if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
            return context.getElementsByClassName(className);
          }
        };
        /* QSA/matchesSelector
        ---------------------------------------------------------------------- */
        // QSA and matchesSelector support
        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)


        rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)
        // We allow this because of a bug in IE8/9 that throws an error
        // whenever `document.activeElement` is accessed on an iframe
        // So, we allow :focus to pass through QSA all the time to avoid the IE error
        // See https://bugs.jquery.com/ticket/13378

        rbuggyQSA = [];

        if (support.qsa = rnative.test(document.querySelectorAll)) {
          // Build QSA regex
          // Regex strategy adopted from Diego Perini
          assert(function (el) {
            // Select is set to empty string on purpose
            // This is to test IE's treatment of not explicitly
            // setting a boolean content attribute,
            // since its presence should be enough
            // https://bugs.jquery.com/ticket/12359
            docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>"; // Support: IE8, Opera 11-12.16
            // Nothing should be selected when empty strings follow ^= or $= or *=
            // The test attribute must be unknown in Opera but "safe" for WinRT
            // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section

            if (el.querySelectorAll("[msallowcapture^='']").length) {
              rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
            } // Support: IE8
            // Boolean attributes and "value" are not treated correctly


            if (!el.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
            } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+


            if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            } // Webkit/Opera - :checked should return selected option elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            // IE8 throws error here and will not see later tests


            if (!el.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            } // Support: Safari 8+, iOS 8+
            // https://bugs.webkit.org/show_bug.cgi?id=136851
            // In-page `selector#id sibling-combinator selector` fails


            if (!el.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            }
          });
          assert(function (el) {
            el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>"; // Support: Windows 8 Native Apps
            // The type and name attributes are restricted during .innerHTML assignment

            var input = document.createElement("input");
            input.setAttribute("type", "hidden");
            el.appendChild(input).setAttribute("name", "D"); // Support: IE8
            // Enforce case-sensitivity of name attribute

            if (el.querySelectorAll("[name=d]").length) {
              rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
            } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
            // IE8 throws error here and will not see later tests


            if (el.querySelectorAll(":enabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            } // Support: IE9-11+
            // IE's :disabled selector does not pick up the children of disabled fieldsets


            docElem.appendChild(el).disabled = true;

            if (el.querySelectorAll(":disabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            } // Opera 10-11 does not throw on post-comma invalid pseudos


            el.querySelectorAll("*,:x");
            rbuggyQSA.push(",.*:");
          });
        }

        if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
          assert(function (el) {
            // Check to see if it's possible to do matchesSelector
            // on a disconnected node (IE 9)
            support.disconnectedMatch = matches.call(el, "*"); // This should fail with an exception
            // Gecko does not error, returns false instead

            matches.call(el, "[s!='']:x");
            rbuggyMatches.push("!=", pseudos);
          });
        }

        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
        /* Contains
        ---------------------------------------------------------------------- */

        hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another
        // Purposefully self-exclusive
        // As in, an element does not contain itself

        contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
          var adown = a.nodeType === 9 ? a.documentElement : a,
              bup = b && b.parentNode;
          return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
        } : function (a, b) {
          if (b) {
            while (b = b.parentNode) {
              if (b === a) {
                return true;
              }
            }
          }

          return false;
        };
        /* Sorting
        ---------------------------------------------------------------------- */
        // Document order sorting

        sortOrder = hasCompare ? function (a, b) {
          // Flag for duplicate removal
          if (a === b) {
            hasDuplicate = true;
            return 0;
          } // Sort on method existence if only one input has compareDocumentPosition


          var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;

          if (compare) {
            return compare;
          } // Calculate position if both inputs belong to the same document


          compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
          1; // Disconnected nodes

          if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
            // Choose the first element that is related to our preferred document
            if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
              return -1;
            }

            if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
              return 1;
            } // Maintain original order


            return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
          }

          return compare & 4 ? -1 : 1;
        } : function (a, b) {
          // Exit early if the nodes are identical
          if (a === b) {
            hasDuplicate = true;
            return 0;
          }

          var cur,
              i = 0,
              aup = a.parentNode,
              bup = b.parentNode,
              ap = [a],
              bp = [b]; // Parentless nodes are either documents or disconnected

          if (!aup || !bup) {
            return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check
          } else if (aup === bup) {
            return siblingCheck(a, b);
          } // Otherwise we need full lists of their ancestors for comparison


          cur = a;

          while (cur = cur.parentNode) {
            ap.unshift(cur);
          }

          cur = b;

          while (cur = cur.parentNode) {
            bp.unshift(cur);
          } // Walk down the tree looking for a discrepancy


          while (ap[i] === bp[i]) {
            i++;
          }

          return i ? // Do a sibling check if the nodes have a common ancestor
          siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
          ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
        };
        return document;
      };

      Sizzle.matches = function (expr, elements) {
        return Sizzle(expr, null, null, elements);
      };

      Sizzle.matchesSelector = function (elem, expr) {
        // Set document vars if needed
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        } // Make sure that attribute selectors are quoted


        expr = expr.replace(rattributeQuotes, "='$1']");

        if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
          try {
            var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes

            if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
            // fragment in IE 9
            elem.document && elem.document.nodeType !== 11) {
              return ret;
            }
          } catch (e) {}
        }

        return Sizzle(expr, document, null, [elem]).length > 0;
      };

      Sizzle.contains = function (context, elem) {
        // Set document vars if needed
        if ((context.ownerDocument || context) !== document) {
          setDocument(context);
        }

        return contains(context, elem);
      };

      Sizzle.attr = function (elem, name) {
        // Set document vars if needed
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }

        var fn = Expr.attrHandle[name.toLowerCase()],
            // Don't get fooled by Object.prototype properties (jQuery #13807)
        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
        return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
      };

      Sizzle.escape = function (sel) {
        return (sel + "").replace(rcssescape, fcssescape);
      };

      Sizzle.error = function (msg) {
        throw new Error("Syntax error, unrecognized expression: " + msg);
      };
      /**
       * Document sorting and removing duplicates
       * @param {ArrayLike} results
       */


      Sizzle.uniqueSort = function (results) {
        var elem,
            duplicates = [],
            j = 0,
            i = 0; // Unless we *know* we can detect duplicates, assume their presence

        hasDuplicate = !support.detectDuplicates;
        sortInput = !support.sortStable && results.slice(0);
        results.sort(sortOrder);

        if (hasDuplicate) {
          while (elem = results[i++]) {
            if (elem === results[i]) {
              j = duplicates.push(i);
            }
          }

          while (j--) {
            results.splice(duplicates[j], 1);
          }
        } // Clear input after sorting to release objects
        // See https://github.com/jquery/sizzle/pull/225


        sortInput = null;
        return results;
      };
      /**
       * Utility function for retrieving the text value of an array of DOM nodes
       * @param {Array|Element} elem
       */


      getText = Sizzle.getText = function (elem) {
        var node,
            ret = "",
            i = 0,
            nodeType = elem.nodeType;

        if (!nodeType) {
          // If no nodeType, this is expected to be an array
          while (node = elem[i++]) {
            // Do not traverse comment nodes
            ret += getText(node);
          }
        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
          // Use textContent for elements
          // innerText usage removed for consistency of new lines (jQuery #11153)
          if (typeof elem.textContent === "string") {
            return elem.textContent;
          } else {
            // Traverse its children
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              ret += getText(elem);
            }
          }
        } else if (nodeType === 3 || nodeType === 4) {
          return elem.nodeValue;
        } // Do not include comment or processing instruction nodes


        return ret;
      };

      Expr = Sizzle.selectors = {
        // Can be adjusted by the user
        cacheLength: 50,
        createPseudo: markFunction,
        match: matchExpr,
        attrHandle: {},
        find: {},
        relative: {
          ">": {
            dir: "parentNode",
            first: true
          },
          " ": {
            dir: "parentNode"
          },
          "+": {
            dir: "previousSibling",
            first: true
          },
          "~": {
            dir: "previousSibling"
          }
        },
        preFilter: {
          "ATTR": function (match) {
            match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted

            match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

            if (match[2] === "~=") {
              match[3] = " " + match[3] + " ";
            }

            return match.slice(0, 4);
          },
          "CHILD": function (match) {
            /* matches from matchExpr["CHILD"]
            	1 type (only|nth|...)
            	2 what (child|of-type)
            	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
            	4 xn-component of xn+y argument ([+-]?\d*n|)
            	5 sign of xn-component
            	6 x of xn-component
            	7 sign of y-component
            	8 y of y-component
            */
            match[1] = match[1].toLowerCase();

            if (match[1].slice(0, 3) === "nth") {
              // nth-* requires argument
              if (!match[3]) {
                Sizzle.error(match[0]);
              } // numeric x and y parameters for Expr.filter.CHILD
              // remember that false/true cast respectively to 0/1


              match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
              match[5] = +(match[7] + match[8] || match[3] === "odd"); // other types prohibit arguments
            } else if (match[3]) {
              Sizzle.error(match[0]);
            }

            return match;
          },
          "PSEUDO": function (match) {
            var excess,
                unquoted = !match[6] && match[2];

            if (matchExpr["CHILD"].test(match[0])) {
              return null;
            } // Accept quoted arguments as-is


            if (match[3]) {
              match[2] = match[4] || match[5] || ""; // Strip excess characters from unquoted arguments
            } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)
            excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis
            excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
              // excess is a negative index
              match[0] = match[0].slice(0, excess);
              match[2] = unquoted.slice(0, excess);
            } // Return only captures needed by the pseudo filter method (type and argument)


            return match.slice(0, 3);
          }
        },
        filter: {
          "TAG": function (nodeNameSelector) {
            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
            return nodeNameSelector === "*" ? function () {
              return true;
            } : function (elem) {
              return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
            };
          },
          "CLASS": function (className) {
            var pattern = classCache[className + " "];
            return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
              return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
            });
          },
          "ATTR": function (name, operator, check) {
            return function (elem) {
              var result = Sizzle.attr(elem, name);

              if (result == null) {
                return operator === "!=";
              }

              if (!operator) {
                return true;
              }

              result += "";
              return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
            };
          },
          "CHILD": function (type, what, argument, first, last) {
            var simple = type.slice(0, 3) !== "nth",
                forward = type.slice(-4) !== "last",
                ofType = what === "of-type";
            return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
            function (elem) {
              return !!elem.parentNode;
            } : function (elem, context, xml) {
              var cache,
                  uniqueCache,
                  outerCache,
                  node,
                  nodeIndex,
                  start,
                  dir = simple !== forward ? "nextSibling" : "previousSibling",
                  parent = elem.parentNode,
                  name = ofType && elem.nodeName.toLowerCase(),
                  useCache = !xml && !ofType,
                  diff = false;

              if (parent) {
                // :(first|last|only)-(child|of-type)
                if (simple) {
                  while (dir) {
                    node = elem;

                    while (node = node[dir]) {
                      if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                        return false;
                      }
                    } // Reverse direction for :only-* (if we haven't yet done so)


                    start = dir = type === "only" && !start && "nextSibling";
                  }

                  return true;
                }

                start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`

                if (forward && useCache) {
                  // Seek `elem` from a previously-cached index
                  // ...in a gzip-friendly way
                  node = parent;
                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                  // Defend against cloned attroperties (jQuery gh-1709)

                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex && cache[2];
                  node = nodeIndex && parent.childNodes[nodeIndex];

                  while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start
                  diff = nodeIndex = 0) || start.pop()) {
                    // When found, cache indexes on `parent` and break
                    if (node.nodeType === 1 && ++diff && node === elem) {
                      uniqueCache[type] = [dirruns, nodeIndex, diff];
                      break;
                    }
                  }
                } else {
                  // Use previously-cached element index if available
                  if (useCache) {
                    // ...in a gzip-friendly way
                    node = elem;
                    outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                    // Defend against cloned attroperties (jQuery gh-1709)

                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                    cache = uniqueCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = nodeIndex;
                  } // xml :nth-child(...)
                  // or :nth-last-child(...) or :nth(-last)?-of-type(...)


                  if (diff === false) {
                    // Use the same loop as above to seek `elem` from the start
                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                      if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                        // Cache the index of each encountered element
                        if (useCache) {
                          outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                          // Defend against cloned attroperties (jQuery gh-1709)

                          uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                          uniqueCache[type] = [dirruns, diff];
                        }

                        if (node === elem) {
                          break;
                        }
                      }
                    }
                  }
                } // Incorporate the offset, then check against cycle size


                diff -= last;
                return diff === first || diff % first === 0 && diff / first >= 0;
              }
            };
          },
          "PSEUDO": function (pseudo, argument) {
            // pseudo-class names are case-insensitive
            // http://www.w3.org/TR/selectors/#pseudo-classes
            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
            // Remember that setFilters inherits from pseudos
            var args,
                fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo); // The user may use createPseudo to indicate that
            // arguments are needed to create the filter function
            // just as Sizzle does

            if (fn[expando]) {
              return fn(argument);
            } // But maintain support for old signatures


            if (fn.length > 1) {
              args = [pseudo, pseudo, "", argument];
              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                var idx,
                    matched = fn(seed, argument),
                    i = matched.length;

                while (i--) {
                  idx = indexOf(seed, matched[i]);
                  seed[idx] = !(matches[idx] = matched[i]);
                }
              }) : function (elem) {
                return fn(elem, 0, args);
              };
            }

            return fn;
          }
        },
        pseudos: {
          // Potentially complex pseudos
          "not": markFunction(function (selector) {
            // Trim the selector passed to compile
            // to avoid treating leading and trailing
            // spaces as combinators
            var input = [],
                results = [],
                matcher = compile(selector.replace(rtrim, "$1"));
            return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
              var elem,
                  unmatched = matcher(seed, null, xml, []),
                  i = seed.length; // Match elements unmatched by `matcher`

              while (i--) {
                if (elem = unmatched[i]) {
                  seed[i] = !(matches[i] = elem);
                }
              }
            }) : function (elem, context, xml) {
              input[0] = elem;
              matcher(input, null, xml, results); // Don't keep the element (issue #299)

              input[0] = null;
              return !results.pop();
            };
          }),
          "has": markFunction(function (selector) {
            return function (elem) {
              return Sizzle(selector, elem).length > 0;
            };
          }),
          "contains": markFunction(function (text) {
            text = text.replace(runescape, funescape);
            return function (elem) {
              return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
            };
          }),
          // "Whether an element is represented by a :lang() selector
          // is based solely on the element's language value
          // being equal to the identifier C,
          // or beginning with the identifier C immediately followed by "-".
          // The matching of C against the element's language value is performed case-insensitively.
          // The identifier C does not have to be a valid language name."
          // http://www.w3.org/TR/selectors/#lang-pseudo
          "lang": markFunction(function (lang) {
            // lang value must be a valid identifier
            if (!ridentifier.test(lang || "")) {
              Sizzle.error("unsupported lang: " + lang);
            }

            lang = lang.replace(runescape, funescape).toLowerCase();
            return function (elem) {
              var elemLang;

              do {
                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                  elemLang = elemLang.toLowerCase();
                  return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                }
              } while ((elem = elem.parentNode) && elem.nodeType === 1);

              return false;
            };
          }),
          // Miscellaneous
          "target": function (elem) {
            var hash = window.location && window.location.hash;
            return hash && hash.slice(1) === elem.id;
          },
          "root": function (elem) {
            return elem === docElem;
          },
          "focus": function (elem) {
            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
          },
          // Boolean properties
          "enabled": createDisabledPseudo(false),
          "disabled": createDisabledPseudo(true),
          "checked": function (elem) {
            // In CSS3, :checked should return both checked and selected elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            var nodeName = elem.nodeName.toLowerCase();
            return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
          },
          "selected": function (elem) {
            // Accessing this property makes selected-by-default
            // options in Safari work properly
            if (elem.parentNode) {
              elem.parentNode.selectedIndex;
            }

            return elem.selected === true;
          },
          // Contents
          "empty": function (elem) {
            // http://www.w3.org/TR/selectors/#empty-pseudo
            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
            //   but not by others (comment: 8; processing instruction: 7; etc.)
            // nodeType < 6 works because attributes (2) do not appear as children
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              if (elem.nodeType < 6) {
                return false;
              }
            }

            return true;
          },
          "parent": function (elem) {
            return !Expr.pseudos["empty"](elem);
          },
          // Element/input types
          "header": function (elem) {
            return rheader.test(elem.nodeName);
          },
          "input": function (elem) {
            return rinputs.test(elem.nodeName);
          },
          "button": function (elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === "button" || name === "button";
          },
          "text": function (elem) {
            var attr;
            return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ( // Support: IE<8
            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
            (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
          },
          // Position-in-collection
          "first": createPositionalPseudo(function () {
            return [0];
          }),
          "last": createPositionalPseudo(function (matchIndexes, length) {
            return [length - 1];
          }),
          "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
            return [argument < 0 ? argument + length : argument];
          }),
          "even": createPositionalPseudo(function (matchIndexes, length) {
            var i = 0;

            for (; i < length; i += 2) {
              matchIndexes.push(i);
            }

            return matchIndexes;
          }),
          "odd": createPositionalPseudo(function (matchIndexes, length) {
            var i = 1;

            for (; i < length; i += 2) {
              matchIndexes.push(i);
            }

            return matchIndexes;
          }),
          "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;

            for (; --i >= 0;) {
              matchIndexes.push(i);
            }

            return matchIndexes;
          }),
          "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;

            for (; ++i < length;) {
              matchIndexes.push(i);
            }

            return matchIndexes;
          })
        }
      };
      Expr.pseudos["nth"] = Expr.pseudos["eq"]; // Add button/input type pseudos

      for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true
      }) {
        Expr.pseudos[i] = createInputPseudo(i);
      }

      for (i in {
        submit: true,
        reset: true
      }) {
        Expr.pseudos[i] = createButtonPseudo(i);
      } // Easy API for creating new setFilters


      function setFilters() {}

      setFilters.prototype = Expr.filters = Expr.pseudos;
      Expr.setFilters = new setFilters();

      tokenize = Sizzle.tokenize = function (selector, parseOnly) {
        var matched,
            match,
            tokens,
            type,
            soFar,
            groups,
            preFilters,
            cached = tokenCache[selector + " "];

        if (cached) {
          return parseOnly ? 0 : cached.slice(0);
        }

        soFar = selector;
        groups = [];
        preFilters = Expr.preFilter;

        while (soFar) {
          // Comma and first run
          if (!matched || (match = rcomma.exec(soFar))) {
            if (match) {
              // Don't consume trailing commas as valid
              soFar = soFar.slice(match[0].length) || soFar;
            }

            groups.push(tokens = []);
          }

          matched = false; // Combinators

          if (match = rcombinators.exec(soFar)) {
            matched = match.shift();
            tokens.push({
              value: matched,
              // Cast descendant combinators to space
              type: match[0].replace(rtrim, " ")
            });
            soFar = soFar.slice(matched.length);
          } // Filters


          for (type in Expr.filter) {
            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
              matched = match.shift();
              tokens.push({
                value: matched,
                type: type,
                matches: match
              });
              soFar = soFar.slice(matched.length);
            }
          }

          if (!matched) {
            break;
          }
        } // Return the length of the invalid excess
        // if we're just parsing
        // Otherwise, throw an error or return tokens


        return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
        tokenCache(selector, groups).slice(0);
      };

      function toSelector(tokens) {
        var i = 0,
            len = tokens.length,
            selector = "";

        for (; i < len; i++) {
          selector += tokens[i].value;
        }

        return selector;
      }

      function addCombinator(matcher, combinator, base) {
        var dir = combinator.dir,
            skip = combinator.next,
            key = skip || dir,
            checkNonElements = base && key === "parentNode",
            doneName = done++;
        return combinator.first ? // Check against closest ancestor/preceding element
        function (elem, context, xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              return matcher(elem, context, xml);
            }
          }

          return false;
        } : // Check against all ancestor/preceding elements
        function (elem, context, xml) {
          var oldCache,
              uniqueCache,
              outerCache,
              newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching

          if (xml) {
            while (elem = elem[dir]) {
              if (elem.nodeType === 1 || checkNonElements) {
                if (matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          } else {
            while (elem = elem[dir]) {
              if (elem.nodeType === 1 || checkNonElements) {
                outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only
                // Defend against cloned attroperties (jQuery gh-1709)

                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

                if (skip && skip === elem.nodeName.toLowerCase()) {
                  elem = elem[dir] || elem;
                } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                  // Assign to newCache so results back-propagate to previous elements
                  return newCache[2] = oldCache[2];
                } else {
                  // Reuse newcache so results back-propagate to previous elements
                  uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking

                  if (newCache[2] = matcher(elem, context, xml)) {
                    return true;
                  }
                }
              }
            }
          }

          return false;
        };
      }

      function elementMatcher(matchers) {
        return matchers.length > 1 ? function (elem, context, xml) {
          var i = matchers.length;

          while (i--) {
            if (!matchers[i](elem, context, xml)) {
              return false;
            }
          }

          return true;
        } : matchers[0];
      }

      function multipleContexts(selector, contexts, results) {
        var i = 0,
            len = contexts.length;

        for (; i < len; i++) {
          Sizzle(selector, contexts[i], results);
        }

        return results;
      }

      function condense(unmatched, map, filter, context, xml) {
        var elem,
            newUnmatched = [],
            i = 0,
            len = unmatched.length,
            mapped = map != null;

        for (; i < len; i++) {
          if (elem = unmatched[i]) {
            if (!filter || filter(elem, context, xml)) {
              newUnmatched.push(elem);

              if (mapped) {
                map.push(i);
              }
            }
          }
        }

        return newUnmatched;
      }

      function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
        if (postFilter && !postFilter[expando]) {
          postFilter = setMatcher(postFilter);
        }

        if (postFinder && !postFinder[expando]) {
          postFinder = setMatcher(postFinder, postSelector);
        }

        return markFunction(function (seed, results, context, xml) {
          var temp,
              i,
              elem,
              preMap = [],
              postMap = [],
              preexisting = results.length,
              // Get initial elements from seed or context
          elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
              // Prefilter to get matcher input, preserving a map for seed-results synchronization
          matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
              matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
          postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
          [] : // ...otherwise use results directly
          results : matcherIn; // Find primary matches

          if (matcher) {
            matcher(matcherIn, matcherOut, context, xml);
          } // Apply postFilter


          if (postFilter) {
            temp = condense(matcherOut, postMap);
            postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn

            i = temp.length;

            while (i--) {
              if (elem = temp[i]) {
                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
              }
            }
          }

          if (seed) {
            if (postFinder || preFilter) {
              if (postFinder) {
                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                temp = [];
                i = matcherOut.length;

                while (i--) {
                  if (elem = matcherOut[i]) {
                    // Restore matcherIn since elem is not yet a final match
                    temp.push(matcherIn[i] = elem);
                  }
                }

                postFinder(null, matcherOut = [], temp, xml);
              } // Move matched elements from seed to results to keep them synchronized


              i = matcherOut.length;

              while (i--) {
                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                  seed[temp] = !(results[temp] = elem);
                }
              }
            } // Add elements to results, through postFinder if defined

          } else {
            matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);

            if (postFinder) {
              postFinder(null, results, matcherOut, xml);
            } else {
              push.apply(results, matcherOut);
            }
          }
        });
      }

      function matcherFromTokens(tokens) {
        var checkContext,
            matcher,
            j,
            len = tokens.length,
            leadingRelative = Expr.relative[tokens[0].type],
            implicitRelative = leadingRelative || Expr.relative[" "],
            i = leadingRelative ? 1 : 0,
            // The foundational matcher ensures that elements are reachable from top-level context(s)
        matchContext = addCombinator(function (elem) {
          return elem === checkContext;
        }, implicitRelative, true),
            matchAnyContext = addCombinator(function (elem) {
          return indexOf(checkContext, elem) > -1;
        }, implicitRelative, true),
            matchers = [function (elem, context, xml) {
          var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)

          checkContext = null;
          return ret;
        }];

        for (; i < len; i++) {
          if (matcher = Expr.relative[tokens[i].type]) {
            matchers = [addCombinator(elementMatcher(matchers), matcher)];
          } else {
            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher

            if (matcher[expando]) {
              // Find the next relative operator (if any) for proper handling
              j = ++i;

              for (; j < len; j++) {
                if (Expr.relative[tokens[j].type]) {
                  break;
                }
              }

              return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`
              tokens.slice(0, i - 1).concat({
                value: tokens[i - 2].type === " " ? "*" : ""
              })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
            }

            matchers.push(matcher);
          }
        }

        return elementMatcher(matchers);
      }

      function matcherFromGroupMatchers(elementMatchers, setMatchers) {
        var bySet = setMatchers.length > 0,
            byElement = elementMatchers.length > 0,
            superMatcher = function (seed, context, xml, results, outermost) {
          var elem,
              j,
              matcher,
              matchedCount = 0,
              i = "0",
              unmatched = seed && [],
              setMatched = [],
              contextBackup = outermostContext,
              // We must always have either seed elements or outermost context
          elems = seed || byElement && Expr.find["TAG"]("*", outermost),
              // Use integer dirruns iff this is the outermost matcher
          dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
              len = elems.length;

          if (outermost) {
            outermostContext = context === document || context || outermost;
          } // Add elements passing elementMatchers directly to results
          // Support: IE<9, Safari
          // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id


          for (; i !== len && (elem = elems[i]) != null; i++) {
            if (byElement && elem) {
              j = 0;

              if (!context && elem.ownerDocument !== document) {
                setDocument(elem);
                xml = !documentIsHTML;
              }

              while (matcher = elementMatchers[j++]) {
                if (matcher(elem, context || document, xml)) {
                  results.push(elem);
                  break;
                }
              }

              if (outermost) {
                dirruns = dirrunsUnique;
              }
            } // Track unmatched elements for set filters


            if (bySet) {
              // They will have gone through all possible matchers
              if (elem = !matcher && elem) {
                matchedCount--;
              } // Lengthen the array for every element, matched or not


              if (seed) {
                unmatched.push(elem);
              }
            }
          } // `i` is now the count of elements visited above, and adding it to `matchedCount`
          // makes the latter nonnegative.


          matchedCount += i; // Apply set filters to unmatched elements
          // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
          // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
          // no element matchers and no seed.
          // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
          // case, which will result in a "00" `matchedCount` that differs from `i` but is also
          // numerically zero.

          if (bySet && i !== matchedCount) {
            j = 0;

            while (matcher = setMatchers[j++]) {
              matcher(unmatched, setMatched, context, xml);
            }

            if (seed) {
              // Reintegrate element matches to eliminate the need for sorting
              if (matchedCount > 0) {
                while (i--) {
                  if (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              } // Discard index placeholder values to get only actual matches


              setMatched = condense(setMatched);
            } // Add matches to results


            push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting

            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
              Sizzle.uniqueSort(results);
            }
          } // Override manipulation of globals by nested matchers


          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }

          return unmatched;
        };

        return bySet ? markFunction(superMatcher) : superMatcher;
      }

      compile = Sizzle.compile = function (selector, match
      /* Internal Use Only */
      ) {
        var i,
            setMatchers = [],
            elementMatchers = [],
            cached = compilerCache[selector + " "];

        if (!cached) {
          // Generate a function of recursive functions that can be used to check each element
          if (!match) {
            match = tokenize(selector);
          }

          i = match.length;

          while (i--) {
            cached = matcherFromTokens(match[i]);

            if (cached[expando]) {
              setMatchers.push(cached);
            } else {
              elementMatchers.push(cached);
            }
          } // Cache the compiled function


          cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization

          cached.selector = selector;
        }

        return cached;
      };
      /**
       * A low-level selection function that works with Sizzle's compiled
       *  selector functions
       * @param {String|Function} selector A selector or a pre-compiled
       *  selector function built with Sizzle.compile
       * @param {Element} context
       * @param {Array} [results]
       * @param {Array} [seed] A set of elements to match against
       */


      select = Sizzle.select = function (selector, context, results, seed) {
        var i,
            tokens,
            token,
            type,
            find,
            compiled = typeof selector === "function" && selector,
            match = !seed && tokenize(selector = compiled.selector || selector);
        results = results || []; // Try to minimize operations if there is only one selector in the list and no seed
        // (the latter of which guarantees us context)

        if (match.length === 1) {
          // Reduce context if the leading compound selector is an ID
          tokens = match[0] = match[0].slice(0);

          if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
            context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];

            if (!context) {
              return results; // Precompiled matchers will still verify ancestry, so step up a level
            } else if (compiled) {
              context = context.parentNode;
            }

            selector = selector.slice(tokens.shift().value.length);
          } // Fetch a seed set for right-to-left matching


          i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;

          while (i--) {
            token = tokens[i]; // Abort if we hit a combinator

            if (Expr.relative[type = token.type]) {
              break;
            }

            if (find = Expr.find[type]) {
              // Search, expanding context for leading sibling combinators
              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                // If seed is empty or no tokens remain, we can return early
                tokens.splice(i, 1);
                selector = seed.length && toSelector(tokens);

                if (!selector) {
                  push.apply(results, seed);
                  return results;
                }

                break;
              }
            }
          }
        } // Compile and execute a filtering function if one is not provided
        // Provide `match` to avoid retokenization if we modified the selector above


        (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
        return results;
      }; // One-time assignments
      // Sort stability


      support.sortStable = expando.split("").sort(sortOrder).join("") === expando; // Support: Chrome 14-35+
      // Always assume duplicates if they aren't passed to the comparison function

      support.detectDuplicates = !!hasDuplicate; // Initialize against the default document

      setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
      // Detached nodes confoundingly follow *each other*

      support.sortDetached = assert(function (el) {
        // Should return 1, but returns 4 (following)
        return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
      }); // Support: IE<8
      // Prevent attribute/property "interpolation"
      // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx

      if (!assert(function (el) {
        el.innerHTML = "<a href='#'></a>";
        return el.firstChild.getAttribute("href") === "#";
      })) {
        addHandle("type|href|height|width", function (elem, name, isXML) {
          if (!isXML) {
            return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
          }
        });
      } // Support: IE<9
      // Use defaultValue in place of getAttribute("value")


      if (!support.attributes || !assert(function (el) {
        el.innerHTML = "<input/>";
        el.firstChild.setAttribute("value", "");
        return el.firstChild.getAttribute("value") === "";
      })) {
        addHandle("value", function (elem, name, isXML) {
          if (!isXML && elem.nodeName.toLowerCase() === "input") {
            return elem.defaultValue;
          }
        });
      } // Support: IE<9
      // Use getAttributeNode to fetch booleans when getAttribute lies


      if (!assert(function (el) {
        return el.getAttribute("disabled") == null;
      })) {
        addHandle(booleans, function (elem, name, isXML) {
          var val;

          if (!isXML) {
            return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
          }
        });
      }

      return Sizzle;
    }(window);

    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors; // Deprecated

    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    jQuery.escapeSelector = Sizzle.escape;

    var dir = function (elem, dir, until) {
      var matched = [],
          truncate = until !== undefined;

      while ((elem = elem[dir]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }

          matched.push(elem);
        }
      }

      return matched;
    };

    var siblings = function (n, elem) {
      var matched = [];

      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }

      return matched;
    };

    var rneedsContext = jQuery.expr.match.needsContext;
    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    var risSimple = /^.[^:#\[\.,]*$/; // Implement the identical functionality for filter and not

    function winnow(elements, qualifier, not) {
      if (jQuery.isFunction(qualifier)) {
        return jQuery.grep(elements, function (elem, i) {
          return !!qualifier.call(elem, i, elem) !== not;
        });
      } // Single element


      if (qualifier.nodeType) {
        return jQuery.grep(elements, function (elem) {
          return elem === qualifier !== not;
        });
      } // Arraylike of elements (jQuery, arguments, Array)


      if (typeof qualifier !== "string") {
        return jQuery.grep(elements, function (elem) {
          return indexOf.call(qualifier, elem) > -1 !== not;
        });
      } // Simple selector that can be filtered directly, removing non-Elements


      if (risSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      } // Complex selector, compare the two sets, removing non-Elements


      qualifier = jQuery.filter(qualifier, elements);
      return jQuery.grep(elements, function (elem) {
        return indexOf.call(qualifier, elem) > -1 !== not && elem.nodeType === 1;
      });
    }

    jQuery.filter = function (expr, elems, not) {
      var elem = elems[0];

      if (not) {
        expr = ":not(" + expr + ")";
      }

      if (elems.length === 1 && elem.nodeType === 1) {
        return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
      }

      return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
        return elem.nodeType === 1;
      }));
    };

    jQuery.fn.extend({
      find: function (selector) {
        var i,
            ret,
            len = this.length,
            self = this;

        if (typeof selector !== "string") {
          return this.pushStack(jQuery(selector).filter(function () {
            for (i = 0; i < len; i++) {
              if (jQuery.contains(self[i], this)) {
                return true;
              }
            }
          }));
        }

        ret = this.pushStack([]);

        for (i = 0; i < len; i++) {
          jQuery.find(selector, self[i], ret);
        }

        return len > 1 ? jQuery.uniqueSort(ret) : ret;
      },
      filter: function (selector) {
        return this.pushStack(winnow(this, selector || [], false));
      },
      not: function (selector) {
        return this.pushStack(winnow(this, selector || [], true));
      },
      is: function (selector) {
        return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
        // so $("p:first").is("p:last") won't return true for a doc with two "p".
        typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
      }
    }); // Initialize a jQuery object
    // A central reference to the root jQuery(document)

    var rootjQuery,
        // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    // Shortcut simple #id case for speed
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
        init = jQuery.fn.init = function (selector, context, root) {
      var match, elem; // HANDLE: $(""), $(null), $(undefined), $(false)

      if (!selector) {
        return this;
      } // Method init() accepts an alternate rootjQuery
      // so migrate can support jQuery.sub (gh-2101)


      root = root || rootjQuery; // Handle HTML strings

      if (typeof selector === "string") {
        if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
          // Assume that strings that start and end with <> are HTML and skip the regex check
          match = [null, selector, null];
        } else {
          match = rquickExpr.exec(selector);
        } // Match html or make sure no context is specified for #id


        if (match && (match[1] || !context)) {
          // HANDLE: $(html) -> $(array)
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat
            // Intentionally let the error be thrown if parseHTML is not present

            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)

            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              for (match in context) {
                // Properties of context are called as methods if possible
                if (jQuery.isFunction(this[match])) {
                  this[match](context[match]); // ...and otherwise set as attributes
                } else {
                  this.attr(match, context[match]);
                }
              }
            }

            return this; // HANDLE: $(#id)
          } else {
            elem = document.getElementById(match[2]);

            if (elem) {
              // Inject the element directly into the jQuery object
              this[0] = elem;
              this.length = 1;
            }

            return this;
          } // HANDLE: $(expr, $(...))

        } else if (!context || context.jquery) {
          return (context || root).find(selector); // HANDLE: $(expr, context)
          // (which is just equivalent to: $(context).find(expr)
        } else {
          return this.constructor(context).find(selector);
        } // HANDLE: $(DOMElement)

      } else if (selector.nodeType) {
        this[0] = selector;
        this.length = 1;
        return this; // HANDLE: $(function)
        // Shortcut for document ready
      } else if (jQuery.isFunction(selector)) {
        return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
        selector(jQuery);
      }

      return jQuery.makeArray(selector, this);
    }; // Give the init function the jQuery prototype for later instantiation


    init.prototype = jQuery.fn; // Initialize central reference

    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/,
        // Methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
    jQuery.fn.extend({
      has: function (target) {
        var targets = jQuery(target, this),
            l = targets.length;
        return this.filter(function () {
          var i = 0;

          for (; i < l; i++) {
            if (jQuery.contains(this, targets[i])) {
              return true;
            }
          }
        });
      },
      closest: function (selectors, context) {
        var cur,
            i = 0,
            l = this.length,
            matched = [],
            targets = typeof selectors !== "string" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context

        if (!rneedsContext.test(selectors)) {
          for (; i < l; i++) {
            for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
              // Always skip document fragments
              if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle
              cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                matched.push(cur);
                break;
              }
            }
          }
        }

        return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
      },
      // Determine the position of an element within the set
      index: function (elem) {
        // No argument, return index in parent
        if (!elem) {
          return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        } // Index in selector


        if (typeof elem === "string") {
          return indexOf.call(jQuery(elem), this[0]);
        } // Locate the position of the desired element


        return indexOf.call(this, // If it receives a jQuery object, the first element is used
        elem.jquery ? elem[0] : elem);
      },
      add: function (selector, context) {
        return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
      },
      addBack: function (selector) {
        return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
      }
    });

    function sibling(cur, dir) {
      while ((cur = cur[dir]) && cur.nodeType !== 1) {}

      return cur;
    }

    jQuery.each({
      parent: function (elem) {
        var parent = elem.parentNode;
        return parent && parent.nodeType !== 11 ? parent : null;
      },
      parents: function (elem) {
        return dir(elem, "parentNode");
      },
      parentsUntil: function (elem, i, until) {
        return dir(elem, "parentNode", until);
      },
      next: function (elem) {
        return sibling(elem, "nextSibling");
      },
      prev: function (elem) {
        return sibling(elem, "previousSibling");
      },
      nextAll: function (elem) {
        return dir(elem, "nextSibling");
      },
      prevAll: function (elem) {
        return dir(elem, "previousSibling");
      },
      nextUntil: function (elem, i, until) {
        return dir(elem, "nextSibling", until);
      },
      prevUntil: function (elem, i, until) {
        return dir(elem, "previousSibling", until);
      },
      siblings: function (elem) {
        return siblings((elem.parentNode || {}).firstChild, elem);
      },
      children: function (elem) {
        return siblings(elem.firstChild);
      },
      contents: function (elem) {
        return elem.contentDocument || jQuery.merge([], elem.childNodes);
      }
    }, function (name, fn) {
      jQuery.fn[name] = function (until, selector) {
        var matched = jQuery.map(this, fn, until);

        if (name.slice(-5) !== "Until") {
          selector = until;
        }

        if (selector && typeof selector === "string") {
          matched = jQuery.filter(selector, matched);
        }

        if (this.length > 1) {
          // Remove duplicates
          if (!guaranteedUnique[name]) {
            jQuery.uniqueSort(matched);
          } // Reverse order for parents* and prev-derivatives


          if (rparentsprev.test(name)) {
            matched.reverse();
          }
        }

        return this.pushStack(matched);
      };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g; // Convert String-formatted options into Object-formatted ones

    function createOptions(options) {
      var object = {};
      jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
        object[flag] = true;
      });
      return object;
    }
    /*
     * Create a callback list using the following parameters:
     *
     *	options: an optional list of space-separated options that will change how
     *			the callback list behaves or a more traditional option object
     *
     * By default a callback list will act like an event callback list and can be
     * "fired" multiple times.
     *
     * Possible options:
     *
     *	once:			will ensure the callback list can only be fired once (like a Deferred)
     *
     *	memory:			will keep track of previous values and will call any callback added
     *					after the list has been fired right away with the latest "memorized"
     *					values (like a Deferred)
     *
     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
     *
     *	stopOnFalse:	interrupt callings when a callback returns false
     *
     */


    jQuery.Callbacks = function (options) {
      // Convert options from String-formatted to Object-formatted if needed
      // (we check in cache first)
      options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

      var // Flag to know if list is currently firing
      firing,
          // Last fire value for non-forgettable lists
      memory,
          // Flag to know if list was already fired
      fired,
          // Flag to prevent firing
      locked,
          // Actual callback list
      list = [],
          // Queue of execution data for repeatable lists
      queue = [],
          // Index of currently firing callback (modified by add/remove as needed)
      firingIndex = -1,
          // Fire callbacks
      fire = function () {
        // Enforce single-firing
        locked = options.once; // Execute callbacks for all pending executions,
        // respecting firingIndex overrides and runtime changes

        fired = firing = true;

        for (; queue.length; firingIndex = -1) {
          memory = queue.shift();

          while (++firingIndex < list.length) {
            // Run callback and check for early termination
            if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
              // Jump to end and forget the data so .add doesn't re-fire
              firingIndex = list.length;
              memory = false;
            }
          }
        } // Forget the data if we're done with it


        if (!options.memory) {
          memory = false;
        }

        firing = false; // Clean up if we're done firing for good

        if (locked) {
          // Keep an empty list if we have data for future add calls
          if (memory) {
            list = []; // Otherwise, this object is spent
          } else {
            list = "";
          }
        }
      },
          // Actual Callbacks object
      self = {
        // Add a callback or a collection of callbacks to the list
        add: function () {
          if (list) {
            // If we have memory from a past run, we should fire after adding
            if (memory && !firing) {
              firingIndex = list.length - 1;
              queue.push(memory);
            }

            (function add(args) {
              jQuery.each(args, function (_, arg) {
                if (jQuery.isFunction(arg)) {
                  if (!options.unique || !self.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && jQuery.type(arg) !== "string") {
                  // Inspect recursively
                  add(arg);
                }
              });
            })(arguments);

            if (memory && !firing) {
              fire();
            }
          }

          return this;
        },
        // Remove a callback from the list
        remove: function () {
          jQuery.each(arguments, function (_, arg) {
            var index;

            while ((index = jQuery.inArray(arg, list, index)) > -1) {
              list.splice(index, 1); // Handle firing indexes

              if (index <= firingIndex) {
                firingIndex--;
              }
            }
          });
          return this;
        },
        // Check if a given callback is in the list.
        // If no argument is given, return whether or not list has callbacks attached.
        has: function (fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
        },
        // Remove all callbacks from the list
        empty: function () {
          if (list) {
            list = [];
          }

          return this;
        },
        // Disable .fire and .add
        // Abort any current/pending executions
        // Clear all callbacks and values
        disable: function () {
          locked = queue = [];
          list = memory = "";
          return this;
        },
        disabled: function () {
          return !list;
        },
        // Disable .fire
        // Also disable .add unless we have memory (since it would have no effect)
        // Abort any pending executions
        lock: function () {
          locked = queue = [];

          if (!memory && !firing) {
            list = memory = "";
          }

          return this;
        },
        locked: function () {
          return !!locked;
        },
        // Call all callbacks with the given context and arguments
        fireWith: function (context, args) {
          if (!locked) {
            args = args || [];
            args = [context, args.slice ? args.slice() : args];
            queue.push(args);

            if (!firing) {
              fire();
            }
          }

          return this;
        },
        // Call all the callbacks with the given arguments
        fire: function () {
          self.fireWith(this, arguments);
          return this;
        },
        // To know if the callbacks have already been called at least once
        fired: function () {
          return !!fired;
        }
      };

      return self;
    };

    function Identity(v) {
      return v;
    }

    function Thrower(ex) {
      throw ex;
    }

    function adoptValue(value, resolve, reject) {
      var method;

      try {
        // Check for promise aspect first to privilege synchronous behavior
        if (value && jQuery.isFunction(method = value.promise)) {
          method.call(value).done(resolve).fail(reject); // Other thenables
        } else if (value && jQuery.isFunction(method = value.then)) {
          method.call(value, resolve, reject); // Other non-thenables
        } else {
          // Support: Android 4.0 only
          // Strict mode functions invoked without .call/.apply get global-object context
          resolve.call(undefined, value);
        } // For Promises/A+, convert exceptions into rejections
        // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
        // Deferred#then to conditionally suppress rejection.

      } catch (value) {
        // Support: Android 4.0 only
        // Strict mode functions invoked without .call/.apply get global-object context
        reject.call(undefined, value);
      }
    }

    jQuery.extend({
      Deferred: function (func) {
        var tuples = [// action, add listener, callbacks,
        // ... .then handlers, argument index, [final state]
        ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
            state = "pending",
            promise = {
          state: function () {
            return state;
          },
          always: function () {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          "catch": function (fn) {
            return promise.then(null, fn);
          },
          // Keep pipe for back-compat
          pipe: function ()
          /* fnDone, fnFail, fnProgress */
          {
            var fns = arguments;
            return jQuery.Deferred(function (newDefer) {
              jQuery.each(tuples, function (i, tuple) {
                // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                var fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })
                // deferred.done(function() { bind to newDefer or newDefer.resolve })
                // deferred.fail(function() { bind to newDefer or newDefer.reject })

                deferred[tuple[1]](function () {
                  var returned = fn && fn.apply(this, arguments);

                  if (returned && jQuery.isFunction(returned.promise)) {
                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                  } else {
                    newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                  }
                });
              });
              fns = null;
            }).promise();
          },
          then: function (onFulfilled, onRejected, onProgress) {
            var maxDepth = 0;

            function resolve(depth, deferred, handler, special) {
              return function () {
                var that = this,
                    args = arguments,
                    mightThrow = function () {
                  var returned, then; // Support: Promises/A+ section 2.3.3.3.3
                  // https://promisesaplus.com/#point-59
                  // Ignore double-resolution attempts

                  if (depth < maxDepth) {
                    return;
                  }

                  returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1
                  // https://promisesaplus.com/#point-48

                  if (returned === deferred.promise()) {
                    throw new TypeError("Thenable self-resolution");
                  } // Support: Promises/A+ sections 2.3.3.1, 3.5
                  // https://promisesaplus.com/#point-54
                  // https://promisesaplus.com/#point-75
                  // Retrieve `then` only once


                  then = returned && ( // Support: Promises/A+ section 2.3.4
                  // https://promisesaplus.com/#point-64
                  // Only check objects and functions for thenability
                  typeof returned === "object" || typeof returned === "function") && returned.then; // Handle a returned thenable

                  if (jQuery.isFunction(then)) {
                    // Special processors (notify) just wait for resolution
                    if (special) {
                      then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress
                    } else {
                      // ...and disregard older resolution values
                      maxDepth++;
                      then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                    } // Handle all other returned values

                  } else {
                    // Only substitute handlers pass on context
                    // and multiple values (non-spec behavior)
                    if (handler !== Identity) {
                      that = undefined;
                      args = [returned];
                    } // Process the value(s)
                    // Default process is resolve


                    (special || deferred.resolveWith)(that, args);
                  }
                },
                    // Only normal processors (resolve) catch and reject exceptions
                process = special ? mightThrow : function () {
                  try {
                    mightThrow();
                  } catch (e) {
                    if (jQuery.Deferred.exceptionHook) {
                      jQuery.Deferred.exceptionHook(e, process.stackTrace);
                    } // Support: Promises/A+ section 2.3.3.3.4.1
                    // https://promisesaplus.com/#point-61
                    // Ignore post-resolution exceptions


                    if (depth + 1 >= maxDepth) {
                      // Only substitute handlers pass on context
                      // and multiple values (non-spec behavior)
                      if (handler !== Thrower) {
                        that = undefined;
                        args = [e];
                      }

                      deferred.rejectWith(that, args);
                    }
                  }
                }; // Support: Promises/A+ section 2.3.3.3.1
                // https://promisesaplus.com/#point-57
                // Re-resolve promises immediately to dodge false rejection from
                // subsequent errors


                if (depth) {
                  process();
                } else {
                  // Call an optional hook to record the stack, in case of exception
                  // since it's otherwise lost when execution goes async
                  if (jQuery.Deferred.getStackHook) {
                    process.stackTrace = jQuery.Deferred.getStackHook();
                  }

                  window.setTimeout(process);
                }
              };
            }

            return jQuery.Deferred(function (newDefer) {
              // progress_handlers.add( ... )
              tuples[0][3].add(resolve(0, newDefer, jQuery.isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )

              tuples[1][3].add(resolve(0, newDefer, jQuery.isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )

              tuples[2][3].add(resolve(0, newDefer, jQuery.isFunction(onRejected) ? onRejected : Thrower));
            }).promise();
          },
          // Get a promise for this deferred
          // If obj is provided, the promise aspect is added to the object
          promise: function (obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          }
        },
            deferred = {}; // Add list-specific methods

        jQuery.each(tuples, function (i, tuple) {
          var list = tuple[2],
              stateString = tuple[5]; // promise.progress = list.add
          // promise.done = list.add
          // promise.fail = list.add

          promise[tuple[1]] = list.add; // Handle state

          if (stateString) {
            list.add(function () {
              // state = "resolved" (i.e., fulfilled)
              // state = "rejected"
              state = stateString;
            }, // rejected_callbacks.disable
            // fulfilled_callbacks.disable
            tuples[3 - i][2].disable, // progress_callbacks.lock
            tuples[0][2].lock);
          } // progress_handlers.fire
          // fulfilled_handlers.fire
          // rejected_handlers.fire


          list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }
          // deferred.resolve = function() { deferred.resolveWith(...) }
          // deferred.reject = function() { deferred.rejectWith(...) }

          deferred[tuple[0]] = function () {
            deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
            return this;
          }; // deferred.notifyWith = list.fireWith
          // deferred.resolveWith = list.fireWith
          // deferred.rejectWith = list.fireWith


          deferred[tuple[0] + "With"] = list.fireWith;
        }); // Make the deferred a promise

        promise.promise(deferred); // Call given func if any

        if (func) {
          func.call(deferred, deferred);
        } // All done!


        return deferred;
      },
      // Deferred helper
      when: function (singleValue) {
        var // count of uncompleted subordinates
        remaining = arguments.length,
            // count of unprocessed arguments
        i = remaining,
            // subordinate fulfillment data
        resolveContexts = Array(i),
            resolveValues = slice.call(arguments),
            // the master Deferred
        master = jQuery.Deferred(),
            // subordinate callback factory
        updateFunc = function (i) {
          return function (value) {
            resolveContexts[i] = this;
            resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;

            if (! --remaining) {
              master.resolveWith(resolveContexts, resolveValues);
            }
          };
        }; // Single- and empty arguments are adopted like Promise.resolve


        if (remaining <= 1) {
          adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject); // Use .then() to unwrap secondary thenables (cf. gh-3000)

          if (master.state() === "pending" || jQuery.isFunction(resolveValues[i] && resolveValues[i].then)) {
            return master.then();
          }
        } // Multiple arguments are aggregated like Promise.all array elements


        while (i--) {
          adoptValue(resolveValues[i], updateFunc(i), master.reject);
        }

        return master.promise();
      }
    }); // These usually indicate a programmer mistake during development,
    // warn about them ASAP rather than swallowing them by default.

    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

    jQuery.Deferred.exceptionHook = function (error, stack) {
      // Support: IE 8 - 9 only
      // Console exists when dev tools are open, which can happen at any time
      if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
        window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
      }
    };

    jQuery.readyException = function (error) {
      window.setTimeout(function () {
        throw error;
      });
    }; // The deferred used on DOM ready


    var readyList = jQuery.Deferred();

    jQuery.fn.ready = function (fn) {
      readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup
      // happens at the time of error handling instead of callback
      // registration.
      .catch(function (error) {
        jQuery.readyException(error);
      });
      return this;
    };

    jQuery.extend({
      // Is the DOM ready to be used? Set to true once it occurs.
      isReady: false,
      // A counter to track how many items to wait for before
      // the ready event fires. See #6781
      readyWait: 1,
      // Hold (or release) the ready event
      holdReady: function (hold) {
        if (hold) {
          jQuery.readyWait++;
        } else {
          jQuery.ready(true);
        }
      },
      // Handle when the DOM is ready
      ready: function (wait) {
        // Abort if there are pending holds or we're already ready
        if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
          return;
        } // Remember that the DOM is ready


        jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be

        if (wait !== true && --jQuery.readyWait > 0) {
          return;
        } // If there are functions bound, to execute


        readyList.resolveWith(document, [jQuery]);
      }
    });
    jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method

    function completed() {
      document.removeEventListener("DOMContentLoaded", completed);
      window.removeEventListener("load", completed);
      jQuery.ready();
    } // Catch cases where $(document).ready() is called
    // after the browser event has already occurred.
    // Support: IE <=9 - 10 only
    // Older IE sometimes signals "interactive" too soon


    if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
      // Handle it asynchronously to allow scripts the opportunity to delay ready
      window.setTimeout(jQuery.ready);
    } else {
      // Use the handy event callback
      document.addEventListener("DOMContentLoaded", completed); // A fallback to window.onload, that will always work

      window.addEventListener("load", completed);
    } // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function


    var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
      var i = 0,
          len = elems.length,
          bulk = key == null; // Sets many values

      if (jQuery.type(key) === "object") {
        chainable = true;

        for (i in key) {
          access(elems, fn, i, key[i], true, emptyGet, raw);
        } // Sets one value

      } else if (value !== undefined) {
        chainable = true;

        if (!jQuery.isFunction(value)) {
          raw = true;
        }

        if (bulk) {
          // Bulk operations run against the entire set
          if (raw) {
            fn.call(elems, value);
            fn = null; // ...except when executing function values
          } else {
            bulk = fn;

            fn = function (elem, key, value) {
              return bulk.call(jQuery(elem), value);
            };
          }
        }

        if (fn) {
          for (; i < len; i++) {
            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
          }
        }
      }

      if (chainable) {
        return elems;
      } // Gets


      if (bulk) {
        return fn.call(elems);
      }

      return len ? fn(elems[0], key) : emptyGet;
    };

    var acceptData = function (owner) {
      // Accepts only:
      //  - Node
      //    - Node.ELEMENT_NODE
      //    - Node.DOCUMENT_NODE
      //  - Object
      //    - Any
      return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };

    function Data() {
      this.expando = jQuery.expando + Data.uid++;
    }

    Data.uid = 1;
    Data.prototype = {
      cache: function (owner) {
        // Check if the owner object already has a cache
        var value = owner[this.expando]; // If not, create one

        if (!value) {
          value = {}; // We can accept data for non-element nodes in modern browsers,
          // but we should not, see #8335.
          // Always return an empty object.

          if (acceptData(owner)) {
            // If it is a node unlikely to be stringify-ed or looped over
            // use plain assignment
            if (owner.nodeType) {
              owner[this.expando] = value; // Otherwise secure it in a non-enumerable property
              // configurable must be true to allow the property to be
              // deleted when data is removed
            } else {
              Object.defineProperty(owner, this.expando, {
                value: value,
                configurable: true
              });
            }
          }
        }

        return value;
      },
      set: function (owner, data, value) {
        var prop,
            cache = this.cache(owner); // Handle: [ owner, key, value ] args
        // Always use camelCase key (gh-2257)

        if (typeof data === "string") {
          cache[jQuery.camelCase(data)] = value; // Handle: [ owner, { properties } ] args
        } else {
          // Copy the properties one-by-one to the cache object
          for (prop in data) {
            cache[jQuery.camelCase(prop)] = data[prop];
          }
        }

        return cache;
      },
      get: function (owner, key) {
        return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
        owner[this.expando] && owner[this.expando][jQuery.camelCase(key)];
      },
      access: function (owner, key, value) {
        // In cases where either:
        //
        //   1. No key was specified
        //   2. A string key was specified, but no value provided
        //
        // Take the "read" path and allow the get method to determine
        // which value to return, respectively either:
        //
        //   1. The entire cache object
        //   2. The data stored at the key
        //
        if (key === undefined || key && typeof key === "string" && value === undefined) {
          return this.get(owner, key);
        } // When the key is not a string, or both a key and value
        // are specified, set or extend (existing objects) with either:
        //
        //   1. An object of properties
        //   2. A key and value
        //


        this.set(owner, key, value); // Since the "set" path can have two possible entry points
        // return the expected data based on which path was taken[*]

        return value !== undefined ? value : key;
      },
      remove: function (owner, key) {
        var i,
            cache = owner[this.expando];

        if (cache === undefined) {
          return;
        }

        if (key !== undefined) {
          // Support array or space separated string of keys
          if (jQuery.isArray(key)) {
            // If key is an array of keys...
            // We always set camelCase keys, so remove that.
            key = key.map(jQuery.camelCase);
          } else {
            key = jQuery.camelCase(key); // If a key with the spaces exists, use it.
            // Otherwise, create an array by matching non-whitespace

            key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
          }

          i = key.length;

          while (i--) {
            delete cache[key[i]];
          }
        } // Remove the expando if there's no more data


        if (key === undefined || jQuery.isEmptyObject(cache)) {
          // Support: Chrome <=35 - 45
          // Webkit & Blink performance suffers when deleting properties
          // from DOM nodes, so set to undefined instead
          // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
          if (owner.nodeType) {
            owner[this.expando] = undefined;
          } else {
            delete owner[this.expando];
          }
        }
      },
      hasData: function (owner) {
        var cache = owner[this.expando];
        return cache !== undefined && !jQuery.isEmptyObject(cache);
      }
    };
    var dataPriv = new Data();
    var dataUser = new Data(); //	Implementation Summary
    //
    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
    //	2. Improve the module's maintainability by reducing the storage
    //		paths to a single mechanism.
    //	3. Use the same single mechanism to support "private" and "user" data.
    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        rmultiDash = /[A-Z]/g;

    function getData(data) {
      if (data === "true") {
        return true;
      }

      if (data === "false") {
        return false;
      }

      if (data === "null") {
        return null;
      } // Only convert to a number if it doesn't change the string


      if (data === +data + "") {
        return +data;
      }

      if (rbrace.test(data)) {
        return JSON.parse(data);
      }

      return data;
    }

    function dataAttr(elem, key, data) {
      var name; // If nothing was found internally, try to fetch any
      // data from the HTML5 data-* attribute

      if (data === undefined && elem.nodeType === 1) {
        name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
        data = elem.getAttribute(name);

        if (typeof data === "string") {
          try {
            data = getData(data);
          } catch (e) {} // Make sure we set the data so it isn't changed later


          dataUser.set(elem, key, data);
        } else {
          data = undefined;
        }
      }

      return data;
    }

    jQuery.extend({
      hasData: function (elem) {
        return dataUser.hasData(elem) || dataPriv.hasData(elem);
      },
      data: function (elem, name, data) {
        return dataUser.access(elem, name, data);
      },
      removeData: function (elem, name) {
        dataUser.remove(elem, name);
      },
      // TODO: Now that all calls to _data and _removeData have been replaced
      // with direct calls to dataPriv methods, these can be deprecated.
      _data: function (elem, name, data) {
        return dataPriv.access(elem, name, data);
      },
      _removeData: function (elem, name) {
        dataPriv.remove(elem, name);
      }
    });
    jQuery.fn.extend({
      data: function (key, value) {
        var i,
            name,
            data,
            elem = this[0],
            attrs = elem && elem.attributes; // Gets all values

        if (key === undefined) {
          if (this.length) {
            data = dataUser.get(elem);

            if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
              i = attrs.length;

              while (i--) {
                // Support: IE 11 only
                // The attrs elements can be null (#14894)
                if (attrs[i]) {
                  name = attrs[i].name;

                  if (name.indexOf("data-") === 0) {
                    name = jQuery.camelCase(name.slice(5));
                    dataAttr(elem, name, data[name]);
                  }
                }
              }

              dataPriv.set(elem, "hasDataAttrs", true);
            }
          }

          return data;
        } // Sets multiple values


        if (typeof key === "object") {
          return this.each(function () {
            dataUser.set(this, key);
          });
        }

        return access(this, function (value) {
          var data; // The calling jQuery object (element matches) is not empty
          // (and therefore has an element appears at this[ 0 ]) and the
          // `value` parameter was not undefined. An empty jQuery object
          // will result in `undefined` for elem = this[ 0 ] which will
          // throw an exception if an attempt to read a data cache is made.

          if (elem && value === undefined) {
            // Attempt to get data from the cache
            // The key will always be camelCased in Data
            data = dataUser.get(elem, key);

            if (data !== undefined) {
              return data;
            } // Attempt to "discover" the data in
            // HTML5 custom data-* attrs


            data = dataAttr(elem, key);

            if (data !== undefined) {
              return data;
            } // We tried really hard, but the data doesn't exist.


            return;
          } // Set the data...


          this.each(function () {
            // We always store the camelCased key
            dataUser.set(this, key, value);
          });
        }, null, value, arguments.length > 1, null, true);
      },
      removeData: function (key) {
        return this.each(function () {
          dataUser.remove(this, key);
        });
      }
    });
    jQuery.extend({
      queue: function (elem, type, data) {
        var queue;

        if (elem) {
          type = (type || "fx") + "queue";
          queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup

          if (data) {
            if (!queue || jQuery.isArray(data)) {
              queue = dataPriv.access(elem, type, jQuery.makeArray(data));
            } else {
              queue.push(data);
            }
          }

          return queue || [];
        }
      },
      dequeue: function (elem, type) {
        type = type || "fx";

        var queue = jQuery.queue(elem, type),
            startLength = queue.length,
            fn = queue.shift(),
            hooks = jQuery._queueHooks(elem, type),
            next = function () {
          jQuery.dequeue(elem, type);
        }; // If the fx queue is dequeued, always remove the progress sentinel


        if (fn === "inprogress") {
          fn = queue.shift();
          startLength--;
        }

        if (fn) {
          // Add a progress sentinel to prevent the fx queue from being
          // automatically dequeued
          if (type === "fx") {
            queue.unshift("inprogress");
          } // Clear up the last queue stop function


          delete hooks.stop;
          fn.call(elem, next, hooks);
        }

        if (!startLength && hooks) {
          hooks.empty.fire();
        }
      },
      // Not public - generate a queueHooks object, or return the current one
      _queueHooks: function (elem, type) {
        var key = type + "queueHooks";
        return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
          empty: jQuery.Callbacks("once memory").add(function () {
            dataPriv.remove(elem, [type + "queue", key]);
          })
        });
      }
    });
    jQuery.fn.extend({
      queue: function (type, data) {
        var setter = 2;

        if (typeof type !== "string") {
          data = type;
          type = "fx";
          setter--;
        }

        if (arguments.length < setter) {
          return jQuery.queue(this[0], type);
        }

        return data === undefined ? this : this.each(function () {
          var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue

          jQuery._queueHooks(this, type);

          if (type === "fx" && queue[0] !== "inprogress") {
            jQuery.dequeue(this, type);
          }
        });
      },
      dequeue: function (type) {
        return this.each(function () {
          jQuery.dequeue(this, type);
        });
      },
      clearQueue: function (type) {
        return this.queue(type || "fx", []);
      },
      // Get a promise resolved when queues of a certain type
      // are emptied (fx is the type by default)
      promise: function (type, obj) {
        var tmp,
            count = 1,
            defer = jQuery.Deferred(),
            elements = this,
            i = this.length,
            resolve = function () {
          if (! --count) {
            defer.resolveWith(elements, [elements]);
          }
        };

        if (typeof type !== "string") {
          obj = type;
          type = undefined;
        }

        type = type || "fx";

        while (i--) {
          tmp = dataPriv.get(elements[i], type + "queueHooks");

          if (tmp && tmp.empty) {
            count++;
            tmp.empty.add(resolve);
          }
        }

        resolve();
        return defer.promise(obj);
      }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
    var cssExpand = ["Top", "Right", "Bottom", "Left"];

    var isHiddenWithinTree = function (elem, el) {
      // isHiddenWithinTree might be called from jQuery#filter function;
      // in that case, element will be second argument
      elem = el || elem; // Inline style trumps all

      return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
      // Support: Firefox <=43 - 45
      // Disconnected elements can have computed display: none, so first confirm that elem is
      // in the document.
      jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, "display") === "none";
    };

    var swap = function (elem, options, callback, args) {
      var ret,
          name,
          old = {}; // Remember the old values, and insert the new ones

      for (name in options) {
        old[name] = elem.style[name];
        elem.style[name] = options[name];
      }

      ret = callback.apply(elem, args || []); // Revert the old values

      for (name in options) {
        elem.style[name] = old[name];
      }

      return ret;
    };

    function adjustCSS(elem, prop, valueParts, tween) {
      var adjusted,
          scale = 1,
          maxIterations = 20,
          currentValue = tween ? function () {
        return tween.cur();
      } : function () {
        return jQuery.css(elem, prop, "");
      },
          initial = currentValue(),
          unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
          // Starting value computation is required for potential unit mismatches
      initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

      if (initialInUnit && initialInUnit[3] !== unit) {
        // Trust units reported by jQuery.css
        unit = unit || initialInUnit[3]; // Make sure we update the tween properties later on

        valueParts = valueParts || []; // Iteratively approximate from a nonzero starting point

        initialInUnit = +initial || 1;

        do {
          // If previous iteration zeroed out, double until we get *something*.
          // Use string for doubling so we don't accidentally see scale as unchanged below
          scale = scale || ".5"; // Adjust and apply

          initialInUnit = initialInUnit / scale;
          jQuery.style(elem, prop, initialInUnit + unit); // Update scale, tolerating zero or NaN from tween.cur()
          // Break the loop if scale is unchanged or perfect, or if we've just had enough.
        } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
      }

      if (valueParts) {
        initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified

        adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];

        if (tween) {
          tween.unit = unit;
          tween.start = initialInUnit;
          tween.end = adjusted;
        }
      }

      return adjusted;
    }

    var defaultDisplayMap = {};

    function getDefaultDisplay(elem) {
      var temp,
          doc = elem.ownerDocument,
          nodeName = elem.nodeName,
          display = defaultDisplayMap[nodeName];

      if (display) {
        return display;
      }

      temp = doc.body.appendChild(doc.createElement(nodeName));
      display = jQuery.css(temp, "display");
      temp.parentNode.removeChild(temp);

      if (display === "none") {
        display = "block";
      }

      defaultDisplayMap[nodeName] = display;
      return display;
    }

    function showHide(elements, show) {
      var display,
          elem,
          values = [],
          index = 0,
          length = elements.length; // Determine new display value for elements that need to change

      for (; index < length; index++) {
        elem = elements[index];

        if (!elem.style) {
          continue;
        }

        display = elem.style.display;

        if (show) {
          // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
          // check is required in this first loop unless we have a nonempty display value (either
          // inline or about-to-be-restored)
          if (display === "none") {
            values[index] = dataPriv.get(elem, "display") || null;

            if (!values[index]) {
              elem.style.display = "";
            }
          }

          if (elem.style.display === "" && isHiddenWithinTree(elem)) {
            values[index] = getDefaultDisplay(elem);
          }
        } else {
          if (display !== "none") {
            values[index] = "none"; // Remember what we're overwriting

            dataPriv.set(elem, "display", display);
          }
        }
      } // Set the display of the elements in a second loop to avoid constant reflow


      for (index = 0; index < length; index++) {
        if (values[index] != null) {
          elements[index].style.display = values[index];
        }
      }

      return elements;
    }

    jQuery.fn.extend({
      show: function () {
        return showHide(this, true);
      },
      hide: function () {
        return showHide(this);
      },
      toggle: function (state) {
        if (typeof state === "boolean") {
          return state ? this.show() : this.hide();
        }

        return this.each(function () {
          if (isHiddenWithinTree(this)) {
            jQuery(this).show();
          } else {
            jQuery(this).hide();
          }
        });
      }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;
    var rscriptType = /^$|\/(?:java|ecma)script/i; // We have to close these tags to support XHTML (#13200)

    var wrapMap = {
      // Support: IE <=9 only
      option: [1, "<select multiple='multiple'>", "</select>"],
      // XHTML parsers do not magically insert elements in the
      // same way that tag soup parsers do. So we cannot shorten
      // this by omitting <tbody> or other required elements.
      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      _default: [0, "", ""]
    }; // Support: IE <=9 only

    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    function getAll(context, tag) {
      // Support: IE <=9 - 11 only
      // Use typeof to avoid zero-argument method invocation on host objects (#15151)
      var ret;

      if (typeof context.getElementsByTagName !== "undefined") {
        ret = context.getElementsByTagName(tag || "*");
      } else if (typeof context.querySelectorAll !== "undefined") {
        ret = context.querySelectorAll(tag || "*");
      } else {
        ret = [];
      }

      if (tag === undefined || tag && jQuery.nodeName(context, tag)) {
        return jQuery.merge([context], ret);
      }

      return ret;
    } // Mark scripts as having already been evaluated


    function setGlobalEval(elems, refElements) {
      var i = 0,
          l = elems.length;

      for (; i < l; i++) {
        dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
      }
    }

    var rhtml = /<|&#?\w+;/;

    function buildFragment(elems, context, scripts, selection, ignored) {
      var elem,
          tmp,
          tag,
          wrap,
          contains,
          j,
          fragment = context.createDocumentFragment(),
          nodes = [],
          i = 0,
          l = elems.length;

      for (; i < l; i++) {
        elem = elems[i];

        if (elem || elem === 0) {
          // Add nodes directly
          if (jQuery.type(elem) === "object") {
            // Support: Android <=4.0 only, PhantomJS 1 only
            // push.apply(_, arraylike) throws on ancient WebKit
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes
          } else {
            tmp = tmp || fragment.appendChild(context.createElement("div")); // Deserialize a standard representation

            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content

            j = wrap[0];

            while (j--) {
              tmp = tmp.lastChild;
            } // Support: Android <=4.0 only, PhantomJS 1 only
            // push.apply(_, arraylike) throws on ancient WebKit


            jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container

            tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)

            tmp.textContent = "";
          }
        }
      } // Remove wrapper from fragment


      fragment.textContent = "";
      i = 0;

      while (elem = nodes[i++]) {
        // Skip elements already in the context collection (trac-4087)
        if (selection && jQuery.inArray(elem, selection) > -1) {
          if (ignored) {
            ignored.push(elem);
          }

          continue;
        }

        contains = jQuery.contains(elem.ownerDocument, elem); // Append to fragment

        tmp = getAll(fragment.appendChild(elem), "script"); // Preserve script evaluation history

        if (contains) {
          setGlobalEval(tmp);
        } // Capture executables


        if (scripts) {
          j = 0;

          while (elem = tmp[j++]) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }

      return fragment;
    }

    (function () {
      var fragment = document.createDocumentFragment(),
          div = fragment.appendChild(document.createElement("div")),
          input = document.createElement("input"); // Support: Android 4.0 - 4.3 only
      // Check state lost if the name is set (#11217)
      // Support: Windows Web Apps (WWA)
      // `name` and `type` must use .setAttribute for WWA (#14901)

      input.setAttribute("type", "radio");
      input.setAttribute("checked", "checked");
      input.setAttribute("name", "t");
      div.appendChild(input); // Support: Android <=4.1 only
      // Older WebKit doesn't clone checked state correctly in fragments

      support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only
      // Make sure textarea (and checkbox) defaultValue is properly cloned

      div.innerHTML = "<textarea>x</textarea>";
      support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    })();

    var documentElement = document.documentElement;
    var rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

    function returnTrue() {
      return true;
    }

    function returnFalse() {
      return false;
    } // Support: IE <=9 only
    // See #13393 for more info


    function safeActiveElement() {
      try {
        return document.activeElement;
      } catch (err) {}
    }

    function on(elem, types, selector, data, fn, one) {
      var origFn, type; // Types can be a map of types/handlers

      if (typeof types === "object") {
        // ( types-Object, selector, data )
        if (typeof selector !== "string") {
          // ( types-Object, data )
          data = data || selector;
          selector = undefined;
        }

        for (type in types) {
          on(elem, type, selector, data, types[type], one);
        }

        return elem;
      }

      if (data == null && fn == null) {
        // ( types, fn )
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === "string") {
          // ( types, selector, fn )
          fn = data;
          data = undefined;
        } else {
          // ( types, data, fn )
          fn = data;
          data = selector;
          selector = undefined;
        }
      }

      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return elem;
      }

      if (one === 1) {
        origFn = fn;

        fn = function (event) {
          // Can use an empty set, since event contains the info
          jQuery().off(event);
          return origFn.apply(this, arguments);
        }; // Use same guid so caller can remove using origFn


        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }

      return elem.each(function () {
        jQuery.event.add(this, types, fn, data, selector);
      });
    }
    /*
     * Helper functions for managing events -- not part of the public interface.
     * Props to Dean Edwards' addEvent library for many of the ideas.
     */


    jQuery.event = {
      global: {},
      add: function (elem, types, handler, data, selector) {
        var handleObjIn,
            eventHandle,
            tmp,
            events,
            t,
            handleObj,
            special,
            handlers,
            type,
            namespaces,
            origType,
            elemData = dataPriv.get(elem); // Don't attach events to noData or text/comment nodes (but allow plain objects)

        if (!elemData) {
          return;
        } // Caller can pass in an object of custom data in lieu of the handler


        if (handler.handler) {
          handleObjIn = handler;
          handler = handleObjIn.handler;
          selector = handleObjIn.selector;
        } // Ensure that invalid selectors throw exceptions at attach time
        // Evaluate against documentElement in case elem is a non-element node (e.g., document)


        if (selector) {
          jQuery.find.matchesSelector(documentElement, selector);
        } // Make sure that the handler has a unique ID, used to find/remove it later


        if (!handler.guid) {
          handler.guid = jQuery.guid++;
        } // Init the element's event structure and main handler, if this is the first


        if (!(events = elemData.events)) {
          events = elemData.events = {};
        }

        if (!(eventHandle = elemData.handle)) {
          eventHandle = elemData.handle = function (e) {
            // Discard the second event of a jQuery.event.trigger() and
            // when an event is called after a page has unloaded
            return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
          };
        } // Handle multiple events separated by a space


        types = (types || "").match(rnothtmlwhite) || [""];
        t = types.length;

        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort(); // There *must* be a type, no attaching namespace-only handlers

          if (!type) {
            continue;
          } // If event changes its type, use the special event handlers for the changed type


          special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type

          type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type

          special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers

          handleObj = jQuery.extend({
            type: type,
            origType: origType,
            data: data,
            handler: handler,
            guid: handler.guid,
            selector: selector,
            needsContext: selector && jQuery.expr.match.needsContext.test(selector),
            namespace: namespaces.join(".")
          }, handleObjIn); // Init the event handler queue if we're the first

          if (!(handlers = events[type])) {
            handlers = events[type] = [];
            handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false

            if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
              if (elem.addEventListener) {
                elem.addEventListener(type, eventHandle);
              }
            }
          }

          if (special.add) {
            special.add.call(elem, handleObj);

            if (!handleObj.handler.guid) {
              handleObj.handler.guid = handler.guid;
            }
          } // Add to the element's handler list, delegates in front


          if (selector) {
            handlers.splice(handlers.delegateCount++, 0, handleObj);
          } else {
            handlers.push(handleObj);
          } // Keep track of which events have ever been used, for event optimization


          jQuery.event.global[type] = true;
        }
      },
      // Detach an event or set of events from an element
      remove: function (elem, types, handler, selector, mappedTypes) {
        var j,
            origCount,
            tmp,
            events,
            t,
            handleObj,
            special,
            handlers,
            type,
            namespaces,
            origType,
            elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

        if (!elemData || !(events = elemData.events)) {
          return;
        } // Once for each type.namespace in types; type may be omitted


        types = (types || "").match(rnothtmlwhite) || [""];
        t = types.length;

        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort(); // Unbind all events (on this namespace, if provided) for the element

          if (!type) {
            for (type in events) {
              jQuery.event.remove(elem, type + types[t], handler, selector, true);
            }

            continue;
          }

          special = jQuery.event.special[type] || {};
          type = (selector ? special.delegateType : special.bindType) || type;
          handlers = events[type] || [];
          tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"); // Remove matching events

          origCount = j = handlers.length;

          while (j--) {
            handleObj = handlers[j];

            if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
              handlers.splice(j, 1);

              if (handleObj.selector) {
                handlers.delegateCount--;
              }

              if (special.remove) {
                special.remove.call(elem, handleObj);
              }
            }
          } // Remove generic event handler if we removed something and no more handlers exist
          // (avoids potential for endless recursion during removal of special event handlers)


          if (origCount && !handlers.length) {
            if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
              jQuery.removeEvent(elem, type, elemData.handle);
            }

            delete events[type];
          }
        } // Remove data and the expando if it's no longer used


        if (jQuery.isEmptyObject(events)) {
          dataPriv.remove(elem, "handle events");
        }
      },
      dispatch: function (nativeEvent) {
        // Make a writable jQuery.Event from the native event object
        var event = jQuery.event.fix(nativeEvent);
        var i,
            j,
            ret,
            matched,
            handleObj,
            handlerQueue,
            args = new Array(arguments.length),
            handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
            special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event

        args[0] = event;

        for (i = 1; i < arguments.length; i++) {
          args[i] = arguments[i];
        }

        event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired

        if (special.preDispatch && special.preDispatch.call(this, event) === false) {
          return;
        } // Determine handlers


        handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us

        i = 0;

        while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
          event.currentTarget = matched.elem;
          j = 0;

          while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
            // Triggered event must either 1) have no namespace, or 2) have namespace(s)
            // a subset or equal to those in the bound event (both can have no namespace).
            if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
              event.handleObj = handleObj;
              event.data = handleObj.data;
              ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

              if (ret !== undefined) {
                if ((event.result = ret) === false) {
                  event.preventDefault();
                  event.stopPropagation();
                }
              }
            }
          }
        } // Call the postDispatch hook for the mapped type


        if (special.postDispatch) {
          special.postDispatch.call(this, event);
        }

        return event.result;
      },
      handlers: function (event, handlers) {
        var i,
            handleObj,
            sel,
            matchedHandlers,
            matchedSelectors,
            handlerQueue = [],
            delegateCount = handlers.delegateCount,
            cur = event.target; // Find delegate handlers

        if (delegateCount && // Support: IE <=9
        // Black-hole SVG <use> instance trees (trac-13180)
        cur.nodeType && // Support: Firefox <=42
        // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
        // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
        // Support: IE 11 only
        // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
        !(event.type === "click" && event.button >= 1)) {
          for (; cur !== this; cur = cur.parentNode || this) {
            // Don't check non-elements (#13208)
            // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
            if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
              matchedHandlers = [];
              matchedSelectors = {};

              for (i = 0; i < delegateCount; i++) {
                handleObj = handlers[i]; // Don't conflict with Object.prototype properties (#13203)

                sel = handleObj.selector + " ";

                if (matchedSelectors[sel] === undefined) {
                  matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                }

                if (matchedSelectors[sel]) {
                  matchedHandlers.push(handleObj);
                }
              }

              if (matchedHandlers.length) {
                handlerQueue.push({
                  elem: cur,
                  handlers: matchedHandlers
                });
              }
            }
          }
        } // Add the remaining (directly-bound) handlers


        cur = this;

        if (delegateCount < handlers.length) {
          handlerQueue.push({
            elem: cur,
            handlers: handlers.slice(delegateCount)
          });
        }

        return handlerQueue;
      },
      addProp: function (name, hook) {
        Object.defineProperty(jQuery.Event.prototype, name, {
          enumerable: true,
          configurable: true,
          get: jQuery.isFunction(hook) ? function () {
            if (this.originalEvent) {
              return hook(this.originalEvent);
            }
          } : function () {
            if (this.originalEvent) {
              return this.originalEvent[name];
            }
          },
          set: function (value) {
            Object.defineProperty(this, name, {
              enumerable: true,
              configurable: true,
              writable: true,
              value: value
            });
          }
        });
      },
      fix: function (originalEvent) {
        return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
      },
      special: {
        load: {
          // Prevent triggered image.load events from bubbling to window.load
          noBubble: true
        },
        focus: {
          // Fire native event if possible so blur/focus sequence is correct
          trigger: function () {
            if (this !== safeActiveElement() && this.focus) {
              this.focus();
              return false;
            }
          },
          delegateType: "focusin"
        },
        blur: {
          trigger: function () {
            if (this === safeActiveElement() && this.blur) {
              this.blur();
              return false;
            }
          },
          delegateType: "focusout"
        },
        click: {
          // For checkbox, fire native event so checked state will be right
          trigger: function () {
            if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
              this.click();
              return false;
            }
          },
          // For cross-browser consistency, don't fire native .click() on links
          _default: function (event) {
            return jQuery.nodeName(event.target, "a");
          }
        },
        beforeunload: {
          postDispatch: function (event) {
            // Support: Firefox 20+
            // Firefox doesn't alert if the returnValue field is not set.
            if (event.result !== undefined && event.originalEvent) {
              event.originalEvent.returnValue = event.result;
            }
          }
        }
      }
    };

    jQuery.removeEvent = function (elem, type, handle) {
      // This "if" is needed for plain objects
      if (elem.removeEventListener) {
        elem.removeEventListener(type, handle);
      }
    };

    jQuery.Event = function (src, props) {
      // Allow instantiation without the 'new' keyword
      if (!(this instanceof jQuery.Event)) {
        return new jQuery.Event(src, props);
      } // Event object


      if (src && src.type) {
        this.originalEvent = src;
        this.type = src.type; // Events bubbling up the document may have been marked as prevented
        // by a handler lower down the tree; reflect the correct value.

        this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
        src.returnValue === false ? returnTrue : returnFalse; // Create target properties
        // Support: Safari <=6 - 7 only
        // Target should not be a text node (#504, #13143)

        this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
        this.currentTarget = src.currentTarget;
        this.relatedTarget = src.relatedTarget; // Event type
      } else {
        this.type = src;
      } // Put explicitly provided properties onto the event object


      if (props) {
        jQuery.extend(this, props);
      } // Create a timestamp if incoming event doesn't have one


      this.timeStamp = src && src.timeStamp || jQuery.now(); // Mark it as fixed

      this[jQuery.expando] = true;
    }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


    jQuery.Event.prototype = {
      constructor: jQuery.Event,
      isDefaultPrevented: returnFalse,
      isPropagationStopped: returnFalse,
      isImmediatePropagationStopped: returnFalse,
      isSimulated: false,
      preventDefault: function () {
        var e = this.originalEvent;
        this.isDefaultPrevented = returnTrue;

        if (e && !this.isSimulated) {
          e.preventDefault();
        }
      },
      stopPropagation: function () {
        var e = this.originalEvent;
        this.isPropagationStopped = returnTrue;

        if (e && !this.isSimulated) {
          e.stopPropagation();
        }
      },
      stopImmediatePropagation: function () {
        var e = this.originalEvent;
        this.isImmediatePropagationStopped = returnTrue;

        if (e && !this.isSimulated) {
          e.stopImmediatePropagation();
        }

        this.stopPropagation();
      }
    }; // Includes all common event props including KeyEvent and MouseEvent specific props

    jQuery.each({
      altKey: true,
      bubbles: true,
      cancelable: true,
      changedTouches: true,
      ctrlKey: true,
      detail: true,
      eventPhase: true,
      metaKey: true,
      pageX: true,
      pageY: true,
      shiftKey: true,
      view: true,
      "char": true,
      charCode: true,
      key: true,
      keyCode: true,
      button: true,
      buttons: true,
      clientX: true,
      clientY: true,
      offsetX: true,
      offsetY: true,
      pointerId: true,
      pointerType: true,
      screenX: true,
      screenY: true,
      targetTouches: true,
      toElement: true,
      touches: true,
      which: function (event) {
        var button = event.button; // Add which for key events

        if (event.which == null && rkeyEvent.test(event.type)) {
          return event.charCode != null ? event.charCode : event.keyCode;
        } // Add which for click: 1 === left; 2 === middle; 3 === right


        if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
          if (button & 1) {
            return 1;
          }

          if (button & 2) {
            return 3;
          }

          if (button & 4) {
            return 2;
          }

          return 0;
        }

        return event.which;
      }
    }, jQuery.event.addProp); // Create mouseenter/leave events using mouseover/out and event-time checks
    // so that event delegation works in jQuery.
    // Do the same for pointerenter/pointerleave and pointerover/pointerout
    //
    // Support: Safari 7 only
    // Safari sends mouseenter too often; see:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
    // for the description of the bug (it existed in older Chrome versions as well).

    jQuery.each({
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      pointerenter: "pointerover",
      pointerleave: "pointerout"
    }, function (orig, fix) {
      jQuery.event.special[orig] = {
        delegateType: fix,
        bindType: fix,
        handle: function (event) {
          var ret,
              target = this,
              related = event.relatedTarget,
              handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.
          // NB: No relatedTarget if the mouse left/entered the browser window

          if (!related || related !== target && !jQuery.contains(target, related)) {
            event.type = handleObj.origType;
            ret = handleObj.handler.apply(this, arguments);
            event.type = fix;
          }

          return ret;
        }
      };
    });
    jQuery.fn.extend({
      on: function (types, selector, data, fn) {
        return on(this, types, selector, data, fn);
      },
      one: function (types, selector, data, fn) {
        return on(this, types, selector, data, fn, 1);
      },
      off: function (types, selector, fn) {
        var handleObj, type;

        if (types && types.preventDefault && types.handleObj) {
          // ( event )  dispatched jQuery.Event
          handleObj = types.handleObj;
          jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
          return this;
        }

        if (typeof types === "object") {
          // ( types-object [, selector] )
          for (type in types) {
            this.off(type, selector, types[type]);
          }

          return this;
        }

        if (selector === false || typeof selector === "function") {
          // ( types [, fn] )
          fn = selector;
          selector = undefined;
        }

        if (fn === false) {
          fn = returnFalse;
        }

        return this.each(function () {
          jQuery.event.remove(this, types, fn, selector);
        });
      }
    });
    var
    /* eslint-disable max-len */
    // See https://github.com/eslint/eslint/issues/3229
    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

    /* eslint-enable */
    // Support: IE <=10 - 11, Edge 12 - 13
    // In IE/Edge using regex groups here causes severe slowdowns.
    // See https://connect.microsoft.com/IE/feedback/details/1736512/
    rnoInnerhtml = /<script|<style|<link/i,
        // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rscriptTypeMasked = /^true\/(.*)/,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

    function manipulationTarget(elem, content) {
      if (jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
        return elem.getElementsByTagName("tbody")[0] || elem;
      }

      return elem;
    } // Replace/restore the type attribute of script elements for safe DOM manipulation


    function disableScript(elem) {
      elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
      return elem;
    }

    function restoreScript(elem) {
      var match = rscriptTypeMasked.exec(elem.type);

      if (match) {
        elem.type = match[1];
      } else {
        elem.removeAttribute("type");
      }

      return elem;
    }

    function cloneCopyEvent(src, dest) {
      var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

      if (dest.nodeType !== 1) {
        return;
      } // 1. Copy private data: events, handlers, etc.


      if (dataPriv.hasData(src)) {
        pdataOld = dataPriv.access(src);
        pdataCur = dataPriv.set(dest, pdataOld);
        events = pdataOld.events;

        if (events) {
          delete pdataCur.handle;
          pdataCur.events = {};

          for (type in events) {
            for (i = 0, l = events[type].length; i < l; i++) {
              jQuery.event.add(dest, type, events[type][i]);
            }
          }
        }
      } // 2. Copy user data


      if (dataUser.hasData(src)) {
        udataOld = dataUser.access(src);
        udataCur = jQuery.extend({}, udataOld);
        dataUser.set(dest, udataCur);
      }
    } // Fix IE bugs, see support tests


    function fixInput(src, dest) {
      var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.

      if (nodeName === "input" && rcheckableType.test(src.type)) {
        dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options
      } else if (nodeName === "input" || nodeName === "textarea") {
        dest.defaultValue = src.defaultValue;
      }
    }

    function domManip(collection, args, callback, ignored) {
      // Flatten any nested arrays
      args = concat.apply([], args);
      var fragment,
          first,
          scripts,
          hasScripts,
          node,
          doc,
          i = 0,
          l = collection.length,
          iNoClone = l - 1,
          value = args[0],
          isFunction = jQuery.isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit

      if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
        return collection.each(function (index) {
          var self = collection.eq(index);

          if (isFunction) {
            args[0] = value.call(this, index, self.html());
          }

          domManip(self, args, callback, ignored);
        });
      }

      if (l) {
        fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
        first = fragment.firstChild;

        if (fragment.childNodes.length === 1) {
          fragment = first;
        } // Require either new content or an interest in ignored elements to invoke the callback


        if (first || ignored) {
          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length; // Use the original fragment for the last item
          // instead of the first because it can end up
          // being emptied incorrectly in certain situations (#8070).

          for (; i < l; i++) {
            node = fragment;

            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration

              if (hasScripts) {
                // Support: Android <=4.0 only, PhantomJS 1 only
                // push.apply(_, arraylike) throws on ancient WebKit
                jQuery.merge(scripts, getAll(node, "script"));
              }
            }

            callback.call(collection[i], node, i);
          }

          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts

            jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion

            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];

              if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                if (node.src) {
                  // Optional AJAX dependency, but won't run scripts if not present
                  if (jQuery._evalUrl) {
                    jQuery._evalUrl(node.src);
                  }
                } else {
                  DOMEval(node.textContent.replace(rcleanScript, ""), doc);
                }
              }
            }
          }
        }
      }

      return collection;
    }

    function remove(elem, selector, keepData) {
      var node,
          nodes = selector ? jQuery.filter(selector, elem) : elem,
          i = 0;

      for (; (node = nodes[i]) != null; i++) {
        if (!keepData && node.nodeType === 1) {
          jQuery.cleanData(getAll(node));
        }

        if (node.parentNode) {
          if (keepData && jQuery.contains(node.ownerDocument, node)) {
            setGlobalEval(getAll(node, "script"));
          }

          node.parentNode.removeChild(node);
        }
      }

      return elem;
    }

    jQuery.extend({
      htmlPrefilter: function (html) {
        return html.replace(rxhtmlTag, "<$1></$2>");
      },
      clone: function (elem, dataAndEvents, deepDataAndEvents) {
        var i,
            l,
            srcElements,
            destElements,
            clone = elem.cloneNode(true),
            inPage = jQuery.contains(elem.ownerDocument, elem); // Fix IE cloning issues

        if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
          // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
          destElements = getAll(clone);
          srcElements = getAll(elem);

          for (i = 0, l = srcElements.length; i < l; i++) {
            fixInput(srcElements[i], destElements[i]);
          }
        } // Copy the events from the original to the clone


        if (dataAndEvents) {
          if (deepDataAndEvents) {
            srcElements = srcElements || getAll(elem);
            destElements = destElements || getAll(clone);

            for (i = 0, l = srcElements.length; i < l; i++) {
              cloneCopyEvent(srcElements[i], destElements[i]);
            }
          } else {
            cloneCopyEvent(elem, clone);
          }
        } // Preserve script evaluation history


        destElements = getAll(clone, "script");

        if (destElements.length > 0) {
          setGlobalEval(destElements, !inPage && getAll(elem, "script"));
        } // Return the cloned set


        return clone;
      },
      cleanData: function (elems) {
        var data,
            elem,
            type,
            special = jQuery.event.special,
            i = 0;

        for (; (elem = elems[i]) !== undefined; i++) {
          if (acceptData(elem)) {
            if (data = elem[dataPriv.expando]) {
              if (data.events) {
                for (type in data.events) {
                  if (special[type]) {
                    jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead
                  } else {
                    jQuery.removeEvent(elem, type, data.handle);
                  }
                }
              } // Support: Chrome <=35 - 45+
              // Assign undefined instead of using delete, see Data#remove


              elem[dataPriv.expando] = undefined;
            }

            if (elem[dataUser.expando]) {
              // Support: Chrome <=35 - 45+
              // Assign undefined instead of using delete, see Data#remove
              elem[dataUser.expando] = undefined;
            }
          }
        }
      }
    });
    jQuery.fn.extend({
      detach: function (selector) {
        return remove(this, selector, true);
      },
      remove: function (selector) {
        return remove(this, selector);
      },
      text: function (value) {
        return access(this, function (value) {
          return value === undefined ? jQuery.text(this) : this.empty().each(function () {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              this.textContent = value;
            }
          });
        }, null, value, arguments.length);
      },
      append: function () {
        return domManip(this, arguments, function (elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.appendChild(elem);
          }
        });
      },
      prepend: function () {
        return domManip(this, arguments, function (elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.insertBefore(elem, target.firstChild);
          }
        });
      },
      before: function () {
        return domManip(this, arguments, function (elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this);
          }
        });
      },
      after: function () {
        return domManip(this, arguments, function (elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this.nextSibling);
          }
        });
      },
      empty: function () {
        var elem,
            i = 0;

        for (; (elem = this[i]) != null; i++) {
          if (elem.nodeType === 1) {
            // Prevent memory leaks
            jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes

            elem.textContent = "";
          }
        }

        return this;
      },
      clone: function (dataAndEvents, deepDataAndEvents) {
        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
        return this.map(function () {
          return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
        });
      },
      html: function (value) {
        return access(this, function (value) {
          var elem = this[0] || {},
              i = 0,
              l = this.length;

          if (value === undefined && elem.nodeType === 1) {
            return elem.innerHTML;
          } // See if we can take a shortcut and just use innerHTML


          if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
            value = jQuery.htmlPrefilter(value);

            try {
              for (; i < l; i++) {
                elem = this[i] || {}; // Remove element nodes and prevent memory leaks

                if (elem.nodeType === 1) {
                  jQuery.cleanData(getAll(elem, false));
                  elem.innerHTML = value;
                }
              }

              elem = 0; // If using innerHTML throws an exception, use the fallback method
            } catch (e) {}
          }

          if (elem) {
            this.empty().append(value);
          }
        }, null, value, arguments.length);
      },
      replaceWith: function () {
        var ignored = []; // Make the changes, replacing each non-ignored context element with the new content

        return domManip(this, arguments, function (elem) {
          var parent = this.parentNode;

          if (jQuery.inArray(this, ignored) < 0) {
            jQuery.cleanData(getAll(this));

            if (parent) {
              parent.replaceChild(elem, this);
            }
          } // Force callback invocation

        }, ignored);
      }
    });
    jQuery.each({
      appendTo: "append",
      prependTo: "prepend",
      insertBefore: "before",
      insertAfter: "after",
      replaceAll: "replaceWith"
    }, function (name, original) {
      jQuery.fn[name] = function (selector) {
        var elems,
            ret = [],
            insert = jQuery(selector),
            last = insert.length - 1,
            i = 0;

        for (; i <= last; i++) {
          elems = i === last ? this : this.clone(true);
          jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only
          // .get() because push.apply(_, arraylike) throws on ancient WebKit

          push.apply(ret, elems.get());
        }

        return this.pushStack(ret);
      };
    });
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

    var getStyles = function (elem) {
      // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
      // IE throws on elements created in popups
      // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
      var view = elem.ownerDocument.defaultView;

      if (!view || !view.opener) {
        view = window;
      }

      return view.getComputedStyle(elem);
    };

    (function () {
      // Executing both pixelPosition & boxSizingReliable tests require only one layout
      // so they're executed at the same time to save the second computation.
      function computeStyleTests() {
        // This is a singleton, we need to execute it only once
        if (!div) {
          return;
        }

        div.style.cssText = "box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
        div.innerHTML = "";
        documentElement.appendChild(container);
        var divStyle = window.getComputedStyle(div);
        pixelPositionVal = divStyle.top !== "1%"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44

        reliableMarginLeftVal = divStyle.marginLeft === "2px";
        boxSizingReliableVal = divStyle.width === "4px"; // Support: Android 4.0 - 4.3 only
        // Some styles come back with percentage values, even though they shouldn't

        div.style.marginRight = "50%";
        pixelMarginRightVal = divStyle.marginRight === "4px";
        documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and
        // it will also be a sign that checks already performed

        div = null;
      }

      var pixelPositionVal,
          boxSizingReliableVal,
          pixelMarginRightVal,
          reliableMarginLeftVal,
          container = document.createElement("div"),
          div = document.createElement("div"); // Finish early in limited (non-browser) environments

      if (!div.style) {
        return;
      } // Support: IE <=9 - 11 only
      // Style of cloned element affects source element cloned (#8908)


      div.style.backgroundClip = "content-box";
      div.cloneNode(true).style.backgroundClip = "";
      support.clearCloneStyle = div.style.backgroundClip === "content-box";
      container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
      container.appendChild(div);
      jQuery.extend(support, {
        pixelPosition: function () {
          computeStyleTests();
          return pixelPositionVal;
        },
        boxSizingReliable: function () {
          computeStyleTests();
          return boxSizingReliableVal;
        },
        pixelMarginRight: function () {
          computeStyleTests();
          return pixelMarginRightVal;
        },
        reliableMarginLeft: function () {
          computeStyleTests();
          return reliableMarginLeftVal;
        }
      });
    })();

    function curCSS(elem, name, computed) {
      var width,
          minWidth,
          maxWidth,
          ret,
          style = elem.style;
      computed = computed || getStyles(elem); // Support: IE <=9 only
      // getPropertyValue is only needed for .css('filter') (#12537)

      if (computed) {
        ret = computed.getPropertyValue(name) || computed[name];

        if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
          ret = jQuery.style(elem, name);
        } // A tribute to the "awesome hack by Dean Edwards"
        // Android Browser returns percentage for some values,
        // but width seems to be reliably pixels.
        // This is against the CSSOM draft spec:
        // https://drafts.csswg.org/cssom/#resolved-values


        if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {
          // Remember the original values
          width = style.width;
          minWidth = style.minWidth;
          maxWidth = style.maxWidth; // Put in the new values to get a computed value out

          style.minWidth = style.maxWidth = style.width = ret;
          ret = computed.width; // Revert the changed values

          style.width = width;
          style.minWidth = minWidth;
          style.maxWidth = maxWidth;
        }
      }

      return ret !== undefined ? // Support: IE <=9 - 11 only
      // IE returns zIndex value as an integer.
      ret + "" : ret;
    }

    function addGetHookIf(conditionFn, hookFn) {
      // Define the hook, we'll check on the first run if it's really needed.
      return {
        get: function () {
          if (conditionFn()) {
            // Hook not needed (or it's not possible to use it due
            // to missing dependency), remove it.
            delete this.get;
            return;
          } // Hook needed; redefine it so that the support test is not executed again.


          return (this.get = hookFn).apply(this, arguments);
        }
      };
    }

    var // Swappable if display is none or starts with table
    // except "table", "table-cell", or "table-caption"
    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        cssShow = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    },
        cssNormalTransform = {
      letterSpacing: "0",
      fontWeight: "400"
    },
        cssPrefixes = ["Webkit", "Moz", "ms"],
        emptyStyle = document.createElement("div").style; // Return a css property mapped to a potentially vendor prefixed property

    function vendorPropName(name) {
      // Shortcut for names that are not vendor prefixed
      if (name in emptyStyle) {
        return name;
      } // Check for vendor prefixed names


      var capName = name[0].toUpperCase() + name.slice(1),
          i = cssPrefixes.length;

      while (i--) {
        name = cssPrefixes[i] + capName;

        if (name in emptyStyle) {
          return name;
        }
      }
    }

    function setPositiveNumber(elem, value, subtract) {
      // Any relative (+/-) values have already been
      // normalized at this point
      var matches = rcssNum.exec(value);
      return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
      Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
    }

    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
      var i,
          val = 0; // If we already have the right measurement, avoid augmentation

      if (extra === (isBorderBox ? "border" : "content")) {
        i = 4; // Otherwise initialize for horizontal or vertical properties
      } else {
        i = name === "width" ? 1 : 0;
      }

      for (; i < 4; i += 2) {
        // Both box models exclude margin, so add it if we want it
        if (extra === "margin") {
          val += jQuery.css(elem, extra + cssExpand[i], true, styles);
        }

        if (isBorderBox) {
          // border-box includes padding, so remove it if we want content
          if (extra === "content") {
            val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
          } // At this point, extra isn't border nor margin, so remove border


          if (extra !== "margin") {
            val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          }
        } else {
          // At this point, extra isn't content, so add padding
          val += jQuery.css(elem, "padding" + cssExpand[i], true, styles); // At this point, extra isn't content nor padding, so add border

          if (extra !== "padding") {
            val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          }
        }
      }

      return val;
    }

    function getWidthOrHeight(elem, name, extra) {
      // Start with offset property, which is equivalent to the border-box value
      var val,
          valueIsBorderBox = true,
          styles = getStyles(elem),
          isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box"; // Support: IE <=11 only
      // Running getBoundingClientRect on a disconnected node
      // in IE throws an error.

      if (elem.getClientRects().length) {
        val = elem.getBoundingClientRect()[name];
      } // Some non-html elements return undefined for offsetWidth, so check for null/undefined
      // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
      // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668


      if (val <= 0 || val == null) {
        // Fall back to computed then uncomputed css if necessary
        val = curCSS(elem, name, styles);

        if (val < 0 || val == null) {
          val = elem.style[name];
        } // Computed unit is not pixels. Stop here and return.


        if (rnumnonpx.test(val)) {
          return val;
        } // Check for style in case a browser which returns unreliable values
        // for getComputedStyle silently falls back to the reliable elem.style


        valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]); // Normalize "", auto, and prepare for extra

        val = parseFloat(val) || 0;
      } // Use the active box-sizing model to add/subtract irrelevant styles


      return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
    }

    jQuery.extend({
      // Add in style property hooks for overriding the default
      // behavior of getting and setting a style property
      cssHooks: {
        opacity: {
          get: function (elem, computed) {
            if (computed) {
              // We should always get a number back from opacity
              var ret = curCSS(elem, "opacity");
              return ret === "" ? "1" : ret;
            }
          }
        }
      },
      // Don't automatically add "px" to these possibly-unitless properties
      cssNumber: {
        "animationIterationCount": true,
        "columnCount": true,
        "fillOpacity": true,
        "flexGrow": true,
        "flexShrink": true,
        "fontWeight": true,
        "lineHeight": true,
        "opacity": true,
        "order": true,
        "orphans": true,
        "widows": true,
        "zIndex": true,
        "zoom": true
      },
      // Add in properties whose names you wish to fix before
      // setting or getting the value
      cssProps: {
        "float": "cssFloat"
      },
      // Get and set the style property on a DOM Node
      style: function (elem, name, value, extra) {
        // Don't set styles on text and comment nodes
        if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
          return;
        } // Make sure that we're working with the right name


        var ret,
            type,
            hooks,
            origName = jQuery.camelCase(name),
            style = elem.style;
        name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName); // Gets hook for the prefixed version, then unprefixed version

        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value

        if (value !== undefined) {
          type = typeof value; // Convert "+=" or "-=" to relative numbers (#7345)

          if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
            value = adjustCSS(elem, name, ret); // Fixes bug #9237

            type = "number";
          } // Make sure that null and NaN values aren't set (#7116)


          if (value == null || value !== value) {
            return;
          } // If a number was passed in, add the unit (except for certain CSS properties)


          if (type === "number") {
            value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
          } // background-* props affect original clone's values


          if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
            style[name] = "inherit";
          } // If a hook was provided, use that value, otherwise just set the specified value


          if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
            style[name] = value;
          }
        } else {
          // If a hook was provided get the non-computed value from there
          if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
            return ret;
          } // Otherwise just get the value from the style object


          return style[name];
        }
      },
      css: function (elem, name, extra, styles) {
        var val,
            num,
            hooks,
            origName = jQuery.camelCase(name); // Make sure that we're working with the right name

        name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName); // Try prefixed name followed by the unprefixed name

        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there

        if (hooks && "get" in hooks) {
          val = hooks.get(elem, true, extra);
        } // Otherwise, if a way to get the computed value exists, use that


        if (val === undefined) {
          val = curCSS(elem, name, styles);
        } // Convert "normal" to computed value


        if (val === "normal" && name in cssNormalTransform) {
          val = cssNormalTransform[name];
        } // Make numeric if forced or a qualifier was provided and val looks numeric


        if (extra === "" || extra) {
          num = parseFloat(val);
          return extra === true || isFinite(num) ? num || 0 : val;
        }

        return val;
      }
    });
    jQuery.each(["height", "width"], function (i, name) {
      jQuery.cssHooks[name] = {
        get: function (elem, computed, extra) {
          if (computed) {
            // Certain elements can have dimension info if we invisibly show them
            // but it must have a current display style that would benefit
            return rdisplayswap.test(jQuery.css(elem, "display")) && ( // Support: Safari 8+
            // Table columns in Safari have non-zero offsetWidth & zero
            // getBoundingClientRect().width unless display is changed.
            // Support: IE <=11 only
            // Running getBoundingClientRect on a disconnected node
            // in IE throws an error.
            !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
              return getWidthOrHeight(elem, name, extra);
            }) : getWidthOrHeight(elem, name, extra);
          }
        },
        set: function (elem, value, extra) {
          var matches,
              styles = extra && getStyles(elem),
              subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles); // Convert to pixels if value adjustment is needed

          if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
            elem.style[name] = value;
            value = jQuery.css(elem, name);
          }

          return setPositiveNumber(elem, value, subtract);
        }
      };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
      if (computed) {
        return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
          marginLeft: 0
        }, function () {
          return elem.getBoundingClientRect().left;
        })) + "px";
      }
    }); // These hooks are used by animate to expand properties

    jQuery.each({
      margin: "",
      padding: "",
      border: "Width"
    }, function (prefix, suffix) {
      jQuery.cssHooks[prefix + suffix] = {
        expand: function (value) {
          var i = 0,
              expanded = {},
              // Assumes a single number if not a string
          parts = typeof value === "string" ? value.split(" ") : [value];

          for (; i < 4; i++) {
            expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
          }

          return expanded;
        }
      };

      if (!rmargin.test(prefix)) {
        jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
      }
    });
    jQuery.fn.extend({
      css: function (name, value) {
        return access(this, function (elem, name, value) {
          var styles,
              len,
              map = {},
              i = 0;

          if (jQuery.isArray(name)) {
            styles = getStyles(elem);
            len = name.length;

            for (; i < len; i++) {
              map[name[i]] = jQuery.css(elem, name[i], false, styles);
            }

            return map;
          }

          return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
        }, name, value, arguments.length > 1);
      }
    });

    function Tween(elem, options, prop, end, easing) {
      return new Tween.prototype.init(elem, options, prop, end, easing);
    }

    jQuery.Tween = Tween;
    Tween.prototype = {
      constructor: Tween,
      init: function (elem, options, prop, end, easing, unit) {
        this.elem = elem;
        this.prop = prop;
        this.easing = easing || jQuery.easing._default;
        this.options = options;
        this.start = this.now = this.cur();
        this.end = end;
        this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
      },
      cur: function () {
        var hooks = Tween.propHooks[this.prop];
        return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
      },
      run: function (percent) {
        var eased,
            hooks = Tween.propHooks[this.prop];

        if (this.options.duration) {
          this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
        } else {
          this.pos = eased = percent;
        }

        this.now = (this.end - this.start) * eased + this.start;

        if (this.options.step) {
          this.options.step.call(this.elem, this.now, this);
        }

        if (hooks && hooks.set) {
          hooks.set(this);
        } else {
          Tween.propHooks._default.set(this);
        }

        return this;
      }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
      _default: {
        get: function (tween) {
          var result; // Use a property on the element directly when it is not a DOM element,
          // or when there is no matching style property that exists.

          if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
            return tween.elem[tween.prop];
          } // Passing an empty string as a 3rd parameter to .css will automatically
          // attempt a parseFloat and fallback to a string if the parse fails.
          // Simple values such as "10px" are parsed to Float;
          // complex values such as "rotate(1rad)" are returned as-is.


          result = jQuery.css(tween.elem, tween.prop, ""); // Empty strings, null, undefined and "auto" are converted to 0.

          return !result || result === "auto" ? 0 : result;
        },
        set: function (tween) {
          // Use step hook for back compat.
          // Use cssHook if its there.
          // Use .style if available and use plain properties where available.
          if (jQuery.fx.step[tween.prop]) {
            jQuery.fx.step[tween.prop](tween);
          } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
            jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
          } else {
            tween.elem[tween.prop] = tween.now;
          }
        }
      }
    }; // Support: IE <=9 only
    // Panic based approach to setting things on disconnected nodes

    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
      set: function (tween) {
        if (tween.elem.nodeType && tween.elem.parentNode) {
          tween.elem[tween.prop] = tween.now;
        }
      }
    };
    jQuery.easing = {
      linear: function (p) {
        return p;
      },
      swing: function (p) {
        return 0.5 - Math.cos(p * Math.PI) / 2;
      },
      _default: "swing"
    };
    jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point

    jQuery.fx.step = {};
    var fxNow,
        timerId,
        rfxtypes = /^(?:toggle|show|hide)$/,
        rrun = /queueHooks$/;

    function raf() {
      if (timerId) {
        window.requestAnimationFrame(raf);
        jQuery.fx.tick();
      }
    } // Animations created synchronously will run synchronously


    function createFxNow() {
      window.setTimeout(function () {
        fxNow = undefined;
      });
      return fxNow = jQuery.now();
    } // Generate parameters to create a standard animation


    function genFx(type, includeWidth) {
      var which,
          i = 0,
          attrs = {
        height: type
      }; // If we include width, step value is 1 to do all cssExpand values,
      // otherwise step value is 2 to skip over Left and Right

      includeWidth = includeWidth ? 1 : 0;

      for (; i < 4; i += 2 - includeWidth) {
        which = cssExpand[i];
        attrs["margin" + which] = attrs["padding" + which] = type;
      }

      if (includeWidth) {
        attrs.opacity = attrs.width = type;
      }

      return attrs;
    }

    function createTween(value, prop, animation) {
      var tween,
          collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
          index = 0,
          length = collection.length;

      for (; index < length; index++) {
        if (tween = collection[index].call(animation, prop, value)) {
          // We're done with this property
          return tween;
        }
      }
    }

    function defaultPrefilter(elem, props, opts) {
      var prop,
          value,
          toggle,
          hooks,
          oldfire,
          propTween,
          restoreDisplay,
          display,
          isBox = "width" in props || "height" in props,
          anim = this,
          orig = {},
          style = elem.style,
          hidden = elem.nodeType && isHiddenWithinTree(elem),
          dataShow = dataPriv.get(elem, "fxshow"); // Queue-skipping animations hijack the fx hooks

      if (!opts.queue) {
        hooks = jQuery._queueHooks(elem, "fx");

        if (hooks.unqueued == null) {
          hooks.unqueued = 0;
          oldfire = hooks.empty.fire;

          hooks.empty.fire = function () {
            if (!hooks.unqueued) {
              oldfire();
            }
          };
        }

        hooks.unqueued++;
        anim.always(function () {
          // Ensure the complete handler is called before this completes
          anim.always(function () {
            hooks.unqueued--;

            if (!jQuery.queue(elem, "fx").length) {
              hooks.empty.fire();
            }
          });
        });
      } // Detect show/hide animations


      for (prop in props) {
        value = props[prop];

        if (rfxtypes.test(value)) {
          delete props[prop];
          toggle = toggle || value === "toggle";

          if (value === (hidden ? "hide" : "show")) {
            // Pretend to be hidden if this is a "show" and
            // there is still data from a stopped show/hide
            if (value === "show" && dataShow && dataShow[prop] !== undefined) {
              hidden = true; // Ignore all other no-op show/hide data
            } else {
              continue;
            }
          }

          orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
        }
      } // Bail out if this is a no-op like .hide().hide()


      propTween = !jQuery.isEmptyObject(props);

      if (!propTween && jQuery.isEmptyObject(orig)) {
        return;
      } // Restrict "overflow" and "display" styles during box animations


      if (isBox && elem.nodeType === 1) {
        // Support: IE <=9 - 11, Edge 12 - 13
        // Record all 3 overflow attributes because IE does not infer the shorthand
        // from identically-valued overflowX and overflowY
        opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade

        restoreDisplay = dataShow && dataShow.display;

        if (restoreDisplay == null) {
          restoreDisplay = dataPriv.get(elem, "display");
        }

        display = jQuery.css(elem, "display");

        if (display === "none") {
          if (restoreDisplay) {
            display = restoreDisplay;
          } else {
            // Get nonempty value(s) by temporarily forcing visibility
            showHide([elem], true);
            restoreDisplay = elem.style.display || restoreDisplay;
            display = jQuery.css(elem, "display");
            showHide([elem]);
          }
        } // Animate inline elements as inline-block


        if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
          if (jQuery.css(elem, "float") === "none") {
            // Restore the original display value at the end of pure show/hide animations
            if (!propTween) {
              anim.done(function () {
                style.display = restoreDisplay;
              });

              if (restoreDisplay == null) {
                display = style.display;
                restoreDisplay = display === "none" ? "" : display;
              }
            }

            style.display = "inline-block";
          }
        }
      }

      if (opts.overflow) {
        style.overflow = "hidden";
        anim.always(function () {
          style.overflow = opts.overflow[0];
          style.overflowX = opts.overflow[1];
          style.overflowY = opts.overflow[2];
        });
      } // Implement show/hide animations


      propTween = false;

      for (prop in orig) {
        // General show/hide setup for this element animation
        if (!propTween) {
          if (dataShow) {
            if ("hidden" in dataShow) {
              hidden = dataShow.hidden;
            }
          } else {
            dataShow = dataPriv.access(elem, "fxshow", {
              display: restoreDisplay
            });
          } // Store hidden/visible for toggle so `.stop().toggle()` "reverses"


          if (toggle) {
            dataShow.hidden = !hidden;
          } // Show elements before animating them


          if (hidden) {
            showHide([elem], true);
          }
          /* eslint-disable no-loop-func */


          anim.done(function () {
            /* eslint-enable no-loop-func */
            // The final step of a "hide" animation is actually hiding the element
            if (!hidden) {
              showHide([elem]);
            }

            dataPriv.remove(elem, "fxshow");

            for (prop in orig) {
              jQuery.style(elem, prop, orig[prop]);
            }
          });
        } // Per-property setup


        propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

        if (!(prop in dataShow)) {
          dataShow[prop] = propTween.start;

          if (hidden) {
            propTween.end = propTween.start;
            propTween.start = 0;
          }
        }
      }
    }

    function propFilter(props, specialEasing) {
      var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass

      for (index in props) {
        name = jQuery.camelCase(index);
        easing = specialEasing[name];
        value = props[index];

        if (jQuery.isArray(value)) {
          easing = value[1];
          value = props[index] = value[0];
        }

        if (index !== name) {
          props[name] = value;
          delete props[index];
        }

        hooks = jQuery.cssHooks[name];

        if (hooks && "expand" in hooks) {
          value = hooks.expand(value);
          delete props[name]; // Not quite $.extend, this won't overwrite existing keys.
          // Reusing 'index' because we have the correct "name"

          for (index in value) {
            if (!(index in props)) {
              props[index] = value[index];
              specialEasing[index] = easing;
            }
          }
        } else {
          specialEasing[name] = easing;
        }
      }
    }

    function Animation(elem, properties, options) {
      var result,
          stopped,
          index = 0,
          length = Animation.prefilters.length,
          deferred = jQuery.Deferred().always(function () {
        // Don't match elem in the :animated selector
        delete tick.elem;
      }),
          tick = function () {
        if (stopped) {
          return false;
        }

        var currentTime = fxNow || createFxNow(),
            remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
            // Support: Android 2.3 only
        // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
        temp = remaining / animation.duration || 0,
            percent = 1 - temp,
            index = 0,
            length = animation.tweens.length;

        for (; index < length; index++) {
          animation.tweens[index].run(percent);
        }

        deferred.notifyWith(elem, [animation, percent, remaining]);

        if (percent < 1 && length) {
          return remaining;
        } else {
          deferred.resolveWith(elem, [animation]);
          return false;
        }
      },
          animation = deferred.promise({
        elem: elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(true, {
          specialEasing: {},
          easing: jQuery.easing._default
        }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function (prop, end) {
          var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
          animation.tweens.push(tween);
          return tween;
        },
        stop: function (gotoEnd) {
          var index = 0,
              // If we are going to the end, we want to run all the tweens
          // otherwise we skip this part
          length = gotoEnd ? animation.tweens.length : 0;

          if (stopped) {
            return this;
          }

          stopped = true;

          for (; index < length; index++) {
            animation.tweens[index].run(1);
          } // Resolve when we played the last frame; otherwise, reject


          if (gotoEnd) {
            deferred.notifyWith(elem, [animation, 1, 0]);
            deferred.resolveWith(elem, [animation, gotoEnd]);
          } else {
            deferred.rejectWith(elem, [animation, gotoEnd]);
          }

          return this;
        }
      }),
          props = animation.props;

      propFilter(props, animation.opts.specialEasing);

      for (; index < length; index++) {
        result = Animation.prefilters[index].call(animation, elem, props, animation.opts);

        if (result) {
          if (jQuery.isFunction(result.stop)) {
            jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
          }

          return result;
        }
      }

      jQuery.map(props, createTween, animation);

      if (jQuery.isFunction(animation.opts.start)) {
        animation.opts.start.call(elem, animation);
      }

      jQuery.fx.timer(jQuery.extend(tick, {
        elem: elem,
        anim: animation,
        queue: animation.opts.queue
      })); // attach callbacks from options

      return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }

    jQuery.Animation = jQuery.extend(Animation, {
      tweeners: {
        "*": [function (prop, value) {
          var tween = this.createTween(prop, value);
          adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
          return tween;
        }]
      },
      tweener: function (props, callback) {
        if (jQuery.isFunction(props)) {
          callback = props;
          props = ["*"];
        } else {
          props = props.match(rnothtmlwhite);
        }

        var prop,
            index = 0,
            length = props.length;

        for (; index < length; index++) {
          prop = props[index];
          Animation.tweeners[prop] = Animation.tweeners[prop] || [];
          Animation.tweeners[prop].unshift(callback);
        }
      },
      prefilters: [defaultPrefilter],
      prefilter: function (callback, prepend) {
        if (prepend) {
          Animation.prefilters.unshift(callback);
        } else {
          Animation.prefilters.push(callback);
        }
      }
    });

    jQuery.speed = function (speed, easing, fn) {
      var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
        complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
        duration: speed,
        easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
      }; // Go to the end state if fx are off or if document is hidden

      if (jQuery.fx.off || document.hidden) {
        opt.duration = 0;
      } else {
        if (typeof opt.duration !== "number") {
          if (opt.duration in jQuery.fx.speeds) {
            opt.duration = jQuery.fx.speeds[opt.duration];
          } else {
            opt.duration = jQuery.fx.speeds._default;
          }
        }
      } // Normalize opt.queue - true/undefined/null -> "fx"


      if (opt.queue == null || opt.queue === true) {
        opt.queue = "fx";
      } // Queueing


      opt.old = opt.complete;

      opt.complete = function () {
        if (jQuery.isFunction(opt.old)) {
          opt.old.call(this);
        }

        if (opt.queue) {
          jQuery.dequeue(this, opt.queue);
        }
      };

      return opt;
    };

    jQuery.fn.extend({
      fadeTo: function (speed, to, easing, callback) {
        // Show any hidden elements after setting opacity to 0
        return this.filter(isHiddenWithinTree).css("opacity", 0).show() // Animate to the value specified
        .end().animate({
          opacity: to
        }, speed, easing, callback);
      },
      animate: function (prop, speed, easing, callback) {
        var empty = jQuery.isEmptyObject(prop),
            optall = jQuery.speed(speed, easing, callback),
            doAnimation = function () {
          // Operate on a copy of prop so per-property easing won't be lost
          var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately

          if (empty || dataPriv.get(this, "finish")) {
            anim.stop(true);
          }
        };

        doAnimation.finish = doAnimation;
        return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
      },
      stop: function (type, clearQueue, gotoEnd) {
        var stopQueue = function (hooks) {
          var stop = hooks.stop;
          delete hooks.stop;
          stop(gotoEnd);
        };

        if (typeof type !== "string") {
          gotoEnd = clearQueue;
          clearQueue = type;
          type = undefined;
        }

        if (clearQueue && type !== false) {
          this.queue(type || "fx", []);
        }

        return this.each(function () {
          var dequeue = true,
              index = type != null && type + "queueHooks",
              timers = jQuery.timers,
              data = dataPriv.get(this);

          if (index) {
            if (data[index] && data[index].stop) {
              stopQueue(data[index]);
            }
          } else {
            for (index in data) {
              if (data[index] && data[index].stop && rrun.test(index)) {
                stopQueue(data[index]);
              }
            }
          }

          for (index = timers.length; index--;) {
            if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
              timers[index].anim.stop(gotoEnd);
              dequeue = false;
              timers.splice(index, 1);
            }
          } // Start the next in the queue if the last step wasn't forced.
          // Timers currently will call their complete callbacks, which
          // will dequeue but only if they were gotoEnd.


          if (dequeue || !gotoEnd) {
            jQuery.dequeue(this, type);
          }
        });
      },
      finish: function (type) {
        if (type !== false) {
          type = type || "fx";
        }

        return this.each(function () {
          var index,
              data = dataPriv.get(this),
              queue = data[type + "queue"],
              hooks = data[type + "queueHooks"],
              timers = jQuery.timers,
              length = queue ? queue.length : 0; // Enable finishing flag on private data

          data.finish = true; // Empty the queue first

          jQuery.queue(this, type, []);

          if (hooks && hooks.stop) {
            hooks.stop.call(this, true);
          } // Look for any active animations, and finish them


          for (index = timers.length; index--;) {
            if (timers[index].elem === this && timers[index].queue === type) {
              timers[index].anim.stop(true);
              timers.splice(index, 1);
            }
          } // Look for any animations in the old queue and finish them


          for (index = 0; index < length; index++) {
            if (queue[index] && queue[index].finish) {
              queue[index].finish.call(this);
            }
          } // Turn off finishing flag


          delete data.finish;
        });
      }
    });
    jQuery.each(["toggle", "show", "hide"], function (i, name) {
      var cssFn = jQuery.fn[name];

      jQuery.fn[name] = function (speed, easing, callback) {
        return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
      };
    }); // Generate shortcuts for custom animations

    jQuery.each({
      slideDown: genFx("show"),
      slideUp: genFx("hide"),
      slideToggle: genFx("toggle"),
      fadeIn: {
        opacity: "show"
      },
      fadeOut: {
        opacity: "hide"
      },
      fadeToggle: {
        opacity: "toggle"
      }
    }, function (name, props) {
      jQuery.fn[name] = function (speed, easing, callback) {
        return this.animate(props, speed, easing, callback);
      };
    });
    jQuery.timers = [];

    jQuery.fx.tick = function () {
      var timer,
          i = 0,
          timers = jQuery.timers;
      fxNow = jQuery.now();

      for (; i < timers.length; i++) {
        timer = timers[i]; // Checks the timer has not already been removed

        if (!timer() && timers[i] === timer) {
          timers.splice(i--, 1);
        }
      }

      if (!timers.length) {
        jQuery.fx.stop();
      }

      fxNow = undefined;
    };

    jQuery.fx.timer = function (timer) {
      jQuery.timers.push(timer);

      if (timer()) {
        jQuery.fx.start();
      } else {
        jQuery.timers.pop();
      }
    };

    jQuery.fx.interval = 13;

    jQuery.fx.start = function () {
      if (!timerId) {
        timerId = window.requestAnimationFrame ? window.requestAnimationFrame(raf) : window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
      }
    };

    jQuery.fx.stop = function () {
      if (window.cancelAnimationFrame) {
        window.cancelAnimationFrame(timerId);
      } else {
        window.clearInterval(timerId);
      }

      timerId = null;
    };

    jQuery.fx.speeds = {
      slow: 600,
      fast: 200,
      // Default speed
      _default: 400
    }; // Based off of the plugin by Clint Helfers, with permission.
    // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/

    jQuery.fn.delay = function (time, type) {
      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
      type = type || "fx";
      return this.queue(type, function (next, hooks) {
        var timeout = window.setTimeout(next, time);

        hooks.stop = function () {
          window.clearTimeout(timeout);
        };
      });
    };

    (function () {
      var input = document.createElement("input"),
          select = document.createElement("select"),
          opt = select.appendChild(document.createElement("option"));
      input.type = "checkbox"; // Support: Android <=4.3 only
      // Default value for a checkbox should be "on"

      support.checkOn = input.value !== ""; // Support: IE <=11 only
      // Must access selectedIndex to make default options select

      support.optSelected = opt.selected; // Support: IE <=11 only
      // An input loses its value after becoming a radio

      input = document.createElement("input");
      input.value = "t";
      input.type = "radio";
      support.radioValue = input.value === "t";
    })();

    var boolHook,
        attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
      attr: function (name, value) {
        return access(this, jQuery.attr, name, value, arguments.length > 1);
      },
      removeAttr: function (name) {
        return this.each(function () {
          jQuery.removeAttr(this, name);
        });
      }
    });
    jQuery.extend({
      attr: function (elem, name, value) {
        var ret,
            hooks,
            nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes

        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        } // Fallback to prop when attributes are not supported


        if (typeof elem.getAttribute === "undefined") {
          return jQuery.prop(elem, name, value);
        } // Attribute hooks are determined by the lowercase version
        // Grab necessary hook if one is defined


        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
          hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
        }

        if (value !== undefined) {
          if (value === null) {
            jQuery.removeAttr(elem, name);
            return;
          }

          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
            return ret;
          }

          elem.setAttribute(name, value + "");
          return value;
        }

        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
          return ret;
        }

        ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined

        return ret == null ? undefined : ret;
      },
      attrHooks: {
        type: {
          set: function (elem, value) {
            if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
              var val = elem.value;
              elem.setAttribute("type", value);

              if (val) {
                elem.value = val;
              }

              return value;
            }
          }
        }
      },
      removeAttr: function (elem, value) {
        var name,
            i = 0,
            // Attribute names can contain non-HTML whitespace characters
        // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
        attrNames = value && value.match(rnothtmlwhite);

        if (attrNames && elem.nodeType === 1) {
          while (name = attrNames[i++]) {
            elem.removeAttribute(name);
          }
        }
      }
    }); // Hooks for boolean attributes

    boolHook = {
      set: function (elem, value, name) {
        if (value === false) {
          // Remove boolean attributes when set to false
          jQuery.removeAttr(elem, name);
        } else {
          elem.setAttribute(name, name);
        }

        return name;
      }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
      var getter = attrHandle[name] || jQuery.find.attr;

      attrHandle[name] = function (elem, name, isXML) {
        var ret,
            handle,
            lowercaseName = name.toLowerCase();

        if (!isXML) {
          // Avoid an infinite loop by temporarily removing this function from the getter
          handle = attrHandle[lowercaseName];
          attrHandle[lowercaseName] = ret;
          ret = getter(elem, name, isXML) != null ? lowercaseName : null;
          attrHandle[lowercaseName] = handle;
        }

        return ret;
      };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i,
        rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
      prop: function (name, value) {
        return access(this, jQuery.prop, name, value, arguments.length > 1);
      },
      removeProp: function (name) {
        return this.each(function () {
          delete this[jQuery.propFix[name] || name];
        });
      }
    });
    jQuery.extend({
      prop: function (elem, name, value) {
        var ret,
            hooks,
            nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes

        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }

        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
          // Fix name and attach hooks
          name = jQuery.propFix[name] || name;
          hooks = jQuery.propHooks[name];
        }

        if (value !== undefined) {
          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
            return ret;
          }

          return elem[name] = value;
        }

        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
          return ret;
        }

        return elem[name];
      },
      propHooks: {
        tabIndex: {
          get: function (elem) {
            // Support: IE <=9 - 11 only
            // elem.tabIndex doesn't always return the
            // correct value when it hasn't been explicitly set
            // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
            // Use proper attribute retrieval(#12072)
            var tabindex = jQuery.find.attr(elem, "tabindex");

            if (tabindex) {
              return parseInt(tabindex, 10);
            }

            if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
              return 0;
            }

            return -1;
          }
        }
      },
      propFix: {
        "for": "htmlFor",
        "class": "className"
      }
    }); // Support: IE <=11 only
    // Accessing the selectedIndex property
    // forces the browser to respect setting selected
    // on the option
    // The getter ensures a default option is selected
    // when in an optgroup
    // eslint rule "no-unused-expressions" is disabled for this code
    // since it considers such accessions noop

    if (!support.optSelected) {
      jQuery.propHooks.selected = {
        get: function (elem) {
          /* eslint no-unused-expressions: "off" */
          var parent = elem.parentNode;

          if (parent && parent.parentNode) {
            parent.parentNode.selectedIndex;
          }

          return null;
        },
        set: function (elem) {
          /* eslint no-unused-expressions: "off" */
          var parent = elem.parentNode;

          if (parent) {
            parent.selectedIndex;

            if (parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
          }
        }
      };
    }

    jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
      jQuery.propFix[this.toLowerCase()] = this;
    }); // Strip and collapse whitespace according to HTML spec
    // https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace

    function stripAndCollapse(value) {
      var tokens = value.match(rnothtmlwhite) || [];
      return tokens.join(" ");
    }

    function getClass(elem) {
      return elem.getAttribute && elem.getAttribute("class") || "";
    }

    jQuery.fn.extend({
      addClass: function (value) {
        var classes,
            elem,
            cur,
            curValue,
            clazz,
            j,
            finalValue,
            i = 0;

        if (jQuery.isFunction(value)) {
          return this.each(function (j) {
            jQuery(this).addClass(value.call(this, j, getClass(this)));
          });
        }

        if (typeof value === "string" && value) {
          classes = value.match(rnothtmlwhite) || [];

          while (elem = this[i++]) {
            curValue = getClass(elem);
            cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

            if (cur) {
              j = 0;

              while (clazz = classes[j++]) {
                if (cur.indexOf(" " + clazz + " ") < 0) {
                  cur += clazz + " ";
                }
              } // Only assign if different to avoid unneeded rendering.


              finalValue = stripAndCollapse(cur);

              if (curValue !== finalValue) {
                elem.setAttribute("class", finalValue);
              }
            }
          }
        }

        return this;
      },
      removeClass: function (value) {
        var classes,
            elem,
            cur,
            curValue,
            clazz,
            j,
            finalValue,
            i = 0;

        if (jQuery.isFunction(value)) {
          return this.each(function (j) {
            jQuery(this).removeClass(value.call(this, j, getClass(this)));
          });
        }

        if (!arguments.length) {
          return this.attr("class", "");
        }

        if (typeof value === "string" && value) {
          classes = value.match(rnothtmlwhite) || [];

          while (elem = this[i++]) {
            curValue = getClass(elem); // This expression is here for better compressibility (see addClass)

            cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

            if (cur) {
              j = 0;

              while (clazz = classes[j++]) {
                // Remove *all* instances
                while (cur.indexOf(" " + clazz + " ") > -1) {
                  cur = cur.replace(" " + clazz + " ", " ");
                }
              } // Only assign if different to avoid unneeded rendering.


              finalValue = stripAndCollapse(cur);

              if (curValue !== finalValue) {
                elem.setAttribute("class", finalValue);
              }
            }
          }
        }

        return this;
      },
      toggleClass: function (value, stateVal) {
        var type = typeof value;

        if (typeof stateVal === "boolean" && type === "string") {
          return stateVal ? this.addClass(value) : this.removeClass(value);
        }

        if (jQuery.isFunction(value)) {
          return this.each(function (i) {
            jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
          });
        }

        return this.each(function () {
          var className, i, self, classNames;

          if (type === "string") {
            // Toggle individual class names
            i = 0;
            self = jQuery(this);
            classNames = value.match(rnothtmlwhite) || [];

            while (className = classNames[i++]) {
              // Check each className given, space separated list
              if (self.hasClass(className)) {
                self.removeClass(className);
              } else {
                self.addClass(className);
              }
            } // Toggle whole class name

          } else if (value === undefined || type === "boolean") {
            className = getClass(this);

            if (className) {
              // Store className if set
              dataPriv.set(this, "__className__", className);
            } // If the element has a class name or if we're passed `false`,
            // then remove the whole classname (if there was one, the above saved it).
            // Otherwise bring back whatever was previously saved (if anything),
            // falling back to the empty string if nothing was stored.


            if (this.setAttribute) {
              this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
            }
          }
        });
      },
      hasClass: function (selector) {
        var className,
            elem,
            i = 0;
        className = " " + selector + " ";

        while (elem = this[i++]) {
          if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
            return true;
          }
        }

        return false;
      }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
      val: function (value) {
        var hooks,
            ret,
            isFunction,
            elem = this[0];

        if (!arguments.length) {
          if (elem) {
            hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

            if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
              return ret;
            }

            ret = elem.value; // Handle most common string cases

            if (typeof ret === "string") {
              return ret.replace(rreturn, "");
            } // Handle cases where value is null/undef or number


            return ret == null ? "" : ret;
          }

          return;
        }

        isFunction = jQuery.isFunction(value);
        return this.each(function (i) {
          var val;

          if (this.nodeType !== 1) {
            return;
          }

          if (isFunction) {
            val = value.call(this, i, jQuery(this).val());
          } else {
            val = value;
          } // Treat null/undefined as ""; convert numbers to string


          if (val == null) {
            val = "";
          } else if (typeof val === "number") {
            val += "";
          } else if (jQuery.isArray(val)) {
            val = jQuery.map(val, function (value) {
              return value == null ? "" : value + "";
            });
          }

          hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting

          if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
            this.value = val;
          }
        });
      }
    });
    jQuery.extend({
      valHooks: {
        option: {
          get: function (elem) {
            var val = jQuery.find.attr(elem, "value");
            return val != null ? val : // Support: IE <=10 - 11 only
            // option.text throws exceptions (#14686, #14858)
            // Strip and collapse whitespace
            // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
            stripAndCollapse(jQuery.text(elem));
          }
        },
        select: {
          get: function (elem) {
            var value,
                option,
                i,
                options = elem.options,
                index = elem.selectedIndex,
                one = elem.type === "select-one",
                values = one ? null : [],
                max = one ? index + 1 : options.length;

            if (index < 0) {
              i = max;
            } else {
              i = one ? index : 0;
            } // Loop through all the selected options


            for (; i < max; i++) {
              option = options[i]; // Support: IE <=9 only
              // IE8-9 doesn't update selected after form reset (#2551)

              if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
              !option.disabled && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                // Get the specific value for the option
                value = jQuery(option).val(); // We don't need an array for one selects

                if (one) {
                  return value;
                } // Multi-Selects return an array


                values.push(value);
              }
            }

            return values;
          },
          set: function (elem, value) {
            var optionSet,
                option,
                options = elem.options,
                values = jQuery.makeArray(value),
                i = options.length;

            while (i--) {
              option = options[i];
              /* eslint-disable no-cond-assign */

              if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                optionSet = true;
              }
              /* eslint-enable no-cond-assign */

            } // Force browsers to behave consistently when non-matching value is set


            if (!optionSet) {
              elem.selectedIndex = -1;
            }

            return values;
          }
        }
      }
    }); // Radios and checkboxes getter/setter

    jQuery.each(["radio", "checkbox"], function () {
      jQuery.valHooks[this] = {
        set: function (elem, value) {
          if (jQuery.isArray(value)) {
            return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
          }
        }
      };

      if (!support.checkOn) {
        jQuery.valHooks[this].get = function (elem) {
          return elem.getAttribute("value") === null ? "on" : elem.value;
        };
      }
    }); // Return jQuery for attributes-only inclusion

    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
    jQuery.extend(jQuery.event, {
      trigger: function (event, data, elem, onlyHandlers) {
        var i,
            cur,
            tmp,
            bubbleType,
            ontype,
            handle,
            special,
            eventPath = [elem || document],
            type = hasOwn.call(event, "type") ? event.type : event,
            namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
        cur = tmp = elem = elem || document; // Don't do events on text and comment nodes

        if (elem.nodeType === 3 || elem.nodeType === 8) {
          return;
        } // focus/blur morphs to focusin/out; ensure we're not firing them right now


        if (rfocusMorph.test(type + jQuery.event.triggered)) {
          return;
        }

        if (type.indexOf(".") > -1) {
          // Namespaced trigger; create a regexp to match event type in handle()
          namespaces = type.split(".");
          type = namespaces.shift();
          namespaces.sort();
        }

        ontype = type.indexOf(":") < 0 && "on" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string

        event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)

        event.isTrigger = onlyHandlers ? 2 : 3;
        event.namespace = namespaces.join(".");
        event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null; // Clean up the event in case it is being reused

        event.result = undefined;

        if (!event.target) {
          event.target = elem;
        } // Clone any incoming data and prepend the event, creating the handler arg list


        data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines

        special = jQuery.event.special[type] || {};

        if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
          return;
        } // Determine event propagation path in advance, per W3C events spec (#9951)
        // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)


        if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
          bubbleType = special.delegateType || type;

          if (!rfocusMorph.test(bubbleType + type)) {
            cur = cur.parentNode;
          }

          for (; cur; cur = cur.parentNode) {
            eventPath.push(cur);
            tmp = cur;
          } // Only add window if we got to document (e.g., not plain obj or detached DOM)


          if (tmp === (elem.ownerDocument || document)) {
            eventPath.push(tmp.defaultView || tmp.parentWindow || window);
          }
        } // Fire handlers on the event path


        i = 0;

        while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
          event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler

          handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");

          if (handle) {
            handle.apply(cur, data);
          } // Native handler


          handle = ontype && cur[ontype];

          if (handle && handle.apply && acceptData(cur)) {
            event.result = handle.apply(cur, data);

            if (event.result === false) {
              event.preventDefault();
            }
          }
        }

        event.type = type; // If nobody prevented the default action, do it now

        if (!onlyHandlers && !event.isDefaultPrevented()) {
          if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
            // Call a native DOM method on the target with the same name as the event.
            // Don't do default actions on window, that's where global variables be (#6170)
            if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
              // Don't re-trigger an onFOO event when we call its FOO() method
              tmp = elem[ontype];

              if (tmp) {
                elem[ontype] = null;
              } // Prevent re-triggering of the same event, since we already bubbled it above


              jQuery.event.triggered = type;
              elem[type]();
              jQuery.event.triggered = undefined;

              if (tmp) {
                elem[ontype] = tmp;
              }
            }
          }
        }

        return event.result;
      },
      // Piggyback on a donor event to simulate a different one
      // Used only for `focus(in | out)` events
      simulate: function (type, elem, event) {
        var e = jQuery.extend(new jQuery.Event(), event, {
          type: type,
          isSimulated: true
        });
        jQuery.event.trigger(e, null, elem);
      }
    });
    jQuery.fn.extend({
      trigger: function (type, data) {
        return this.each(function () {
          jQuery.event.trigger(type, data, this);
        });
      },
      triggerHandler: function (type, data) {
        var elem = this[0];

        if (elem) {
          return jQuery.event.trigger(type, data, elem, true);
        }
      }
    });
    jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (i, name) {
      // Handle event binding
      jQuery.fn[name] = function (data, fn) {
        return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
      };
    });
    jQuery.fn.extend({
      hover: function (fnOver, fnOut) {
        return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
      }
    });
    support.focusin = "onfocusin" in window; // Support: Firefox <=44
    // Firefox doesn't have focus(in | out) events
    // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
    //
    // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
    // focus(in | out) events fire after focus & blur events,
    // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
    // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857

    if (!support.focusin) {
      jQuery.each({
        focus: "focusin",
        blur: "focusout"
      }, function (orig, fix) {
        // Attach a single capturing handler on the document while someone wants focusin/focusout
        var handler = function (event) {
          jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
        };

        jQuery.event.special[fix] = {
          setup: function () {
            var doc = this.ownerDocument || this,
                attaches = dataPriv.access(doc, fix);

            if (!attaches) {
              doc.addEventListener(orig, handler, true);
            }

            dataPriv.access(doc, fix, (attaches || 0) + 1);
          },
          teardown: function () {
            var doc = this.ownerDocument || this,
                attaches = dataPriv.access(doc, fix) - 1;

            if (!attaches) {
              doc.removeEventListener(orig, handler, true);
              dataPriv.remove(doc, fix);
            } else {
              dataPriv.access(doc, fix, attaches);
            }
          }
        };
      });
    }

    var location = window.location;
    var nonce = jQuery.now();
    var rquery = /\?/; // Cross-browser xml parsing

    jQuery.parseXML = function (data) {
      var xml;

      if (!data || typeof data !== "string") {
        return null;
      } // Support: IE 9 - 11 only
      // IE throws on parseFromString with invalid input.


      try {
        xml = new window.DOMParser().parseFromString(data, "text/xml");
      } catch (e) {
        xml = undefined;
      }

      if (!xml || xml.getElementsByTagName("parsererror").length) {
        jQuery.error("Invalid XML: " + data);
      }

      return xml;
    };

    var rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;

    function buildParams(prefix, obj, traditional, add) {
      var name;

      if (jQuery.isArray(obj)) {
        // Serialize array item.
        jQuery.each(obj, function (i, v) {
          if (traditional || rbracket.test(prefix)) {
            // Treat each array item as a scalar.
            add(prefix, v);
          } else {
            // Item is non-scalar (array or object), encode its numeric index.
            buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
          }
        });
      } else if (!traditional && jQuery.type(obj) === "object") {
        // Serialize object item.
        for (name in obj) {
          buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
        }
      } else {
        // Serialize scalar item.
        add(prefix, obj);
      }
    } // Serialize an array of form elements or a set of
    // key/values into a query string


    jQuery.param = function (a, traditional) {
      var prefix,
          s = [],
          add = function (key, valueOrFunction) {
        // If value is a function, invoke it and use its return value
        var value = jQuery.isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
      }; // If an array was passed in, assume that it is an array of form elements.


      if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
        // Serialize the form elements
        jQuery.each(a, function () {
          add(this.name, this.value);
        });
      } else {
        // If traditional, encode the "old" way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for (prefix in a) {
          buildParams(prefix, a[prefix], traditional, add);
        }
      } // Return the resulting serialization


      return s.join("&");
    };

    jQuery.fn.extend({
      serialize: function () {
        return jQuery.param(this.serializeArray());
      },
      serializeArray: function () {
        return this.map(function () {
          // Can add propHook for "elements" to filter or add form elements
          var elements = jQuery.prop(this, "elements");
          return elements ? jQuery.makeArray(elements) : this;
        }).filter(function () {
          var type = this.type; // Use .is( ":disabled" ) so that fieldset[disabled] works

          return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
        }).map(function (i, elem) {
          var val = jQuery(this).val();

          if (val == null) {
            return null;
          }

          if (jQuery.isArray(val)) {
            return jQuery.map(val, function (val) {
              return {
                name: elem.name,
                value: val.replace(rCRLF, "\r\n")
              };
            });
          }

          return {
            name: elem.name,
            value: val.replace(rCRLF, "\r\n")
          };
        }).get();
      }
    });
    var r20 = /%20/g,
        rhash = /#.*$/,
        rantiCache = /([?&])_=[^&]*/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
        // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,

    /* Prefilters
     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
     * 2) These are called:
     *    - BEFORE asking for a transport
     *    - AFTER param serialization (s.data is a string if s.processData is true)
     * 3) key is the dataType
     * 4) the catchall symbol "*" can be used
     * 5) execution will start with transport dataType and THEN continue down to "*" if needed
     */
    prefilters = {},

    /* Transports bindings
     * 1) key is the dataType
     * 2) the catchall symbol "*" can be used
     * 3) selection will start with transport dataType and THEN go to "*" if needed
     */
    transports = {},
        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = "*/".concat("*"),
        // Anchor tag for parsing the document origin
    originAnchor = document.createElement("a");
    originAnchor.href = location.href; // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport

    function addToPrefiltersOrTransports(structure) {
      // dataTypeExpression is optional and defaults to "*"
      return function (dataTypeExpression, func) {
        if (typeof dataTypeExpression !== "string") {
          func = dataTypeExpression;
          dataTypeExpression = "*";
        }

        var dataType,
            i = 0,
            dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

        if (jQuery.isFunction(func)) {
          // For each dataType in the dataTypeExpression
          while (dataType = dataTypes[i++]) {
            // Prepend if requested
            if (dataType[0] === "+") {
              dataType = dataType.slice(1) || "*";
              (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append
            } else {
              (structure[dataType] = structure[dataType] || []).push(func);
            }
          }
        }
      };
    } // Base inspection function for prefilters and transports


    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
      var inspected = {},
          seekingTransport = structure === transports;

      function inspect(dataType) {
        var selected;
        inspected[dataType] = true;
        jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
          var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);

          if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
            options.dataTypes.unshift(dataTypeOrTransport);
            inspect(dataTypeOrTransport);
            return false;
          } else if (seekingTransport) {
            return !(selected = dataTypeOrTransport);
          }
        });
        return selected;
      }

      return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    } // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887


    function ajaxExtend(target, src) {
      var key,
          deep,
          flatOptions = jQuery.ajaxSettings.flatOptions || {};

      for (key in src) {
        if (src[key] !== undefined) {
          (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
        }
      }

      if (deep) {
        jQuery.extend(true, target, deep);
      }

      return target;
    }
    /* Handles responses to an ajax request:
     * - finds the right dataType (mediates between content-type and expected dataType)
     * - returns the corresponding response
     */


    function ajaxHandleResponses(s, jqXHR, responses) {
      var ct,
          type,
          finalDataType,
          firstDataType,
          contents = s.contents,
          dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process

      while (dataTypes[0] === "*") {
        dataTypes.shift();

        if (ct === undefined) {
          ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
        }
      } // Check if we're dealing with a known content-type


      if (ct) {
        for (type in contents) {
          if (contents[type] && contents[type].test(ct)) {
            dataTypes.unshift(type);
            break;
          }
        }
      } // Check to see if we have a response for the expected dataType


      if (dataTypes[0] in responses) {
        finalDataType = dataTypes[0];
      } else {
        // Try convertible dataTypes
        for (type in responses) {
          if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
            finalDataType = type;
            break;
          }

          if (!firstDataType) {
            firstDataType = type;
          }
        } // Or just use first one


        finalDataType = finalDataType || firstDataType;
      } // If we found a dataType
      // We add the dataType to the list if needed
      // and return the corresponding response


      if (finalDataType) {
        if (finalDataType !== dataTypes[0]) {
          dataTypes.unshift(finalDataType);
        }

        return responses[finalDataType];
      }
    }
    /* Chain conversions given the request and the original response
     * Also sets the responseXXX fields on the jqXHR instance
     */


    function ajaxConvert(s, response, jqXHR, isSuccess) {
      var conv2,
          current,
          conv,
          tmp,
          prev,
          converters = {},
          // Work with a copy of dataTypes in case we need to modify it for conversion
      dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys

      if (dataTypes[1]) {
        for (conv in s.converters) {
          converters[conv.toLowerCase()] = s.converters[conv];
        }
      }

      current = dataTypes.shift(); // Convert to each sequential dataType

      while (current) {
        if (s.responseFields[current]) {
          jqXHR[s.responseFields[current]] = response;
        } // Apply the dataFilter if provided


        if (!prev && isSuccess && s.dataFilter) {
          response = s.dataFilter(response, s.dataType);
        }

        prev = current;
        current = dataTypes.shift();

        if (current) {
          // There's only work to do if current dataType is non-auto
          if (current === "*") {
            current = prev; // Convert response if prev dataType is non-auto and differs from current
          } else if (prev !== "*" && prev !== current) {
            // Seek a direct converter
            conv = converters[prev + " " + current] || converters["* " + current]; // If none found, seek a pair

            if (!conv) {
              for (conv2 in converters) {
                // If conv2 outputs current
                tmp = conv2.split(" ");

                if (tmp[1] === current) {
                  // If prev can be converted to accepted input
                  conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];

                  if (conv) {
                    // Condense equivalence converters
                    if (conv === true) {
                      conv = converters[conv2]; // Otherwise, insert the intermediate dataType
                    } else if (converters[conv2] !== true) {
                      current = tmp[0];
                      dataTypes.unshift(tmp[1]);
                    }

                    break;
                  }
                }
              }
            } // Apply converter (if not an equivalence)


            if (conv !== true) {
              // Unless errors are allowed to bubble, catch and return them
              if (conv && s.throws) {
                response = conv(response);
              } else {
                try {
                  response = conv(response);
                } catch (e) {
                  return {
                    state: "parsererror",
                    error: conv ? e : "No conversion from " + prev + " to " + current
                  };
                }
              }
            }
          }
        }
      }

      return {
        state: "success",
        data: response
      };
    }

    jQuery.extend({
      // Counter for holding the number of active queries
      active: 0,
      // Last-Modified header cache for next request
      lastModified: {},
      etag: {},
      ajaxSettings: {
        url: location.href,
        type: "GET",
        isLocal: rlocalProtocol.test(location.protocol),
        global: true,
        processData: true,
        async: true,
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",

        /*
        timeout: 0,
        data: null,
        dataType: null,
        username: null,
        password: null,
        cache: null,
        throws: false,
        traditional: false,
        headers: {},
        */
        accepts: {
          "*": allTypes,
          text: "text/plain",
          html: "text/html",
          xml: "application/xml, text/xml",
          json: "application/json, text/javascript"
        },
        contents: {
          xml: /\bxml\b/,
          html: /\bhtml/,
          json: /\bjson\b/
        },
        responseFields: {
          xml: "responseXML",
          text: "responseText",
          json: "responseJSON"
        },
        // Data converters
        // Keys separate source (or catchall "*") and destination types with a single space
        converters: {
          // Convert anything to text
          "* text": String,
          // Text to html (true = no transformation)
          "text html": true,
          // Evaluate text as a json expression
          "text json": JSON.parse,
          // Parse text as xml
          "text xml": jQuery.parseXML
        },
        // For options that shouldn't be deep extended:
        // you can add your own custom options here if
        // and when you create one that shouldn't be
        // deep extended (see ajaxExtend)
        flatOptions: {
          url: true,
          context: true
        }
      },
      // Creates a full fledged settings object into target
      // with both ajaxSettings and settings fields.
      // If target is omitted, writes into ajaxSettings.
      ajaxSetup: function (target, settings) {
        return settings ? // Building a settings object
        ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
        ajaxExtend(jQuery.ajaxSettings, target);
      },
      ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
      ajaxTransport: addToPrefiltersOrTransports(transports),
      // Main method
      ajax: function (url, options) {
        // If url is an object, simulate pre-1.5 signature
        if (typeof url === "object") {
          options = url;
          url = undefined;
        } // Force options to be an object


        options = options || {};
        var transport,
            // URL without anti-cache param
        cacheURL,
            // Response headers
        responseHeadersString,
            responseHeaders,
            // timeout handle
        timeoutTimer,
            // Url cleanup var
        urlAnchor,
            // Request state (becomes false upon send and true upon completion)
        completed,
            // To know if global events are to be dispatched
        fireGlobals,
            // Loop variable
        i,
            // uncached part of the url
        uncached,
            // Create the final options object
        s = jQuery.ajaxSetup({}, options),
            // Callbacks context
        callbackContext = s.context || s,
            // Context for global events is callbackContext if it is a DOM node or jQuery collection
        globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
            // Deferreds
        deferred = jQuery.Deferred(),
            completeDeferred = jQuery.Callbacks("once memory"),
            // Status-dependent callbacks
        statusCode = s.statusCode || {},
            // Headers (they are sent all at once)
        requestHeaders = {},
            requestHeadersNames = {},
            // Default abort message
        strAbort = "canceled",
            // Fake xhr
        jqXHR = {
          readyState: 0,
          // Builds headers hashtable if needed
          getResponseHeader: function (key) {
            var match;

            if (completed) {
              if (!responseHeaders) {
                responseHeaders = {};

                while (match = rheaders.exec(responseHeadersString)) {
                  responseHeaders[match[1].toLowerCase()] = match[2];
                }
              }

              match = responseHeaders[key.toLowerCase()];
            }

            return match == null ? null : match;
          },
          // Raw string
          getAllResponseHeaders: function () {
            return completed ? responseHeadersString : null;
          },
          // Caches the header
          setRequestHeader: function (name, value) {
            if (completed == null) {
              name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
              requestHeaders[name] = value;
            }

            return this;
          },
          // Overrides response content-type header
          overrideMimeType: function (type) {
            if (completed == null) {
              s.mimeType = type;
            }

            return this;
          },
          // Status-dependent callbacks
          statusCode: function (map) {
            var code;

            if (map) {
              if (completed) {
                // Execute the appropriate callbacks
                jqXHR.always(map[jqXHR.status]);
              } else {
                // Lazy-add the new callbacks in a way that preserves old ones
                for (code in map) {
                  statusCode[code] = [statusCode[code], map[code]];
                }
              }
            }

            return this;
          },
          // Cancel the request
          abort: function (statusText) {
            var finalText = statusText || strAbort;

            if (transport) {
              transport.abort(finalText);
            }

            done(0, finalText);
            return this;
          }
        }; // Attach deferreds

        deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)
        // Handle falsy url in the settings object (#10093: consistency with old signature)
        // We also use the url parameter if available

        s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"); // Alias method option to type as per ticket #12004

        s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list

        s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""]; // A cross-domain request is in order when the origin doesn't match the current origin.

        if (s.crossDomain == null) {
          urlAnchor = document.createElement("a"); // Support: IE <=8 - 11, Edge 12 - 13
          // IE throws exception on accessing the href property if url is malformed,
          // e.g. http://example.com:80x/

          try {
            urlAnchor.href = s.url; // Support: IE <=8 - 11 only
            // Anchor's host property isn't correctly set when s.url is relative

            urlAnchor.href = urlAnchor.href;
            s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
          } catch (e) {
            // If there is an error parsing the URL, assume it is crossDomain,
            // it can be rejected by the transport if it is invalid
            s.crossDomain = true;
          }
        } // Convert data if not already a string


        if (s.data && s.processData && typeof s.data !== "string") {
          s.data = jQuery.param(s.data, s.traditional);
        } // Apply prefilters


        inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there

        if (completed) {
          return jqXHR;
        } // We can fire global events as of now if asked to
        // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)


        fireGlobals = jQuery.event && s.global; // Watch for a new set of requests

        if (fireGlobals && jQuery.active++ === 0) {
          jQuery.event.trigger("ajaxStart");
        } // Uppercase the type


        s.type = s.type.toUpperCase(); // Determine if request has content

        s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since
        // and/or If-None-Match header later on
        // Remove hash to simplify url manipulation

        cacheURL = s.url.replace(rhash, ""); // More options handling for requests with no content

        if (!s.hasContent) {
          // Remember the hash so we can put it back
          uncached = s.url.slice(cacheURL.length); // If data is available, append data to url

          if (s.data) {
            cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data; // #9682: remove data so that it's not used in an eventual retry

            delete s.data;
          } // Add or update anti-cache param if needed


          if (s.cache === false) {
            cacheURL = cacheURL.replace(rantiCache, "$1");
            uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached;
          } // Put hash and anti-cache on the URL that will be requested (gh-1732)


          s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)
        } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
          s.data = s.data.replace(r20, "+");
        } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.


        if (s.ifModified) {
          if (jQuery.lastModified[cacheURL]) {
            jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
          }

          if (jQuery.etag[cacheURL]) {
            jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
          }
        } // Set the correct header, if data is being sent


        if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
          jqXHR.setRequestHeader("Content-Type", s.contentType);
        } // Set the Accepts header for the server, depending on the dataType


        jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]); // Check for headers option

        for (i in s.headers) {
          jqXHR.setRequestHeader(i, s.headers[i]);
        } // Allow custom headers/mimetypes and early abort


        if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
          // Abort if not done already and return
          return jqXHR.abort();
        } // Aborting is no longer a cancellation


        strAbort = "abort"; // Install callbacks on deferreds

        completeDeferred.add(s.complete);
        jqXHR.done(s.success);
        jqXHR.fail(s.error); // Get transport

        transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort

        if (!transport) {
          done(-1, "No Transport");
        } else {
          jqXHR.readyState = 1; // Send global event

          if (fireGlobals) {
            globalEventContext.trigger("ajaxSend", [jqXHR, s]);
          } // If request was aborted inside ajaxSend, stop there


          if (completed) {
            return jqXHR;
          } // Timeout


          if (s.async && s.timeout > 0) {
            timeoutTimer = window.setTimeout(function () {
              jqXHR.abort("timeout");
            }, s.timeout);
          }

          try {
            completed = false;
            transport.send(requestHeaders, done);
          } catch (e) {
            // Rethrow post-completion exceptions
            if (completed) {
              throw e;
            } // Propagate others as results


            done(-1, e);
          }
        } // Callback for when everything is done


        function done(status, nativeStatusText, responses, headers) {
          var isSuccess,
              success,
              error,
              response,
              modified,
              statusText = nativeStatusText; // Ignore repeat invocations

          if (completed) {
            return;
          }

          completed = true; // Clear timeout if it exists

          if (timeoutTimer) {
            window.clearTimeout(timeoutTimer);
          } // Dereference transport for early garbage collection
          // (no matter how long the jqXHR object will be used)


          transport = undefined; // Cache response headers

          responseHeadersString = headers || ""; // Set readyState

          jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful

          isSuccess = status >= 200 && status < 300 || status === 304; // Get response data

          if (responses) {
            response = ajaxHandleResponses(s, jqXHR, responses);
          } // Convert no matter what (that way responseXXX fields are always set)


          response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining

          if (isSuccess) {
            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
              modified = jqXHR.getResponseHeader("Last-Modified");

              if (modified) {
                jQuery.lastModified[cacheURL] = modified;
              }

              modified = jqXHR.getResponseHeader("etag");

              if (modified) {
                jQuery.etag[cacheURL] = modified;
              }
            } // if no content


            if (status === 204 || s.type === "HEAD") {
              statusText = "nocontent"; // if not modified
            } else if (status === 304) {
              statusText = "notmodified"; // If we have data, let's convert it
            } else {
              statusText = response.state;
              success = response.data;
              error = response.error;
              isSuccess = !error;
            }
          } else {
            // Extract error from statusText and normalize for non-aborts
            error = statusText;

            if (status || !statusText) {
              statusText = "error";

              if (status < 0) {
                status = 0;
              }
            }
          } // Set data for the fake xhr object


          jqXHR.status = status;
          jqXHR.statusText = (nativeStatusText || statusText) + ""; // Success/Error

          if (isSuccess) {
            deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
          } else {
            deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
          } // Status-dependent callbacks


          jqXHR.statusCode(statusCode);
          statusCode = undefined;

          if (fireGlobals) {
            globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
          } // Complete


          completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

          if (fireGlobals) {
            globalEventContext.trigger("ajaxComplete", [jqXHR, s]); // Handle the global AJAX counter

            if (! --jQuery.active) {
              jQuery.event.trigger("ajaxStop");
            }
          }
        }

        return jqXHR;
      },
      getJSON: function (url, data, callback) {
        return jQuery.get(url, data, callback, "json");
      },
      getScript: function (url, callback) {
        return jQuery.get(url, undefined, callback, "script");
      }
    });
    jQuery.each(["get", "post"], function (i, method) {
      jQuery[method] = function (url, data, callback, type) {
        // Shift arguments if data argument was omitted
        if (jQuery.isFunction(data)) {
          type = type || callback;
          callback = data;
          data = undefined;
        } // The url can be an options object (which then must have .url)


        return jQuery.ajax(jQuery.extend({
          url: url,
          type: method,
          dataType: type,
          data: data,
          success: callback
        }, jQuery.isPlainObject(url) && url));
      };
    });

    jQuery._evalUrl = function (url) {
      return jQuery.ajax({
        url: url,
        // Make this explicit, since user can override this through ajaxSetup (#11264)
        type: "GET",
        dataType: "script",
        cache: true,
        async: false,
        global: false,
        "throws": true
      });
    };

    jQuery.fn.extend({
      wrapAll: function (html) {
        var wrap;

        if (this[0]) {
          if (jQuery.isFunction(html)) {
            html = html.call(this[0]);
          } // The elements to wrap the target around


          wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

          if (this[0].parentNode) {
            wrap.insertBefore(this[0]);
          }

          wrap.map(function () {
            var elem = this;

            while (elem.firstElementChild) {
              elem = elem.firstElementChild;
            }

            return elem;
          }).append(this);
        }

        return this;
      },
      wrapInner: function (html) {
        if (jQuery.isFunction(html)) {
          return this.each(function (i) {
            jQuery(this).wrapInner(html.call(this, i));
          });
        }

        return this.each(function () {
          var self = jQuery(this),
              contents = self.contents();

          if (contents.length) {
            contents.wrapAll(html);
          } else {
            self.append(html);
          }
        });
      },
      wrap: function (html) {
        var isFunction = jQuery.isFunction(html);
        return this.each(function (i) {
          jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
        });
      },
      unwrap: function (selector) {
        this.parent(selector).not("body").each(function () {
          jQuery(this).replaceWith(this.childNodes);
        });
        return this;
      }
    });

    jQuery.expr.pseudos.hidden = function (elem) {
      return !jQuery.expr.pseudos.visible(elem);
    };

    jQuery.expr.pseudos.visible = function (elem) {
      return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };

    jQuery.ajaxSettings.xhr = function () {
      try {
        return new window.XMLHttpRequest();
      } catch (e) {}
    };

    var xhrSuccessStatus = {
      // File protocol always yields status code 0, assume 200
      0: 200,
      // Support: IE <=9 only
      // #1450: sometimes IE returns 1223 when it should be 204
      1223: 204
    },
        xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function (options) {
      var callback, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest

      if (support.cors || xhrSupported && !options.crossDomain) {
        return {
          send: function (headers, complete) {
            var i,
                xhr = options.xhr();
            xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided

            if (options.xhrFields) {
              for (i in options.xhrFields) {
                xhr[i] = options.xhrFields[i];
              }
            } // Override mime type if needed


            if (options.mimeType && xhr.overrideMimeType) {
              xhr.overrideMimeType(options.mimeType);
            } // X-Requested-With header
            // For cross-domain requests, seeing as conditions for a preflight are
            // akin to a jigsaw puzzle, we simply never set it to be sure.
            // (it can always be set on a per-request basis or even using ajaxSetup)
            // For same-domain requests, won't change header if already provided.


            if (!options.crossDomain && !headers["X-Requested-With"]) {
              headers["X-Requested-With"] = "XMLHttpRequest";
            } // Set headers


            for (i in headers) {
              xhr.setRequestHeader(i, headers[i]);
            } // Callback


            callback = function (type) {
              return function () {
                if (callback) {
                  callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

                  if (type === "abort") {
                    xhr.abort();
                  } else if (type === "error") {
                    // Support: IE <=9 only
                    // On a manual native abort, IE9 throws
                    // errors on any property access that is not readyState
                    if (typeof xhr.status !== "number") {
                      complete(0, "error");
                    } else {
                      complete( // File: protocol always yields status 0; see #8605, #14207
                      xhr.status, xhr.statusText);
                    }
                  } else {
                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
                    // IE9 has no XHR2 but throws on binary (trac-11426)
                    // For XHR2 non-text, let the caller handle it (gh-2498)
                    (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                      binary: xhr.response
                    } : {
                      text: xhr.responseText
                    }, xhr.getAllResponseHeaders());
                  }
                }
              };
            }; // Listen to events


            xhr.onload = callback();
            errorCallback = xhr.onerror = callback("error"); // Support: IE 9 only
            // Use onreadystatechange to replace onabort
            // to handle uncaught aborts

            if (xhr.onabort !== undefined) {
              xhr.onabort = errorCallback;
            } else {
              xhr.onreadystatechange = function () {
                // Check readyState before timeout as it changes
                if (xhr.readyState === 4) {
                  // Allow onerror to be called first,
                  // but that will not handle a native abort
                  // Also, save errorCallback to a variable
                  // as xhr.onerror cannot be accessed
                  window.setTimeout(function () {
                    if (callback) {
                      errorCallback();
                    }
                  });
                }
              };
            } // Create the abort callback


            callback = callback("abort");

            try {
              // Do send the request (this may raise an exception)
              xhr.send(options.hasContent && options.data || null);
            } catch (e) {
              // #14683: Only rethrow if this hasn't been notified as an error yet
              if (callback) {
                throw e;
              }
            }
          },
          abort: function () {
            if (callback) {
              callback();
            }
          }
        };
      }
    }); // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)

    jQuery.ajaxPrefilter(function (s) {
      if (s.crossDomain) {
        s.contents.script = false;
      }
    }); // Install script dataType

    jQuery.ajaxSetup({
      accepts: {
        script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
      },
      contents: {
        script: /\b(?:java|ecma)script\b/
      },
      converters: {
        "text script": function (text) {
          jQuery.globalEval(text);
          return text;
        }
      }
    }); // Handle cache's special case and crossDomain

    jQuery.ajaxPrefilter("script", function (s) {
      if (s.cache === undefined) {
        s.cache = false;
      }

      if (s.crossDomain) {
        s.type = "GET";
      }
    }); // Bind script tag hack transport

    jQuery.ajaxTransport("script", function (s) {
      // This transport only deals with cross domain requests
      if (s.crossDomain) {
        var script, callback;
        return {
          send: function (_, complete) {
            script = jQuery("<script>").prop({
              charset: s.scriptCharset,
              src: s.url
            }).on("load error", callback = function (evt) {
              script.remove();
              callback = null;

              if (evt) {
                complete(evt.type === "error" ? 404 : 200, evt.type);
              }
            }); // Use native DOM manipulation to avoid our domManip AJAX trickery

            document.head.appendChild(script[0]);
          },
          abort: function () {
            if (callback) {
              callback();
            }
          }
        };
      }
    });
    var oldCallbacks = [],
        rjsonp = /(=)\?(?=&|$)|\?\?/; // Default jsonp settings

    jQuery.ajaxSetup({
      jsonp: "callback",
      jsonpCallback: function () {
        var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
        this[callback] = true;
        return callback;
      }
    }); // Detect, normalize options and install callbacks for jsonp requests

    jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
      var callbackName,
          overwritten,
          responseContainer,
          jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data"); // Handle iff the expected data type is "jsonp" or we have a parameter to set

      if (jsonProp || s.dataTypes[0] === "jsonp") {
        // Get callback name, remembering preexisting value associated with it
        callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data

        if (jsonProp) {
          s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
        } else if (s.jsonp !== false) {
          s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
        } // Use data converter to retrieve json after script execution


        s.converters["script json"] = function () {
          if (!responseContainer) {
            jQuery.error(callbackName + " was not called");
          }

          return responseContainer[0];
        }; // Force json dataType


        s.dataTypes[0] = "json"; // Install callback

        overwritten = window[callbackName];

        window[callbackName] = function () {
          responseContainer = arguments;
        }; // Clean-up function (fires after converters)


        jqXHR.always(function () {
          // If previous value didn't exist - remove it
          if (overwritten === undefined) {
            jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value
          } else {
            window[callbackName] = overwritten;
          } // Save back as free


          if (s[callbackName]) {
            // Make sure that re-using the options doesn't screw things around
            s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use

            oldCallbacks.push(callbackName);
          } // Call if it was a function and we have a response


          if (responseContainer && jQuery.isFunction(overwritten)) {
            overwritten(responseContainer[0]);
          }

          responseContainer = overwritten = undefined;
        }); // Delegate to script

        return "script";
      }
    }); // Support: Safari 8 only
    // In Safari 8 documents created via document.implementation.createHTMLDocument
    // collapse sibling forms: the second one becomes a child of the first one.
    // Because of that, this security measure has to be disabled in Safari 8.
    // https://bugs.webkit.org/show_bug.cgi?id=137337

    support.createHTMLDocument = function () {
      var body = document.implementation.createHTMLDocument("").body;
      body.innerHTML = "<form></form><form></form>";
      return body.childNodes.length === 2;
    }(); // Argument "data" should be string of html
    // context (optional): If specified, the fragment will be created in this context,
    // defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string


    jQuery.parseHTML = function (data, context, keepScripts) {
      if (typeof data !== "string") {
        return [];
      }

      if (typeof context === "boolean") {
        keepScripts = context;
        context = false;
      }

      var base, parsed, scripts;

      if (!context) {
        // Stop scripts or inline event handlers from being executed immediately
        // by using document.implementation
        if (support.createHTMLDocument) {
          context = document.implementation.createHTMLDocument(""); // Set the base href for the created document
          // so any parsed elements with URLs
          // are based on the document's URL (gh-2965)

          base = context.createElement("base");
          base.href = document.location.href;
          context.head.appendChild(base);
        } else {
          context = document;
        }
      }

      parsed = rsingleTag.exec(data);
      scripts = !keepScripts && []; // Single tag

      if (parsed) {
        return [context.createElement(parsed[1])];
      }

      parsed = buildFragment([data], context, scripts);

      if (scripts && scripts.length) {
        jQuery(scripts).remove();
      }

      return jQuery.merge([], parsed.childNodes);
    };
    /**
     * Load a url into a page
     */


    jQuery.fn.load = function (url, params, callback) {
      var selector,
          type,
          response,
          self = this,
          off = url.indexOf(" ");

      if (off > -1) {
        selector = stripAndCollapse(url.slice(off));
        url = url.slice(0, off);
      } // If it's a function


      if (jQuery.isFunction(params)) {
        // We assume that it's the callback
        callback = params;
        params = undefined; // Otherwise, build a param string
      } else if (params && typeof params === "object") {
        type = "POST";
      } // If we have elements to modify, make the request


      if (self.length > 0) {
        jQuery.ajax({
          url: url,
          // If "type" variable is undefined, then "GET" method will be used.
          // Make value of this field explicit since
          // user can override it through ajaxSetup method
          type: type || "GET",
          dataType: "html",
          data: params
        }).done(function (responseText) {
          // Save response for use in complete callback
          response = arguments;
          self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
          // Exclude scripts to avoid IE 'Permission Denied' errors
          jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
          responseText); // If the request succeeds, this function gets "data", "status", "jqXHR"
          // but they are ignored because response was set above.
          // If it fails, this function gets "jqXHR", "status", "error"
        }).always(callback && function (jqXHR, status) {
          self.each(function () {
            callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
          });
        });
      }

      return this;
    }; // Attach a bunch of functions for handling common AJAX events


    jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
      jQuery.fn[type] = function (fn) {
        return this.on(type, fn);
      };
    });

    jQuery.expr.pseudos.animated = function (elem) {
      return jQuery.grep(jQuery.timers, function (fn) {
        return elem === fn.elem;
      }).length;
    };
    /**
     * Gets a window from an element
     */


    function getWindow(elem) {
      return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }

    jQuery.offset = {
      setOffset: function (elem, options, i) {
        var curPosition,
            curLeft,
            curCSSTop,
            curTop,
            curOffset,
            curCSSLeft,
            calculatePosition,
            position = jQuery.css(elem, "position"),
            curElem = jQuery(elem),
            props = {}; // Set position first, in-case top/left are set even on static elem

        if (position === "static") {
          elem.style.position = "relative";
        }

        curOffset = curElem.offset();
        curCSSTop = jQuery.css(elem, "top");
        curCSSLeft = jQuery.css(elem, "left");
        calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1; // Need to be able to calculate position if either
        // top or left is auto and position is either absolute or fixed

        if (calculatePosition) {
          curPosition = curElem.position();
          curTop = curPosition.top;
          curLeft = curPosition.left;
        } else {
          curTop = parseFloat(curCSSTop) || 0;
          curLeft = parseFloat(curCSSLeft) || 0;
        }

        if (jQuery.isFunction(options)) {
          // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
          options = options.call(elem, i, jQuery.extend({}, curOffset));
        }

        if (options.top != null) {
          props.top = options.top - curOffset.top + curTop;
        }

        if (options.left != null) {
          props.left = options.left - curOffset.left + curLeft;
        }

        if ("using" in options) {
          options.using.call(elem, props);
        } else {
          curElem.css(props);
        }
      }
    };
    jQuery.fn.extend({
      offset: function (options) {
        // Preserve chaining for setter
        if (arguments.length) {
          return options === undefined ? this : this.each(function (i) {
            jQuery.offset.setOffset(this, options, i);
          });
        }

        var docElem,
            win,
            rect,
            doc,
            elem = this[0];

        if (!elem) {
          return;
        } // Support: IE <=11 only
        // Running getBoundingClientRect on a
        // disconnected node in IE throws an error


        if (!elem.getClientRects().length) {
          return {
            top: 0,
            left: 0
          };
        }

        rect = elem.getBoundingClientRect(); // Make sure element is not hidden (display: none)

        if (rect.width || rect.height) {
          doc = elem.ownerDocument;
          win = getWindow(doc);
          docElem = doc.documentElement;
          return {
            top: rect.top + win.pageYOffset - docElem.clientTop,
            left: rect.left + win.pageXOffset - docElem.clientLeft
          };
        } // Return zeros for disconnected and hidden elements (gh-2310)


        return rect;
      },
      position: function () {
        if (!this[0]) {
          return;
        }

        var offsetParent,
            offset,
            elem = this[0],
            parentOffset = {
          top: 0,
          left: 0
        }; // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
        // because it is its only offset parent

        if (jQuery.css(elem, "position") === "fixed") {
          // Assume getBoundingClientRect is there when computed position is fixed
          offset = elem.getBoundingClientRect();
        } else {
          // Get *real* offsetParent
          offsetParent = this.offsetParent(); // Get correct offsets

          offset = this.offset();

          if (!jQuery.nodeName(offsetParent[0], "html")) {
            parentOffset = offsetParent.offset();
          } // Add offsetParent borders


          parentOffset = {
            top: parentOffset.top + jQuery.css(offsetParent[0], "borderTopWidth", true),
            left: parentOffset.left + jQuery.css(offsetParent[0], "borderLeftWidth", true)
          };
        } // Subtract parent offsets and element margins


        return {
          top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
          left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
        };
      },
      // This method will return documentElement in the following cases:
      // 1) For the element inside the iframe without offsetParent, this method will return
      //    documentElement of the parent window
      // 2) For the hidden or detached element
      // 3) For body or html element, i.e. in case of the html node - it will return itself
      //
      // but those exceptions were never presented as a real life use-cases
      // and might be considered as more preferable results.
      //
      // This logic, however, is not guaranteed and can change at any point in the future
      offsetParent: function () {
        return this.map(function () {
          var offsetParent = this.offsetParent;

          while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.offsetParent;
          }

          return offsetParent || documentElement;
        });
      }
    }); // Create scrollLeft and scrollTop methods

    jQuery.each({
      scrollLeft: "pageXOffset",
      scrollTop: "pageYOffset"
    }, function (method, prop) {
      var top = "pageYOffset" === prop;

      jQuery.fn[method] = function (val) {
        return access(this, function (elem, method, val) {
          var win = getWindow(elem);

          if (val === undefined) {
            return win ? win[prop] : elem[method];
          }

          if (win) {
            win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
          } else {
            elem[method] = val;
          }
        }, method, val, arguments.length);
      };
    }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49
    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
    // getComputedStyle returns percent when specified for top/left/bottom/right;
    // rather than make the css module depend on the offset module, just check for it here

    jQuery.each(["top", "left"], function (i, prop) {
      jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
        if (computed) {
          computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset

          return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
        }
      });
    }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods

    jQuery.each({
      Height: "height",
      Width: "width"
    }, function (name, type) {
      jQuery.each({
        padding: "inner" + name,
        content: type,
        "": "outer" + name
      }, function (defaultExtra, funcName) {
        // Margin is only for outerHeight, outerWidth
        jQuery.fn[funcName] = function (margin, value) {
          var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
              extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
          return access(this, function (elem, type, value) {
            var doc;

            if (jQuery.isWindow(elem)) {
              // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
              return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
            } // Get document width or height


            if (elem.nodeType === 9) {
              doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
              // whichever is greatest

              return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
            }

            return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
            jQuery.css(elem, type, extra) : // Set width or height on the element
            jQuery.style(elem, type, value, extra);
          }, type, chainable ? margin : undefined, chainable);
        };
      });
    });
    jQuery.fn.extend({
      bind: function (types, data, fn) {
        return this.on(types, null, data, fn);
      },
      unbind: function (types, fn) {
        return this.off(types, null, fn);
      },
      delegate: function (selector, types, data, fn) {
        return this.on(types, selector, data, fn);
      },
      undelegate: function (selector, types, fn) {
        // ( namespace ) or ( selector, types [, fn] )
        return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
      }
    });
    jQuery.parseJSON = JSON.parse; // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.
    // Note that for maximum portability, libraries that are not jQuery should
    // declare themselves as anonymous modules, and avoid setting a global if an
    // AMD loader is present. jQuery is a special case. For more information, see
    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

    if (typeof define === "function" && define.amd) {
      define("jquery", [], function () {
        return jQuery;
      });
    }

    var // Map over jQuery in case of overwrite
    _jQuery = window.jQuery,
        // Map over the $ in case of overwrite
    _$ = window.$;

    jQuery.noConflict = function (deep) {
      if (window.$ === jQuery) {
        window.$ = _$;
      }

      if (deep && window.jQuery === jQuery) {
        window.jQuery = _jQuery;
      }

      return jQuery;
    }; // Expose jQuery and $ identifiers, even in AMD
    // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (#13566)


    if (!noGlobal) {
      window.jQuery = window.$ = jQuery;
    }

    return jQuery;
  });

  /*! jQuery Migrate v3.0.0 | (c) jQuery Foundation and other contributors | jquery.org/license */
  "undefined" == typeof jQuery.migrateMute && (jQuery.migrateMute = !0), function (a, b) {

    function c(c) {
      var d = b.console;
      e[c] || (e[c] = !0, a.migrateWarnings.push(c), d && d.warn && !a.migrateMute && (d.warn("JQMIGRATE: " + c), a.migrateTrace && d.trace && d.trace()));
    }

    function d(a, b, d, e) {
      Object.defineProperty(a, b, {
        configurable: !0,
        enumerable: !0,
        get: function () {
          return c(e), d;
        }
      });
    }

    a.migrateVersion = "3.0.0", function () {
      var c = b.console && b.console.log && function () {
        b.console.log.apply(b.console, arguments);
      },
          d = /^[12]\./;

      c && (a && !d.test(a.fn.jquery) || c("JQMIGRATE: jQuery 3.0.0+ REQUIRED"), a.migrateWarnings && c("JQMIGRATE: Migrate plugin loaded multiple times"), c("JQMIGRATE: Migrate is installed" + (a.migrateMute ? "" : " with logging active") + ", version " + a.migrateVersion));
    }();
    var e = {};
    a.migrateWarnings = [], void 0 === a.migrateTrace && (a.migrateTrace = !0), a.migrateReset = function () {
      e = {}, a.migrateWarnings.length = 0;
    }, "BackCompat" === document.compatMode && c("jQuery is not compatible with Quirks Mode");
    var f = a.fn.init,
        g = a.isNumeric,
        h = a.find,
        i = /\[(\s*[-\w]+\s*)([~|^$*]?=)\s*([-\w#]*?#[-\w#]*)\s*\]/,
        j = /\[(\s*[-\w]+\s*)([~|^$*]?=)\s*([-\w#]*?#[-\w#]*)\s*\]/g;
    a.fn.init = function (a) {
      var b = Array.prototype.slice.call(arguments);
      return "string" == typeof a && "#" === a && (c("jQuery( '#' ) is not a valid selector"), b[0] = []), f.apply(this, b);
    }, a.fn.init.prototype = a.fn, a.find = function (a) {
      var b = Array.prototype.slice.call(arguments);
      if ("string" == typeof a && i.test(a)) try {
        document.querySelector(a);
      } catch (d) {
        a = a.replace(j, function (a, b, c, d) {
          return "[" + b + c + '"' + d + '"]';
        });

        try {
          document.querySelector(a), c("Attribute selector with '#' must be quoted: " + b[0]), b[0] = a;
        } catch (e) {
          c("Attribute selector with '#' was not fixed: " + b[0]);
        }
      }
      return h.apply(this, b);
    };
    var k;

    for (k in h) Object.prototype.hasOwnProperty.call(h, k) && (a.find[k] = h[k]);

    a.fn.size = function () {
      return c("jQuery.fn.size() is deprecated; use the .length property"), this.length;
    }, a.parseJSON = function () {
      return c("jQuery.parseJSON is deprecated; use JSON.parse"), JSON.parse.apply(null, arguments);
    }, a.isNumeric = function (b) {
      function d(b) {
        var c = b && b.toString();
        return !a.isArray(b) && c - parseFloat(c) + 1 >= 0;
      }

      var e = g(b),
          f = d(b);
      return e !== f && c("jQuery.isNumeric() should not be called on constructed objects"), f;
    }, d(a, "unique", a.uniqueSort, "jQuery.unique is deprecated, use jQuery.uniqueSort"), d(a.expr, "filters", a.expr.pseudos, "jQuery.expr.filters is now jQuery.expr.pseudos"), d(a.expr, ":", a.expr.pseudos, 'jQuery.expr[":"] is now jQuery.expr.pseudos');
    var l = a.ajax;

    a.ajax = function () {
      var a = l.apply(this, arguments);
      return a.promise && (d(a, "success", a.done, "jQXHR.success is deprecated and removed"), d(a, "error", a.fail, "jQXHR.error is deprecated and removed"), d(a, "complete", a.always, "jQXHR.complete is deprecated and removed")), a;
    };

    var m = a.fn.removeAttr,
        n = a.fn.toggleClass,
        o = /\S+/g;
    a.fn.removeAttr = function (b) {
      var d = this;
      return a.each(b.match(o), function (b, e) {
        a.expr.match.bool.test(e) && (c("jQuery.fn.removeAttr no longer sets boolean properties: " + e), d.prop(e, !1));
      }), m.apply(this, arguments);
    }, a.fn.toggleClass = function (b) {
      return void 0 !== b && "boolean" != typeof b ? n.apply(this, arguments) : (c("jQuery.fn.toggleClass( boolean ) is deprecated"), this.each(function () {
        var c = this.getAttribute && this.getAttribute("class") || "";
        c && a.data(this, "__className__", c), this.setAttribute && this.setAttribute("class", c || b === !1 ? "" : a.data(this, "__className__") || "");
      }));
    };
    var p = !1;
    a.swap && a.each(["height", "width", "reliableMarginRight"], function (b, c) {
      var d = a.cssHooks[c] && a.cssHooks[c].get;
      d && (a.cssHooks[c].get = function () {
        var a;
        return p = !0, a = d.apply(this, arguments), p = !1, a;
      });
    }), a.swap = function (a, b, d, e) {
      var f,
          g,
          h = {};
      p || c("jQuery.swap() is undocumented and deprecated");

      for (g in b) h[g] = a.style[g], a.style[g] = b[g];

      f = d.apply(a, e || []);

      for (g in b) a.style[g] = h[g];

      return f;
    };
    var q = a.data;

    a.data = function (b, d, e) {
      var f;
      return d && d !== a.camelCase(d) && (f = a.hasData(b) && q.call(this, b), f && d in f) ? (c("jQuery.data() always sets/gets camelCased names: " + d), arguments.length > 2 && (f[d] = e), f[d]) : q.apply(this, arguments);
    };

    var r = a.Tween.prototype.run;

    a.Tween.prototype.run = function (b) {
      a.easing[this.easing].length > 1 && (c('easing function "jQuery.easing.' + this.easing.toString() + '" should use only first argument'), a.easing[this.easing] = a.easing[this.easing].bind(a.easing, b, this.options.duration * b, 0, 1, this.options.duration)), r.apply(this, arguments);
    };

    var s = a.fn.load,
        t = a.event.fix;
    a.event.props = [], a.event.fixHooks = {}, a.event.fix = function (b) {
      var d,
          e = b.type,
          f = this.fixHooks[e],
          g = a.event.props;
      if (g.length) for (c("jQuery.event.props are deprecated and removed: " + g.join()); g.length;) a.event.addProp(g.pop());
      if (f && !f._migrated_ && (f._migrated_ = !0, c("jQuery.event.fixHooks are deprecated and removed: " + e), (g = f.props) && g.length)) for (; g.length;) a.event.addProp(g.pop());
      return d = t.call(this, b), f && f.filter ? f.filter(d, b) : d;
    }, a.each(["load", "unload", "error"], function (b, d) {
      a.fn[d] = function () {
        var a = Array.prototype.slice.call(arguments, 0);
        return "load" === d && "string" == typeof a[0] ? s.apply(this, a) : (c("jQuery.fn." + d + "() is deprecated"), a.splice(0, 0, d), arguments.length ? this.on.apply(this, a) : (this.triggerHandler.apply(this, a), this));
      };
    }), a(function () {
      a(document).triggerHandler("ready");
    }), a.event.special.ready = {
      setup: function () {
        this === document && c("'ready' event is deprecated");
      }
    }, a.fn.extend({
      bind: function (a, b, d) {
        return c("jQuery.fn.bind() is deprecated"), this.on(a, null, b, d);
      },
      unbind: function (a, b) {
        return c("jQuery.fn.unbind() is deprecated"), this.off(a, null, b);
      },
      delegate: function (a, b, d, e) {
        return c("jQuery.fn.delegate() is deprecated"), this.on(b, a, d, e);
      },
      undelegate: function (a, b, d) {
        return c("jQuery.fn.undelegate() is deprecated"), 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", d);
      }
    });
    var u = a.fn.offset;

    a.fn.offset = function () {
      var b,
          d = this[0],
          e = {
        top: 0,
        left: 0
      };
      return d && d.nodeType ? (b = (d.ownerDocument || document).documentElement, a.contains(b, d) ? u.apply(this, arguments) : (c("jQuery.fn.offset() requires an element connected to a document"), e)) : (c("jQuery.fn.offset() requires a valid DOM element"), e);
    };

    var v = a.param;

    a.param = function (b, d) {
      var e = a.ajaxSettings && a.ajaxSettings.traditional;
      return void 0 === d && e && (c("jQuery.param() no longer uses jQuery.ajaxSettings.traditional"), d = e), v.call(this, b, d);
    };

    var w = a.fn.andSelf || a.fn.addBack;

    a.fn.andSelf = function () {
      return c("jQuery.fn.andSelf() replaced by jQuery.fn.addBack()"), w.apply(this, arguments);
    };

    var x = a.Deferred,
        y = [["resolve", "done", a.Callbacks("once memory"), a.Callbacks("once memory"), "resolved"], ["reject", "fail", a.Callbacks("once memory"), a.Callbacks("once memory"), "rejected"], ["notify", "progress", a.Callbacks("memory"), a.Callbacks("memory")]];

    a.Deferred = function (b) {
      var d = x(),
          e = d.promise();
      return d.pipe = e.pipe = function () {
        var b = arguments;
        return c("deferred.pipe() is deprecated"), a.Deferred(function (c) {
          a.each(y, function (f, g) {
            var h = a.isFunction(b[f]) && b[f];
            d[g[1]](function () {
              var b = h && h.apply(this, arguments);
              b && a.isFunction(b.promise) ? b.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[g[0] + "With"](this === e ? c.promise() : this, h ? [b] : arguments);
            });
          }), b = null;
        }).promise();
      }, b && b.call(d, d), d;
    };
  }(jQuery, window);

  (function (UX) {
    /**
     * UX Namespace for tests
     * @namespace
     * @type {*|{}}
     */
    UX.test = UX.test || {};
    /**
     * Test browser support for input[type=date]
     * @returns {boolean}
     */

    UX.test.inputDate = function () {
      // test for input|type=date support
      // it could be better, when tests are separated and used globally - Modernizr test for this issue is much more sofisticated for example
      var hasDateInputSupport = false;

      function checkInput(type) {
        var input = document.createElement("input");
        input.setAttribute("type", type);
        return input.type === type;
      }

      function checkDateInput() {
        var input = document.createElement('input');
        input.setAttribute('type', 'date');
        var notADateValue = 'not-a-date';
        input.setAttribute('value', notADateValue);
        return input.value !== notADateValue;
      }

      if (checkInput('date') && checkDateInput()) {
        hasDateInputSupport = true;
      }

      return hasDateInputSupport;
    };
    /**
     * detect IE
     * returns version of IE or false, if browser is not Internet Explorer
     */


    UX.test.isIE = function isIE() {
      var ua = window.navigator.userAgent;
      var msie = ua.indexOf('MSIE ');

      if (msie > 0) {
        // IE 10 or older => return version number
        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
      }

      var trident = ua.indexOf('Trident/');

      if (trident > 0) {
        // IE 11 => return version number
        var rv = ua.indexOf('rv:');
        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
      }

      var edge = ua.indexOf('Edge/');

      if (edge > 0) {
        // Edge (IE 12+) => return version number
        return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
      } // other browser


      return false;
    };
  })(UX);

  const isIE = UX.test.isIE();

  /**
   * Polyfill to add support to NodeList forEach in IE
   *
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach#Polyfill}
   */
  if (window.NodeList && !NodeList.prototype.forEach) {
    NodeList.prototype.forEach = Array.prototype.forEach;
  }

  (function (UX) {
    /**
     * UX namespace for basic utils
     * @namespace
     * @type {*|{}}
     */
    UX.utils = UX.utils || {};
    /**
     * Generate unique ID suffix
     * @returns {string}
     */

    UX.utils.generateId = function () {
      // Math.random should be unique because of its seeding algorithm.
      // Convert it to base 36 (numbers + letters), and grab the first 9 characters
      // after the decimal.
      return '_' + Math.random().toString(36).substr(2, 9);
    };
    /**
     * Capitalize first letter
     * @param {string} string
     * @returns {string}
     */


    UX.utils.capitalizeFirstLetter = function (string) {
      if (typeof string == "string") {
        return string.charAt(0).toUpperCase() + string.slice(1);
      } else {
        return "";
      }
    };

    UX.utils.fixedHeaderHeight = function (selector) {
      if (!selector) selector = '.header';
      const fixedHeader = document.querySelector(selector);
      if (!fixedHeader) return 0;

      if (fixedHeader.querySelector('.scrollThenFix')) {
        return fixedHeader.querySelector('.scrollThenFix').getBoundingClientRect().height;
      }

      if (fixedHeader.classList.contains('auto-hide-bar') || fixedHeader.querySelectorAll('.auto-hide-bar').length) {
        const fixedHeaderElements = fixedHeader.querySelectorAll('.fixed-element');
        let height = 0;
        fixedHeaderElements.forEach(element => {
          height += element.getBoundingClientRect().height;
        });
        return height;
      }

      const parentsOfHeader = fixedHeader.parentElement;
      let isFixed;

      if (isIE) {
        isFixed = fixedHeader.classList.contains('fixed') || parentsOfHeader.classList.contains('fixed');
      } else {
        const headerPositions = {
          'header': window.getComputedStyle(fixedHeader).position,
          'parents': window.getComputedStyle(parentsOfHeader).position
        };
        isFixed = ['fixed', 'sticky'].indexOf(headerPositions.header) !== -1 || ['fixed', 'sticky'].indexOf(headerPositions.parents) !== -1;
      }

      return isFixed ? fixedHeader.getBoundingClientRect().height : 0;
    };
  })(UX);

  UX.utils;
  const {
    generateId,
    capitalizeFirstLetter,
    fixedHeaderHeight
  } = UX.utils;

  (function ($) {
    // Focusable pseoudo selector
    $.extend($.expr[':'], {
      focusable: function (el, index, selector) {
        var $el = $(el);
        return $el.is('button, [href], input, select, textarea, object, [tabindex]:not([tabindex="-1"])') // we don't need to check "area" tag, while it is focusable only when it has href attr
        && $el.is(':not(:disabled)') // disabled elements are not focusable
        && $el.is(':visible');
      }
    }); // Tabbable pseudo selector

    $.extend($.expr[':'], {
      tabbable: function (el, index, selector) {
        var $el = $(el);
        return $el.is(':focusable') && $el.is(':not([tabindex="-1"])');
      }
    });
  })(jQuery);

  /*!
   * JavaScript Custom Forms
   *
   * Copyright 2014-2015 PSD2HTML - http://psd2html.com/jcf
   * Released under the MIT license (LICENSE.txt)
   *
   * Version: 1.2.3
   */

  (function (root, factory) {
    /*if (typeof define === 'function' && define.amd) {
    	define(['jquery'], factory);
    } else if (typeof exports === 'object') {
    	module.exports = factory(require('jquery'));
    } else {
    	root.jcf = factory(jQuery);
    }*/

    root.jcf = factory(jQuery);
  })(window, function ($) {

    var version = '1.2.3'; // private variables

    var customInstances = []; // default global options

    var commonOptions = {
      optionsKey: 'jcf',
      dataKey: 'jcf-instance',
      rtlClass: 'jcf-rtl',
      focusClass: 'jcf-focus',
      pressedClass: 'jcf-pressed',
      disabledClass: 'jcf-disabled',
      hiddenClass: 'jcf-hidden',
      resetAppearanceClass: 'jcf-reset-appearance',
      unselectableClass: 'jcf-unselectable'
    }; // detect device type

    var isTouchDevice = 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch,
        isWinPhoneDevice = /Windows Phone/.test(navigator.userAgent);
    commonOptions.isMobileDevice = !!(isTouchDevice || isWinPhoneDevice); // create global stylesheet if custom forms are used

    var createStyleSheet = function () {
      var styleTag = $('<style>').appendTo('head'),
          styleSheet = styleTag.prop('sheet') || styleTag.prop('styleSheet'); // crossbrowser style handling

      var addCSSRule = function (selector, rules, index) {
        index = index || 0;

        if (styleSheet.insertRule) {
          styleSheet.insertRule(selector + '{' + rules + '}', index);
        } else {
          styleSheet.addRule(selector, rules, index);
        }
      }; // add special rules


      addCSSRule('.' + commonOptions.hiddenClass, 'position:absolute !important;left:-9999px !important;height:1px !important;width:1px !important;margin:0 !important;border-width:0 !important;-webkit-appearance:none;-moz-appearance:none;appearance:none');
      addCSSRule('.' + commonOptions.rtlClass + ' .' + commonOptions.hiddenClass, 'right:-9999px !important; left: auto !important');
      addCSSRule('.' + commonOptions.unselectableClass, '-webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-tap-highlight-color: rgba(0,0,0,0);');
      addCSSRule('.' + commonOptions.resetAppearanceClass, 'background: none; border: none; -webkit-appearance: none; appearance: none; opacity: 0; filter: alpha(opacity=0);'); // detect rtl pages

      var html = $('html'),
          body = $('body');

      if (html.css('direction') === 'rtl' || body.css('direction') === 'rtl') {
        html.addClass(commonOptions.rtlClass);
      } // handle form reset event


      html.on('reset', function () {
        setTimeout(function () {
          api.refreshAll();
        }, 0);
      }); // mark stylesheet as created

      commonOptions.styleSheetCreated = true;
    }; // simplified pointer events handler


    (function () {
      var pointerEventsSupported = navigator.pointerEnabled || navigator.msPointerEnabled,
          touchEventsSupported = 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch,
          eventList,
          eventMap = {},
          eventPrefix = 'jcf-'; // detect events to attach

      if (pointerEventsSupported) {
        eventList = {
          pointerover: navigator.pointerEnabled ? 'pointerover' : 'MSPointerOver',
          pointerdown: navigator.pointerEnabled ? 'pointerdown' : 'MSPointerDown',
          pointermove: navigator.pointerEnabled ? 'pointermove' : 'MSPointerMove',
          pointerup: navigator.pointerEnabled ? 'pointerup' : 'MSPointerUp'
        };
      } else {
        eventList = {
          pointerover: 'mouseover',
          pointerdown: 'mousedown' + (touchEventsSupported ? ' touchstart' : ''),
          pointermove: 'mousemove' + (touchEventsSupported ? ' touchmove' : ''),
          pointerup: 'mouseup' + (touchEventsSupported ? ' touchend' : '')
        };
      } // create event map


      $.each(eventList, function (targetEventName, fakeEventList) {
        $.each(fakeEventList.split(' '), function (index, fakeEventName) {
          eventMap[fakeEventName] = targetEventName;
        });
      }); // jQuery event hooks

      $.each(eventList, function (eventName, eventHandlers) {
        eventHandlers = eventHandlers.split(' ');
        $.event.special[eventPrefix + eventName] = {
          setup: function () {
            var self = this;
            $.each(eventHandlers, function (index, fallbackEvent) {
              if (self.addEventListener) self.addEventListener(fallbackEvent, fixEvent, false);else self['on' + fallbackEvent] = fixEvent;
            });
          },
          teardown: function () {
            var self = this;
            $.each(eventHandlers, function (index, fallbackEvent) {
              if (self.addEventListener) self.removeEventListener(fallbackEvent, fixEvent, false);else self['on' + fallbackEvent] = null;
            });
          }
        };
      }); // check that mouse event are not simulated by mobile browsers

      var lastTouch = null;

      var mouseEventSimulated = function (e) {
        var dx = Math.abs(e.pageX - lastTouch.x),
            dy = Math.abs(e.pageY - lastTouch.y),
            rangeDistance = 25;

        if (dx <= rangeDistance && dy <= rangeDistance) {
          return true;
        }
      }; // normalize event


      var fixEvent = function (e) {
        var origEvent = e || window.event,
            touchEventData = null,
            targetEventName = eventMap[origEvent.type];
        e = $.event.fix(origEvent);
        e.type = eventPrefix + targetEventName;

        if (origEvent.pointerType) {
          switch (origEvent.pointerType) {
            case 2:
              e.pointerType = 'touch';
              break;

            case 3:
              e.pointerType = 'pen';
              break;

            case 4:
              e.pointerType = 'mouse';
              break;

            default:
              e.pointerType = origEvent.pointerType;
          }
        } else {
          e.pointerType = origEvent.type.substr(0, 5); // "mouse" or "touch" word length
        }

        if (!e.pageX && !e.pageY) {
          touchEventData = origEvent.changedTouches ? origEvent.changedTouches[0] : origEvent;
          e.pageX = touchEventData.pageX;
          e.pageY = touchEventData.pageY;
        }

        if (origEvent.type === 'touchend') {
          lastTouch = {
            x: e.pageX,
            y: e.pageY
          };
        }

        if (e.pointerType === 'mouse' && lastTouch && mouseEventSimulated(e)) {
          return;
        } else {
          return ($.event.dispatch || $.event.handle).call(this, e);
        }
      };
    })(); // custom mousewheel/trackpad handler


    (function () {
      var wheelEvents = ('onwheel' in document || document.documentMode >= 9 ? 'wheel' : 'mousewheel DOMMouseScroll').split(' '),
          shimEventName = 'jcf-mousewheel';
      $.event.special[shimEventName] = {
        setup: function () {
          var self = this;
          $.each(wheelEvents, function (index, fallbackEvent) {
            if (self.addEventListener) self.addEventListener(fallbackEvent, fixEvent, false);else self['on' + fallbackEvent] = fixEvent;
          });
        },
        teardown: function () {
          var self = this;
          $.each(wheelEvents, function (index, fallbackEvent) {
            if (self.addEventListener) self.removeEventListener(fallbackEvent, fixEvent, false);else self['on' + fallbackEvent] = null;
          });
        }
      };

      var fixEvent = function (e) {
        var origEvent = e || window.event;
        e = $.event.fix(origEvent);
        e.type = shimEventName; // old wheel events handler

        if ('detail' in origEvent) {
          e.deltaY = -origEvent.detail;
        }

        if ('wheelDelta' in origEvent) {
          e.deltaY = -origEvent.wheelDelta;
        }

        if ('wheelDeltaY' in origEvent) {
          e.deltaY = -origEvent.wheelDeltaY;
        }

        if ('wheelDeltaX' in origEvent) {
          e.deltaX = -origEvent.wheelDeltaX;
        } // modern wheel event handler


        if ('deltaY' in origEvent) {
          e.deltaY = origEvent.deltaY;
        }

        if ('deltaX' in origEvent) {
          e.deltaX = origEvent.deltaX;
        } // handle deltaMode for mouse wheel


        e.delta = e.deltaY || e.deltaX;

        if (origEvent.deltaMode === 1) {
          var lineHeight = 16;
          e.delta *= lineHeight;
          e.deltaY *= lineHeight;
          e.deltaX *= lineHeight;
        }

        return ($.event.dispatch || $.event.handle).call(this, e);
      };
    })(); // extra module methods


    var moduleMixin = {
      // provide function for firing native events
      fireNativeEvent: function (elements, eventName) {
        $(elements).each(function () {
          var element = this,
              eventObject;

          if (element.dispatchEvent) {
            eventObject = document.createEvent('HTMLEvents');
            eventObject.initEvent(eventName, true, true);
            element.dispatchEvent(eventObject);
          } else if (document.createEventObject) {
            eventObject = document.createEventObject();
            eventObject.target = element;
            element.fireEvent('on' + eventName, eventObject);
          }
        });
      },
      // bind event handlers for module instance (functions beggining with "on")
      bindHandlers: function () {
        var self = this;
        $.each(self, function (propName, propValue) {
          if (propName.indexOf('on') === 0 && $.isFunction(propValue)) {
            // dont use $.proxy here because it doesn't create unique handler
            self[propName] = function () {
              return propValue.apply(self, arguments);
            };
          }
        });
      }
    }; // public API

    var api = {
      version: version,
      modules: {},
      getOptions: function () {
        return $.extend({}, commonOptions);
      },
      setOptions: function (moduleName, moduleOptions) {
        if (arguments.length > 1) {
          // set module options
          if (this.modules[moduleName]) {
            $.extend(this.modules[moduleName].prototype.options, moduleOptions);
          }
        } else {
          // set common options
          $.extend(commonOptions, moduleName);
        }
      },
      addModule: function (proto) {
        // proto is factory function
        if ($.isFunction(proto)) {
          proto = proto($, window);
        } // add module to list


        var Module = function (options) {
          // save instance to collection
          if (!options.element.data(commonOptions.dataKey)) {
            options.element.data(commonOptions.dataKey, this);
          }

          customInstances.push(this); // save options

          this.options = $.extend({}, commonOptions, this.options, getInlineOptions(options.element), options); // bind event handlers to instance

          this.bindHandlers(); // call constructor

          this.init.apply(this, arguments);
        }; // parse options from HTML attribute


        var getInlineOptions = function (element) {
          var dataOptions = element.data(commonOptions.optionsKey),
              attrOptions = element.attr(commonOptions.optionsKey);

          if (dataOptions) {
            return dataOptions;
          } else if (attrOptions) {
            try {
              return $.parseJSON(attrOptions);
            } catch (e) {// ignore invalid attributes
            }
          }
        }; // set proto as prototype for new module


        Module.prototype = proto; // add mixin methods to module proto

        $.extend(proto, moduleMixin);

        if (proto.plugins) {
          $.each(proto.plugins, function (pluginName, plugin) {
            $.extend(plugin.prototype, moduleMixin);
          });
        } // override destroy method


        var originalDestroy = Module.prototype.destroy;

        Module.prototype.destroy = function () {
          this.options.element.removeData(this.options.dataKey);

          for (var i = customInstances.length - 1; i >= 0; i--) {
            if (customInstances[i] === this) {
              customInstances.splice(i, 1);
              break;
            }
          }

          if (originalDestroy) {
            originalDestroy.apply(this, arguments);
          }
        }; // save module to list


        this.modules[proto.name] = Module;
      },
      getInstance: function (element) {
        return $(element).data(commonOptions.dataKey);
      },
      replace: function (elements, moduleName, customOptions) {
        var self = this,
            instance;

        if (!commonOptions.styleSheetCreated) {
          createStyleSheet();
        }

        $(elements).each(function () {
          var moduleOptions,
              element = $(this);
          instance = element.data(commonOptions.dataKey);

          if (instance) {
            instance.refresh();
          } else {
            if (!moduleName) {
              $.each(self.modules, function (currentModuleName, module) {
                if (module.prototype.matchElement.call(module.prototype, element)) {
                  moduleName = currentModuleName;
                  return false;
                }
              });
            }

            if (moduleName) {
              moduleOptions = $.extend({
                element: element
              }, customOptions);
              instance = new self.modules[moduleName](moduleOptions);
            }
          }
        });
        return instance;
      },
      refresh: function (elements) {
        $(elements).each(function () {
          var instance = $(this).data(commonOptions.dataKey);

          if (instance) {
            instance.refresh();
          }
        });
      },
      destroy: function (elements) {
        $(elements).each(function () {
          var instance = $(this).data(commonOptions.dataKey);

          if (instance) {
            instance.destroy();
          }
        });
      },
      replaceAll: function (context) {
        var self = this;
        $.each(this.modules, function (moduleName, module) {
          $(module.prototype.selector, context).each(function () {
            if (this.className.indexOf('jcf-ignore') < 0) {
              self.replace(this, moduleName);
            }
          });
        });
      },
      refreshAll: function (context) {
        if (context) {
          $.each(this.modules, function (moduleName, module) {
            $(module.prototype.selector, context).each(function () {
              var instance = $(this).data(commonOptions.dataKey);

              if (instance) {
                instance.refresh();
              }
            });
          });
        } else {
          for (var i = customInstances.length - 1; i >= 0; i--) {
            customInstances[i].refresh();
          }
        }
      },
      destroyAll: function (context) {
        if (context) {
          $.each(this.modules, function (moduleName, module) {
            $(module.prototype.selector, context).each(function (index, element) {
              var instance = $(element).data(commonOptions.dataKey);

              if (instance) {
                instance.destroy();
              }
            });
          });
        } else {
          while (customInstances.length) {
            customInstances[0].destroy();
          }
        }
      }
    }; // we need to make JCF available globally if we're in AMD environment

    if (typeof define === 'function' && define.amd) {
      window.jcf = api;
    }

    return api;
  });

  /*!
   * JavaScript Custom Forms : Select Module
   *
   * Copyright 2014-2015 PSD2HTML - http://psd2html.com/jcf
   * Released under the MIT license (LICENSE.txt)
   *
   * Version: 1.2.3
   */
  (function (jcf) {
    jcf.addModule(function ($, window) {

      var module = {
        name: 'Select',
        selector: 'select',
        options: {
          element: null,
          multipleCompactStyle: false
        },
        plugins: {
          ListBox: ListBox,
          ComboBox: ComboBox,
          SelectList: SelectList
        },
        matchElement: function (element) {
          return element.is('select');
        },
        init: function () {
          this.element = $(this.options.element);
          this.createInstance();
        },
        isListBox: function () {
          return this.element.is('[size]:not([jcf-size]), [multiple]');
        },
        createInstance: function () {
          if (this.instance) {
            this.instance.destroy();
          }

          if (this.isListBox() && !this.options.multipleCompactStyle) {
            this.instance = new ListBox(this.options);
          } else {
            this.instance = new ComboBox(this.options);
          }
        },
        refresh: function () {
          var typeMismatch = this.isListBox() && this.instance instanceof ComboBox || !this.isListBox() && this.instance instanceof ListBox;

          if (typeMismatch) {
            this.createInstance();
          } else {
            this.instance.refresh();
          }
        },
        destroy: function () {
          this.instance.destroy();
        }
      }; // combobox module

      function ComboBox(options) {
        this.options = $.extend({
          wrapNative: true,
          wrapNativeOnMobile: true,
          fakeDropInBody: true,
          useCustomScroll: true,
          flipDropToFit: true,
          maxVisibleItems: 10,
          fakeAreaStructure: '<span class="jcf-select"><span class="jcf-select-text"></span><span class="jcf-select-opener"></span></span>',
          fakeDropStructure: '<div class="jcf-select-drop"><div class="jcf-select-drop-content"></div></div>',
          optionClassPrefix: 'jcf-option-',
          selectClassPrefix: 'jcf-select-',
          dropContentSelector: '.jcf-select-drop-content',
          selectTextSelector: '.jcf-select-text',
          dropActiveClass: 'jcf-drop-active',
          flipDropClass: 'jcf-drop-flipped'
        }, options);
        this.init();
      }

      $.extend(ComboBox.prototype, {
        init: function () {
          this.initStructure();
          this.bindHandlers();
          this.attachEvents();
          this.refresh();
        },
        initStructure: function () {
          // prepare structure
          this.win = $(window);
          this.doc = $(document);
          this.realElement = $(this.options.element);
          this.fakeElement = $(this.options.fakeAreaStructure).insertAfter(this.realElement);
          this.selectTextContainer = this.fakeElement.find(this.options.selectTextSelector);
          this.selectText = $('<span></span>').appendTo(this.selectTextContainer);
          makeUnselectable(this.fakeElement); // copy classes from original select

          this.fakeElement.addClass(getPrefixedClasses(this.realElement.prop('className'), this.options.selectClassPrefix)); // handle compact multiple style

          if (this.realElement.prop('multiple')) {
            this.fakeElement.addClass('jcf-compact-multiple');
          } // detect device type and dropdown behavior


          if (this.options.isMobileDevice && this.options.wrapNativeOnMobile && !this.options.wrapNative) {
            this.options.wrapNative = true;
          }

          if (this.options.wrapNative) {
            // wrap native select inside fake block
            this.realElement.prependTo(this.fakeElement).css({
              position: 'absolute',
              height: '100%',
              width: '100%'
            }).addClass(this.options.resetAppearanceClass);
          } else {
            // just hide native select
            this.realElement.addClass(this.options.hiddenClass);
            this.fakeElement.attr('title', this.realElement.attr('title'));
            this.fakeDropTarget = this.options.fakeDropInBody ? $('body') : this.fakeElement;
          }
        },
        attachEvents: function () {
          // delayed refresh handler
          var self = this;

          this.delayedRefresh = function () {
            setTimeout(function () {
              self.refresh();

              if (self.list) {
                self.list.refresh();
                self.list.scrollToActiveOption();
              }
            }, 1);
          }; // native dropdown event handlers


          if (this.options.wrapNative) {
            this.realElement.on({
              focus: this.onFocus,
              change: this.onChange,
              click: this.onChange,
              keydown: this.delayedRefresh
            });
          } else {
            // custom dropdown event handlers
            this.realElement.on({
              focus: this.onFocus,
              change: this.onChange,
              keydown: this.onKeyDown
            });
            this.fakeElement.on({
              'jcf-pointerdown': this.onSelectAreaPress
            });
          }
        },
        onKeyDown: function (e) {
          if (e.which === 13) {
            this.toggleDropdown();
          } else if (this.dropActive) {
            this.delayedRefresh();
          }
        },
        onChange: function () {
          this.refresh();
        },
        onFocus: function () {
          if (!this.pressedFlag || !this.focusedFlag) {
            this.fakeElement.addClass(this.options.focusClass);
            this.realElement.on('blur', this.onBlur);
            this.toggleListMode(true);
            this.focusedFlag = true;
          }
        },
        onBlur: function () {
          if (!this.pressedFlag) {
            this.fakeElement.removeClass(this.options.focusClass);
            this.realElement.off('blur', this.onBlur);
            this.toggleListMode(false);
            this.focusedFlag = false;
          }
        },
        onResize: function () {
          if (this.dropActive) {
            this.hideDropdown();
          }
        },
        onSelectDropPress: function () {
          this.pressedFlag = true;
        },
        onSelectDropRelease: function (e, pointerEvent) {
          this.pressedFlag = false;

          if (pointerEvent.pointerType === 'mouse') {
            this.realElement.focus();
          }
        },
        onSelectAreaPress: function (e) {
          // skip click if drop inside fake element or real select is disabled
          var dropClickedInsideFakeElement = !this.options.fakeDropInBody && $(e.target).closest(this.dropdown).length;

          if (dropClickedInsideFakeElement || e.button > 1 || this.realElement.is(':disabled')) {
            return;
          } // toggle dropdown visibility


          this.selectOpenedByEvent = e.pointerType;
          this.toggleDropdown(); // misc handlers

          if (!this.focusedFlag) {
            if (e.pointerType === 'mouse') {
              this.realElement.focus();
            } else {
              this.onFocus(e);
            }
          }

          this.pressedFlag = true;
          this.fakeElement.addClass(this.options.pressedClass);
          this.doc.on('jcf-pointerup', this.onSelectAreaRelease);
        },
        onSelectAreaRelease: function (e) {
          if (this.focusedFlag && e.pointerType === 'mouse') {
            this.realElement.focus();
          }

          this.pressedFlag = false;
          this.fakeElement.removeClass(this.options.pressedClass);
          this.doc.off('jcf-pointerup', this.onSelectAreaRelease);
        },
        onOutsideClick: function (e) {
          var target = $(e.target),
              clickedInsideSelect = target.closest(this.fakeElement).length || target.closest(this.dropdown).length;

          if (!clickedInsideSelect) {
            this.hideDropdown();
          }
        },
        onSelect: function () {
          this.refresh();

          if (this.realElement.prop('multiple')) {
            this.repositionDropdown();
          } else {
            this.hideDropdown();
          }

          this.fireNativeEvent(this.realElement, 'change');
        },
        toggleListMode: function (state) {
          if (!this.options.wrapNative) {
            if (state) {
              // temporary change select to list to avoid appearing of native dropdown
              this.realElement.attr({
                size: 4,
                'jcf-size': ''
              });
            } else {
              // restore select from list mode to dropdown select
              if (!this.options.wrapNative) {
                this.realElement.removeAttr('size jcf-size');
              }
            }
          }
        },
        createDropdown: function () {
          // destroy previous dropdown if needed
          if (this.dropdown) {
            this.list.destroy();
            this.dropdown.remove();
          } // create new drop container


          this.dropdown = $(this.options.fakeDropStructure).appendTo(this.fakeDropTarget);
          this.dropdown.addClass(getPrefixedClasses(this.realElement.prop('className'), this.options.selectClassPrefix));
          makeUnselectable(this.dropdown); // handle compact multiple style

          if (this.realElement.prop('multiple')) {
            this.dropdown.addClass('jcf-compact-multiple');
          } // set initial styles for dropdown in body


          if (this.options.fakeDropInBody) {
            this.dropdown.css({
              position: 'absolute',
              top: -9999
            });
          } // create new select list instance


          this.list = new SelectList({
            useHoverClass: true,
            handleResize: false,
            alwaysPreventMouseWheel: true,
            maxVisibleItems: this.options.maxVisibleItems,
            useCustomScroll: this.options.useCustomScroll,
            holder: this.dropdown.find(this.options.dropContentSelector),
            multipleSelectWithoutKey: this.realElement.prop('multiple'),
            element: this.realElement
          });
          $(this.list).on({
            select: this.onSelect,
            press: this.onSelectDropPress,
            release: this.onSelectDropRelease
          });
        },
        repositionDropdown: function () {
          var selectOffset = this.fakeElement.offset(),
              fakeElementBounds = this.fakeElement[0].getBoundingClientRect(),
              selectWidth = fakeElementBounds.width || fakeElementBounds.right - fakeElementBounds.left,
              selectHeight = this.fakeElement.outerHeight(),
              dropHeight = this.dropdown.css('width', selectWidth).outerHeight(),
              winScrollTop = this.win.scrollTop(),
              winHeight = this.win.height(),
              calcTop,
              calcLeft,
              bodyOffset,
              needFlipDrop = false; // check flip drop position

          if (selectOffset.top + selectHeight + dropHeight > winScrollTop + winHeight && selectOffset.top - dropHeight > winScrollTop) {
            needFlipDrop = true;
          }

          if (this.options.fakeDropInBody) {
            bodyOffset = this.fakeDropTarget.css('position') !== 'static' ? this.fakeDropTarget.offset().top : 0;

            if (this.options.flipDropToFit && needFlipDrop) {
              // calculate flipped dropdown position
              calcLeft = selectOffset.left;
              calcTop = selectOffset.top - dropHeight - bodyOffset;
            } else {
              // calculate default drop position
              calcLeft = selectOffset.left;
              calcTop = selectOffset.top + selectHeight - bodyOffset;
            } // update drop styles


            this.dropdown.css({
              width: selectWidth,
              left: calcLeft,
              top: calcTop
            });
          } // refresh flipped class


          this.dropdown.add(this.fakeElement).toggleClass(this.options.flipDropClass, this.options.flipDropToFit && needFlipDrop);
        },
        showDropdown: function () {
          // do not show empty custom dropdown
          if (!this.realElement.prop('options').length) {
            return;
          } // create options list if not created


          if (!this.dropdown) {
            this.createDropdown();
          } // show dropdown


          this.dropActive = true;
          this.dropdown.appendTo(this.fakeDropTarget);
          this.fakeElement.addClass(this.options.dropActiveClass);
          this.refreshSelectedText();
          this.repositionDropdown();
          this.list.setScrollTop(this.savedScrollTop);
          this.list.refresh(); // add temporary event handlers

          this.win.on('resize', this.onResize);
          this.doc.on('jcf-pointerdown', this.onOutsideClick);
        },
        hideDropdown: function () {
          if (this.dropdown) {
            this.savedScrollTop = this.list.getScrollTop();
            this.fakeElement.removeClass(this.options.dropActiveClass + ' ' + this.options.flipDropClass);
            this.dropdown.removeClass(this.options.flipDropClass).detach();
            this.doc.off('jcf-pointerdown', this.onOutsideClick);
            this.win.off('resize', this.onResize);
            this.dropActive = false;

            if (this.selectOpenedByEvent === 'touch') {
              this.onBlur();
            }
          }
        },
        toggleDropdown: function () {
          if (this.dropActive) {
            this.hideDropdown();
          } else {
            this.showDropdown();
          }
        },
        refreshSelectedText: function () {
          // redraw selected area
          var selectedIndex = this.realElement.prop('selectedIndex'),
              selectedOption = this.realElement.prop('options')[selectedIndex],
              selectedOptionImage = selectedOption ? selectedOption.getAttribute('data-image') : null,
              selectedOptionText = '',
              selectedOptionClasses,
              self = this;

          if (this.realElement.prop('multiple')) {
            $.each(this.realElement.prop('options'), function (index, option) {
              if (option.selected) {
                selectedOptionText += (selectedOptionText ? ', ' : '') + option.innerHTML;
              }
            });

            if (!selectedOptionText) {
              selectedOptionText = self.realElement.attr('placeholder') || '';
            }

            this.selectText.removeAttr('class').html(selectedOptionText);
          } else if (!selectedOption) {
            if (this.selectImage) {
              this.selectImage.hide();
            }

            this.selectText.removeAttr('class').empty();
          } else if (this.currentSelectedText !== selectedOption.innerHTML || this.currentSelectedImage !== selectedOptionImage) {
            selectedOptionClasses = getPrefixedClasses(selectedOption.className, this.options.optionClassPrefix);
            this.selectText.attr('class', selectedOptionClasses).html(selectedOption.innerHTML);

            if (selectedOptionImage) {
              if (!this.selectImage) {
                this.selectImage = $('<img>').prependTo(this.selectTextContainer).hide();
              }

              this.selectImage.attr('src', selectedOptionImage).show();
            } else if (this.selectImage) {
              this.selectImage.hide();
            }

            this.currentSelectedText = selectedOption.innerHTML;
            this.currentSelectedImage = selectedOptionImage;
          }
        },
        refresh: function () {
          // refresh fake select visibility
          if (this.realElement.prop('style').display === 'none') {
            this.fakeElement.hide();
          } else {
            this.fakeElement.show();
          } // refresh selected text


          this.refreshSelectedText(); // handle disabled state

          this.fakeElement.toggleClass(this.options.disabledClass, this.realElement.is(':disabled'));
        },
        destroy: function () {
          // restore structure
          if (this.options.wrapNative) {
            this.realElement.insertBefore(this.fakeElement).css({
              position: '',
              height: '',
              width: ''
            }).removeClass(this.options.resetAppearanceClass);
          } else {
            this.realElement.removeClass(this.options.hiddenClass);

            if (this.realElement.is('[jcf-size]')) {
              this.realElement.removeAttr('size jcf-size');
            }
          } // removing element will also remove its event handlers


          this.fakeElement.remove(); // remove other event handlers

          this.doc.off('jcf-pointerup', this.onSelectAreaRelease);
          this.realElement.off({
            focus: this.onFocus
          });
        }
      }); // listbox module

      function ListBox(options) {
        this.options = $.extend({
          wrapNative: true,
          useCustomScroll: true,
          fakeStructure: '<span class="jcf-list-box"><span class="jcf-list-wrapper"></span></span>',
          selectClassPrefix: 'jcf-select-',
          listHolder: '.jcf-list-wrapper'
        }, options);
        this.init();
      }

      $.extend(ListBox.prototype, {
        init: function () {
          this.bindHandlers();
          this.initStructure();
          this.attachEvents();
        },
        initStructure: function () {
          this.realElement = $(this.options.element);
          this.fakeElement = $(this.options.fakeStructure).insertAfter(this.realElement);
          this.listHolder = this.fakeElement.find(this.options.listHolder);
          makeUnselectable(this.fakeElement); // copy classes from original select

          this.fakeElement.addClass(getPrefixedClasses(this.realElement.prop('className'), this.options.selectClassPrefix));
          this.realElement.addClass(this.options.hiddenClass);
          this.list = new SelectList({
            useCustomScroll: this.options.useCustomScroll,
            holder: this.listHolder,
            selectOnClick: false,
            element: this.realElement
          });
        },
        attachEvents: function () {
          // delayed refresh handler
          var self = this;

          this.delayedRefresh = function (e) {
            if (e && (e.which === 16 || e.ctrlKey || e.metaKey || e.altKey)) {
              // ignore modifier keys
              return;
            } else {
              clearTimeout(self.refreshTimer);
              self.refreshTimer = setTimeout(function () {
                self.refresh();
                self.list.scrollToActiveOption();
              }, 1);
            }
          }; // other event handlers


          this.realElement.on({
            focus: this.onFocus,
            click: this.delayedRefresh,
            keydown: this.delayedRefresh
          }); // select list event handlers

          $(this.list).on({
            select: this.onSelect,
            press: this.onFakeOptionsPress,
            release: this.onFakeOptionsRelease
          });
        },
        onFakeOptionsPress: function (e, pointerEvent) {
          this.pressedFlag = true;

          if (pointerEvent.pointerType === 'mouse') {
            this.realElement.focus();
          }
        },
        onFakeOptionsRelease: function (e, pointerEvent) {
          this.pressedFlag = false;

          if (pointerEvent.pointerType === 'mouse') {
            this.realElement.focus();
          }
        },
        onSelect: function () {
          this.fireNativeEvent(this.realElement, 'change');
          this.fireNativeEvent(this.realElement, 'click');
        },
        onFocus: function () {
          if (!this.pressedFlag || !this.focusedFlag) {
            this.fakeElement.addClass(this.options.focusClass);
            this.realElement.on('blur', this.onBlur);
            this.focusedFlag = true;
          }
        },
        onBlur: function () {
          if (!this.pressedFlag) {
            this.fakeElement.removeClass(this.options.focusClass);
            this.realElement.off('blur', this.onBlur);
            this.focusedFlag = false;
          }
        },
        refresh: function () {
          this.fakeElement.toggleClass(this.options.disabledClass, this.realElement.is(':disabled'));
          this.list.refresh();
        },
        destroy: function () {
          this.list.destroy();
          this.realElement.insertBefore(this.fakeElement).removeClass(this.options.hiddenClass);
          this.fakeElement.remove();
        }
      }); // options list module

      function SelectList(options) {
        this.options = $.extend({
          holder: null,
          maxVisibleItems: 10,
          selectOnClick: true,
          useHoverClass: false,
          useCustomScroll: false,
          handleResize: true,
          multipleSelectWithoutKey: false,
          alwaysPreventMouseWheel: false,
          indexAttribute: 'data-index',
          cloneClassPrefix: 'jcf-option-',
          containerStructure: '<span class="jcf-list"><span class="jcf-list-content"></span></span>',
          containerSelector: '.jcf-list-content',
          captionClass: 'jcf-optgroup-caption',
          disabledClass: 'jcf-disabled',
          optionClass: 'jcf-option',
          groupClass: 'jcf-optgroup',
          hoverClass: 'jcf-hover',
          selectedClass: 'jcf-selected',
          scrollClass: 'jcf-scroll-active'
        }, options);
        this.init();
      }

      $.extend(SelectList.prototype, {
        init: function () {
          this.initStructure();
          this.refreshSelectedClass();
          this.attachEvents();
        },
        initStructure: function () {
          this.element = $(this.options.element);
          this.indexSelector = '[' + this.options.indexAttribute + ']';
          this.container = $(this.options.containerStructure).appendTo(this.options.holder);
          this.listHolder = this.container.find(this.options.containerSelector);
          this.lastClickedIndex = this.element.prop('selectedIndex');
          this.rebuildList(); // save current selection in multiple select

          if (this.element.prop('multiple')) {
            this.previousSelection = this.getSelectedOptionsIndexes();
          }
        },
        attachEvents: function () {
          this.bindHandlers();
          this.listHolder.on('jcf-pointerdown', this.indexSelector, this.onItemPress);
          this.listHolder.on('jcf-pointerdown', this.onPress);

          if (this.options.useHoverClass) {
            this.listHolder.on('jcf-pointerover', this.indexSelector, this.onHoverItem);
          }
        },
        onPress: function (e) {
          $(this).trigger('press', e);
          this.listHolder.on('jcf-pointerup', this.onRelease);
        },
        onRelease: function (e) {
          $(this).trigger('release', e);
          this.listHolder.off('jcf-pointerup', this.onRelease);
        },
        onHoverItem: function (e) {
          var hoverIndex = parseFloat(e.currentTarget.getAttribute(this.options.indexAttribute));
          this.fakeOptions.removeClass(this.options.hoverClass).eq(hoverIndex).addClass(this.options.hoverClass);
        },
        onItemPress: function (e) {
          if (e.pointerType === 'touch' || this.options.selectOnClick) {
            // select option after "click"
            this.tmpListOffsetTop = this.list.offset().top;
            this.listHolder.on('jcf-pointerup', this.indexSelector, this.onItemRelease);
          } else {
            // select option immediately
            this.onSelectItem(e);
          }
        },
        onItemRelease: function (e) {
          // remove event handlers and temporary data
          this.listHolder.off('jcf-pointerup', this.indexSelector, this.onItemRelease); // simulate item selection

          if (this.tmpListOffsetTop === this.list.offset().top) {
            this.listHolder.on('click', this.indexSelector, {
              savedPointerType: e.pointerType
            }, this.onSelectItem);
          }

          delete this.tmpListOffsetTop;
        },
        onSelectItem: function (e) {
          var clickedIndex = parseFloat(e.currentTarget.getAttribute(this.options.indexAttribute)),
              pointerType = e.data && e.data.savedPointerType || e.pointerType || 'mouse',
              range; // remove click event handler

          this.listHolder.off('click', this.indexSelector, this.onSelectItem); // ignore clicks on disabled options

          if (e.button > 1 || this.realOptions[clickedIndex].disabled) {
            return;
          }

          if (this.element.prop('multiple')) {
            if (e.metaKey || e.ctrlKey || pointerType === 'touch' || this.options.multipleSelectWithoutKey) {
              // if CTRL/CMD pressed or touch devices - toggle selected option
              this.realOptions[clickedIndex].selected = !this.realOptions[clickedIndex].selected;
            } else if (e.shiftKey) {
              // if SHIFT pressed - update selection
              range = [this.lastClickedIndex, clickedIndex].sort(function (a, b) {
                return a - b;
              });
              this.realOptions.each(function (index, option) {
                option.selected = index >= range[0] && index <= range[1];
              });
            } else {
              // set single selected index
              this.element.prop('selectedIndex', clickedIndex);
            }
          } else {
            this.element.prop('selectedIndex', clickedIndex);
          } // save last clicked option


          if (!e.shiftKey) {
            this.lastClickedIndex = clickedIndex;
          } // refresh classes


          this.refreshSelectedClass(); // scroll to active item in desktop browsers

          if (pointerType === 'mouse') {
            this.scrollToActiveOption();
          } // make callback when item selected


          $(this).trigger('select');
        },
        rebuildList: function () {
          // rebuild options
          var self = this,
              rootElement = this.element[0]; // recursively create fake options

          this.storedSelectHTML = rootElement.innerHTML;
          this.optionIndex = 0;
          this.list = $(this.createOptionsList(rootElement));
          this.listHolder.empty().append(this.list);
          this.realOptions = this.element.find('option');
          this.fakeOptions = this.list.find(this.indexSelector);
          this.fakeListItems = this.list.find('.' + this.options.captionClass + ',' + this.indexSelector);
          delete this.optionIndex; // detect max visible items

          var maxCount = this.options.maxVisibleItems,
              sizeValue = this.element.prop('size');

          if (sizeValue > 1 && !this.element.is('[jcf-size]')) {
            maxCount = sizeValue;
          } // handle scrollbar


          var needScrollBar = this.fakeOptions.length > maxCount;
          this.container.toggleClass(this.options.scrollClass, needScrollBar);

          if (needScrollBar) {
            // change max-height
            this.listHolder.css({
              maxHeight: this.getOverflowHeight(maxCount),
              overflow: 'auto'
            });

            if (this.options.useCustomScroll && jcf.modules.Scrollable) {
              // add custom scrollbar if specified in options
              jcf.replace(this.listHolder, 'Scrollable', {
                handleResize: this.options.handleResize,
                alwaysPreventMouseWheel: this.options.alwaysPreventMouseWheel
              });
              return;
            }
          } // disable edge wheel scrolling


          if (this.options.alwaysPreventMouseWheel) {
            this.preventWheelHandler = function (e) {
              var currentScrollTop = self.listHolder.scrollTop(),
                  maxScrollTop = self.listHolder.prop('scrollHeight') - self.listHolder.innerHeight(); // check edge cases

              if (currentScrollTop <= 0 && e.deltaY < 0 || currentScrollTop >= maxScrollTop && e.deltaY > 0) {
                e.preventDefault();
              }
            };

            this.listHolder.on('jcf-mousewheel', this.preventWheelHandler);
          }
        },
        refreshSelectedClass: function () {
          var self = this,
              selectedItem,
              isMultiple = this.element.prop('multiple'),
              selectedIndex = this.element.prop('selectedIndex');

          if (isMultiple) {
            this.realOptions.each(function (index, option) {
              self.fakeOptions.eq(index).toggleClass(self.options.selectedClass, !!option.selected);
            });
          } else {
            this.fakeOptions.removeClass(this.options.selectedClass + ' ' + this.options.hoverClass);
            selectedItem = this.fakeOptions.eq(selectedIndex).addClass(this.options.selectedClass);

            if (this.options.useHoverClass) {
              selectedItem.addClass(this.options.hoverClass);
            }
          }
        },
        scrollToActiveOption: function () {
          // scroll to target option
          var targetOffset = this.getActiveOptionOffset();

          if (typeof targetOffset === 'number') {
            this.listHolder.prop('scrollTop', targetOffset);
          }
        },
        getSelectedOptionsIndexes: function () {
          var selection = [];
          this.realOptions.each(function (index, option) {
            if (option.selected) {
              selection.push(index);
            }
          });
          return selection;
        },
        getChangedSelectedIndex: function () {
          var selectedIndex = this.element.prop('selectedIndex'),
              self = this,
              found = false,
              targetIndex = null;

          if (this.element.prop('multiple')) {
            // multiple selects handling
            this.currentSelection = this.getSelectedOptionsIndexes();
            $.each(this.currentSelection, function (index, optionIndex) {
              if (!found && self.previousSelection.indexOf(optionIndex) < 0) {
                if (index === 0) {
                  found = true;
                }

                targetIndex = optionIndex;
              }
            });
            this.previousSelection = this.currentSelection;
            return targetIndex;
          } else {
            // single choice selects handling
            return selectedIndex;
          }
        },
        getActiveOptionOffset: function () {
          // calc values
          var currentIndex = this.getChangedSelectedIndex(); // selection was not changed

          if (currentIndex === null) {
            return;
          } // find option and scroll to it if needed


          var dropHeight = this.listHolder.height(),
              dropScrollTop = this.listHolder.prop('scrollTop'),
              fakeOption = this.fakeOptions.eq(currentIndex),
              fakeOptionOffset = fakeOption.offset().top - this.list.offset().top,
              fakeOptionHeight = fakeOption.innerHeight(); // scroll list

          if (fakeOptionOffset + fakeOptionHeight >= dropScrollTop + dropHeight) {
            // scroll down (always scroll to option)
            return fakeOptionOffset - dropHeight + fakeOptionHeight;
          } else if (fakeOptionOffset < dropScrollTop) {
            // scroll up to option
            return fakeOptionOffset;
          }
        },
        getOverflowHeight: function (sizeValue) {
          var item = this.fakeListItems.eq(sizeValue - 1),
              listOffset = this.list.offset().top,
              itemOffset = item.offset().top,
              itemHeight = item.innerHeight();
          return itemOffset + itemHeight - listOffset;
        },
        getScrollTop: function () {
          return this.listHolder.scrollTop();
        },
        setScrollTop: function (value) {
          this.listHolder.scrollTop(value);
        },
        createOption: function (option) {
          var newOption = document.createElement('span');
          newOption.className = this.options.optionClass;
          newOption.innerHTML = option.innerHTML;
          newOption.setAttribute(this.options.indexAttribute, this.optionIndex++);
          var optionImage,
              optionImageSrc = option.getAttribute('data-image');

          if (optionImageSrc) {
            optionImage = document.createElement('img');
            optionImage.src = optionImageSrc;
            newOption.insertBefore(optionImage, newOption.childNodes[0]);
          }

          if (option.disabled) {
            newOption.className += ' ' + this.options.disabledClass;
          }

          if (option.className) {
            newOption.className += ' ' + getPrefixedClasses(option.className, this.options.cloneClassPrefix);
          }

          return newOption;
        },
        createOptGroup: function (optgroup) {
          var optGroupContainer = document.createElement('span'),
              optGroupName = optgroup.getAttribute('label'),
              optGroupCaption,
              optGroupList; // create caption

          optGroupCaption = document.createElement('span');
          optGroupCaption.className = this.options.captionClass;
          optGroupCaption.innerHTML = optGroupName;
          optGroupContainer.appendChild(optGroupCaption); // create list of options

          if (optgroup.children.length) {
            optGroupList = this.createOptionsList(optgroup);
            optGroupContainer.appendChild(optGroupList);
          }

          optGroupContainer.className = this.options.groupClass;
          return optGroupContainer;
        },
        createOptionContainer: function () {
          var optionContainer = document.createElement('li');
          return optionContainer;
        },
        createOptionsList: function (container) {
          var self = this,
              list = document.createElement('ul');
          $.each(container.children, function (index, currentNode) {
            var item = self.createOptionContainer(currentNode),
                newNode;

            switch (currentNode.tagName.toLowerCase()) {
              case 'option':
                newNode = self.createOption(currentNode);
                break;

              case 'optgroup':
                newNode = self.createOptGroup(currentNode);
                break;
            }

            list.appendChild(item).appendChild(newNode);
          });
          return list;
        },
        refresh: function () {
          // check for select innerHTML changes
          if (this.storedSelectHTML !== this.element.prop('innerHTML')) {
            this.rebuildList();
          } // refresh custom scrollbar


          var scrollInstance = jcf.getInstance(this.listHolder);

          if (scrollInstance) {
            scrollInstance.refresh();
          } // refresh selectes classes


          this.refreshSelectedClass();
        },
        destroy: function () {
          this.listHolder.off('jcf-mousewheel', this.preventWheelHandler);
          this.listHolder.off('jcf-pointerdown', this.indexSelector, this.onSelectItem);
          this.listHolder.off('jcf-pointerover', this.indexSelector, this.onHoverItem);
          this.listHolder.off('jcf-pointerdown', this.onPress);
        }
      }); // helper functions

      var getPrefixedClasses = function (className, prefixToAdd) {
        return className ? className.replace(/[\s]*([\S]+)+[\s]*/gi, prefixToAdd + '$1 ') : '';
      };

      var makeUnselectable = function () {
        var unselectableClass = jcf.getOptions().unselectableClass;

        function preventHandler(e) {
          e.preventDefault();
        }

        return function (node) {
          node.addClass(unselectableClass).on('selectstart', preventHandler);
        };
      }();

      return module;
    });
  })(jcf);

  /*!
   * JavaScript Custom Forms : File Module
   *
   * Copyright 2014-2015 PSD2HTML - http://psd2html.com/jcf
   * Released under the MIT license (LICENSE.txt)
   *
   * Version: 1.2.3
   */
  (function (jcf) {
    jcf.addModule(function ($) {

      return {
        name: 'File',
        selector: 'input[type="file"]',
        options: {
          fakeStructure: '<span class="jcf-file"><span class="jcf-fake-input"></span><span class="jcf-upload-button"><span class="jcf-button-content"></span></span></span>',
          buttonText: 'Choose file',
          placeholderText: 'No file chosen',
          realElementClass: 'jcf-real-element',
          extensionPrefixClass: 'jcf-extension-',
          selectedFileBlock: '.jcf-fake-input',
          buttonTextBlock: '.jcf-button-content'
        },
        matchElement: function (element) {
          return element.is('input[type="file"]');
        },
        init: function () {
          this.initStructure();
          this.attachEvents();
          this.refresh();
        },
        initStructure: function () {
          this.doc = $(document);
          this.realElement = $(this.options.element).addClass(this.options.realElementClass);
          this.fakeElement = $(this.options.fakeStructure).insertBefore(this.realElement);
          this.fileNameBlock = this.fakeElement.find(this.options.selectedFileBlock);
          this.buttonTextBlock = this.fakeElement.find(this.options.buttonTextBlock).text(this.options.buttonText);
          this.realElement.appendTo(this.fakeElement).css({
            position: 'absolute',
            opacity: 0
          });
        },
        attachEvents: function () {
          this.realElement.on({
            'jcf-pointerdown': this.onPress,
            change: this.onChange,
            focus: this.onFocus
          });
        },
        onChange: function () {
          this.refresh();
        },
        onFocus: function () {
          this.fakeElement.addClass(this.options.focusClass);
          this.realElement.on('blur', this.onBlur);
        },
        onBlur: function () {
          this.fakeElement.removeClass(this.options.focusClass);
          this.realElement.off('blur', this.onBlur);
        },
        onPress: function () {
          this.fakeElement.addClass(this.options.pressedClass);
          this.doc.on('jcf-pointerup', this.onRelease);
        },
        onRelease: function () {
          this.fakeElement.removeClass(this.options.pressedClass);
          this.doc.off('jcf-pointerup', this.onRelease);
        },
        getFileName: function () {
          var resultFileName = '',
              files = this.realElement.prop('files');

          if (files && files.length) {
            $.each(files, function (index, file) {
              resultFileName += (index > 0 ? ', ' : '') + file.name;
            });
          } else {
            resultFileName = this.realElement.val().replace(/^[\s\S]*(?:\\|\/)([\s\S^\\\/]*)$/g, '$1');
          }

          return resultFileName;
        },
        getFileExtension: function () {
          var fileName = this.realElement.val();
          return fileName.lastIndexOf('.') < 0 ? '' : fileName.substring(fileName.lastIndexOf('.') + 1).toLowerCase();
        },
        updateExtensionClass: function () {
          var currentExtension = this.getFileExtension(),
              currentClassList = this.fakeElement.prop('className'),
              cleanedClassList = currentClassList.replace(new RegExp('(\\s|^)' + this.options.extensionPrefixClass + '[^ ]+', 'gi'), '');
          this.fakeElement.prop('className', cleanedClassList);

          if (currentExtension) {
            this.fakeElement.addClass(this.options.extensionPrefixClass + currentExtension);
          }
        },
        refresh: function () {
          var selectedFileName = this.getFileName() || this.options.placeholderText;
          this.fakeElement.toggleClass(this.options.disabledClass, this.realElement.is(':disabled'));
          this.fileNameBlock.text(selectedFileName);
          this.updateExtensionClass();
        },
        destroy: function () {
          // reset styles and restore element position
          this.realElement.insertBefore(this.fakeElement).removeClass(this.options.realElementClass).css({
            position: '',
            opacity: ''
          });
          this.fakeElement.remove(); // remove event handlers

          this.realElement.off({
            'jcf-pointerdown': this.onPress,
            change: this.onChange,
            focus: this.onFocus,
            blur: this.onBlur
          });
          this.doc.off('jcf-pointerup', this.onRelease);
        }
      };
    });
  })(jcf);

  /*!
   * JavaScript Custom Forms : Button Module
   *
   * Copyright 2014-2015 PSD2HTML - http://psd2html.com/jcf
   * Released under the MIT license (LICENSE.txt)
   *
   * Version: 1.2.3
   */
  (function (jcf) {
    jcf.addModule(function ($) {

      return {
        name: 'Button',
        selector: 'button, input[type="button"], input[type="submit"], input[type="reset"]',
        options: {
          realElementClass: 'jcf-real-element',
          fakeStructure: '<span class="jcf-button"><span class="jcf-button-content"></span></span>',
          buttonContent: '.jcf-button-content'
        },
        matchElement: function (element) {
          return element.is(this.selector);
        },
        init: function () {
          this.initStructure();
          this.attachEvents();
          this.refresh();
        },
        initStructure: function () {
          this.page = $('html');
          this.realElement = $(this.options.element).addClass(this.options.realElementClass);
          this.fakeElement = $(this.options.fakeStructure).insertBefore(this.realElement);
          this.buttonContent = this.fakeElement.find(this.options.buttonContent);
          this.fakeElement.css({
            position: 'relative'
          });
          this.realElement.prependTo(this.fakeElement).css({
            position: 'absolute',
            opacity: 0
          });
        },
        attachEvents: function () {
          this.realElement.on({
            focus: this.onFocus,
            'jcf-pointerdown': this.onPress
          });
        },
        onPress: function () {
          this.fakeElement.addClass(this.options.pressedClass);
          this.page.on('jcf-pointerup', this.onRelease);
        },
        onRelease: function () {
          this.fakeElement.removeClass(this.options.pressedClass);
          this.page.off('jcf-pointerup', this.onRelease);
        },
        onFocus: function () {
          this.fakeElement.addClass(this.options.focusClass);
          this.realElement.on('blur', this.onBlur);
        },
        onBlur: function () {
          this.fakeElement.removeClass(this.options.focusClass);
          this.realElement.off('blur', this.onBlur);
        },
        refresh: function () {
          this.buttonContent.html(this.realElement.html() || this.realElement.val());
          this.fakeElement.toggleClass(this.options.disabledClass, this.realElement.is(':disabled'));
        },
        destroy: function () {
          this.realElement.removeClass(this.options.realElementClass).insertBefore(this.fakeElement);
          this.fakeElement.remove();
          this.realElement.off({
            focus: this.onFocus,
            blur: this.onBlur,
            'jcf-pointerdown': this.onPress
          });
          this.realElement.css({
            position: '',
            opacity: ''
          });
        }
      };
    });
  })(jcf);

  /*!
   * JavaScript Custom Forms : Checkbox Module
   *
   * Copyright 2014-2015 PSD2HTML - http://psd2html.com/jcf
   * Released under the MIT license (LICENSE.txt)
   *
   * Version: 1.2.3
   */
  (function (jcf) {
    jcf.addModule(function ($) {

      return {
        name: 'Checkbox',
        selector: 'input[type="checkbox"]',
        options: {
          wrapNative: true,
          checkedClass: 'jcf-checked',
          uncheckedClass: 'jcf-unchecked',
          labelActiveClass: 'jcf-label-active',
          fakeStructure: '<span class="jcf-checkbox"><span></span></span>'
        },
        matchElement: function (element) {
          return element.is(':checkbox');
        },
        init: function () {
          this.initStructure();
          this.attachEvents();
          this.refresh();
        },
        initStructure: function () {
          // prepare structure
          this.doc = $(document);
          this.realElement = $(this.options.element);
          this.fakeElement = $(this.options.fakeStructure).insertAfter(this.realElement);
          this.labelElement = this.getLabelFor();

          if (this.options.wrapNative) {
            // wrap native checkbox inside fake block
            this.realElement.appendTo(this.fakeElement).css({
              position: 'absolute',
              height: '100%',
              width: '100%',
              opacity: 0,
              margin: 0
            });
          } else {
            // just hide native checkbox
            this.realElement.addClass(this.options.hiddenClass);
          }
        },
        attachEvents: function () {
          // add event handlers
          this.realElement.on({
            focus: this.onFocus,
            click: this.onRealClick
          });
          this.fakeElement.on('click', this.onFakeClick);
          this.fakeElement.on('jcf-pointerdown', this.onPress);
        },
        onRealClick: function (e) {
          // just redraw fake element (setTimeout handles click that might be prevented)
          var self = this;
          this.savedEventObject = e;
          setTimeout(function () {
            self.refresh();
          }, 0);
        },
        onFakeClick: function (e) {
          // skip event if clicked on real element inside wrapper
          if (this.options.wrapNative && this.realElement.is(e.target)) {
            return;
          } // toggle checked class


          if (!this.realElement.is(':disabled')) {
            delete this.savedEventObject;
            this.stateChecked = this.realElement.prop('checked');
            this.realElement.prop('checked', !this.stateChecked);
            this.fireNativeEvent(this.realElement, 'click');

            if (this.savedEventObject && this.savedEventObject.isDefaultPrevented()) {
              this.realElement.prop('checked', this.stateChecked);
            } else {
              this.fireNativeEvent(this.realElement, 'change');
            }

            delete this.savedEventObject;
          }
        },
        onFocus: function () {
          if (!this.pressedFlag || !this.focusedFlag) {
            this.focusedFlag = true;
            this.fakeElement.addClass(this.options.focusClass);
            this.realElement.on('blur', this.onBlur);
          }
        },
        onBlur: function () {
          if (!this.pressedFlag) {
            this.focusedFlag = false;
            this.fakeElement.removeClass(this.options.focusClass);
            this.realElement.off('blur', this.onBlur);
          }
        },
        onPress: function (e) {
          if (!this.focusedFlag && e.pointerType === 'mouse') {
            this.realElement.focus();
          }

          this.pressedFlag = true;
          this.fakeElement.addClass(this.options.pressedClass);
          this.doc.on('jcf-pointerup', this.onRelease);
        },
        onRelease: function (e) {
          if (this.focusedFlag && e.pointerType === 'mouse') {
            this.realElement.focus();
          }

          this.pressedFlag = false;
          this.fakeElement.removeClass(this.options.pressedClass);
          this.doc.off('jcf-pointerup', this.onRelease);
        },
        getLabelFor: function () {
          var parentLabel = this.realElement.closest('label'),
              elementId = this.realElement.prop('id');

          if (!parentLabel.length && elementId) {
            parentLabel = $('label[for="' + elementId + '"]');
          }

          return parentLabel.length ? parentLabel : null;
        },
        refresh: function () {
          // redraw custom checkbox
          var isChecked = this.realElement.is(':checked'),
              isDisabled = this.realElement.is(':disabled');
          this.fakeElement.toggleClass(this.options.checkedClass, isChecked).toggleClass(this.options.uncheckedClass, !isChecked).toggleClass(this.options.disabledClass, isDisabled);

          if (this.labelElement) {
            this.labelElement.toggleClass(this.options.labelActiveClass, isChecked);
          }
        },
        destroy: function () {
          // restore structure
          if (this.options.wrapNative) {
            this.realElement.insertBefore(this.fakeElement).css({
              position: '',
              width: '',
              height: '',
              opacity: '',
              margin: ''
            });
          } else {
            this.realElement.removeClass(this.options.hiddenClass);
          } // removing element will also remove its event handlers


          this.fakeElement.off('jcf-pointerdown', this.onPress);
          this.fakeElement.remove(); // remove other event handlers

          this.doc.off('jcf-pointerup', this.onRelease);
          this.realElement.off({
            focus: this.onFocus,
            click: this.onRealClick
          });
        }
      };
    });
  })(jcf);

  /*!
   * JavaScript Custom Forms : Number Module
   *
   * Copyright 2014-2015 PSD2HTML - http://psd2html.com/jcf
   * Released under the MIT license (LICENSE.txt)
   *
   * Version: 1.2.3
   */
  (function (jcf) {
    jcf.addModule(function ($) {

      return {
        name: 'Number',
        selector: 'input[type="number"]',
        options: {
          realElementClass: 'jcf-real-element',
          fakeStructure: '<span class="jcf-number"><span class="jcf-btn-inc"></span><span class="jcf-btn-dec"></span></span>',
          btnIncSelector: '.jcf-btn-inc',
          btnDecSelector: '.jcf-btn-dec',
          pressInterval: 150
        },
        matchElement: function (element) {
          return element.is(this.selector);
        },
        init: function () {
          this.initStructure();
          this.attachEvents();
          this.refresh();
        },
        initStructure: function () {
          this.page = $('html');
          this.realElement = $(this.options.element).addClass(this.options.realElementClass);
          this.fakeElement = $(this.options.fakeStructure).insertBefore(this.realElement).prepend(this.realElement);
          this.btnDec = this.fakeElement.find(this.options.btnDecSelector);
          this.btnInc = this.fakeElement.find(this.options.btnIncSelector); // set initial values

          this.initialValue = parseFloat(this.realElement.val()) || 0;
          this.minValue = parseFloat(this.realElement.attr('min'));
          this.maxValue = parseFloat(this.realElement.attr('max'));
          this.stepValue = parseFloat(this.realElement.attr('step')) || 1; // check attribute values

          this.minValue = isNaN(this.minValue) ? -Infinity : this.minValue;
          this.maxValue = isNaN(this.maxValue) ? Infinity : this.maxValue; // handle range

          if (isFinite(this.maxValue)) {
            this.maxValue -= (this.maxValue - this.minValue) % this.stepValue;
          }
        },
        attachEvents: function () {
          this.realElement.on({
            focus: this.onFocus
          });
          this.btnDec.add(this.btnInc).on('jcf-pointerdown', this.onBtnPress);
        },
        onBtnPress: function (e) {
          var self = this,
              increment;

          if (!this.realElement.is(':disabled')) {
            increment = this.btnInc.is(e.currentTarget);
            self.step(increment);
            clearInterval(this.stepTimer);
            this.stepTimer = setInterval(function () {
              self.step(increment);
            }, this.options.pressInterval);
            this.page.on('jcf-pointerup', this.onBtnRelease);
          }
        },
        onBtnRelease: function () {
          clearInterval(this.stepTimer);
          this.page.off('jcf-pointerup', this.onBtnRelease);
        },
        onFocus: function () {
          this.fakeElement.addClass(this.options.focusClass);
          this.realElement.on({
            blur: this.onBlur,
            keydown: this.onKeyPress
          });
        },
        onBlur: function () {
          this.fakeElement.removeClass(this.options.focusClass);
          this.realElement.off({
            blur: this.onBlur,
            keydown: this.onKeyPress
          });
        },
        onKeyPress: function (e) {
          if (e.which === 38 || e.which === 40) {
            e.preventDefault();
            this.step(e.which === 38);
          }
        },
        step: function (increment) {
          var originalValue = parseFloat(this.realElement.val()),
              newValue = originalValue || 0,
              addValue = this.stepValue * (increment ? 1 : -1),
              edgeNumber = isFinite(this.minValue) ? this.minValue : this.initialValue - Math.abs(newValue * this.stepValue),
              diff = Math.abs(edgeNumber - newValue) % this.stepValue; // handle step diff

          if (diff) {
            if (increment) {
              newValue += addValue - diff;
            } else {
              newValue -= diff;
            }
          } else {
            newValue += addValue;
          } // handle min/max limits


          if (newValue < this.minValue) {
            newValue = this.minValue;
          } else if (newValue > this.maxValue) {
            newValue = this.maxValue;
          } // update value in real input if its changed


          if (newValue !== originalValue) {
            this.realElement.val(newValue).trigger('change');
            this.refresh();
          }
        },
        refresh: function () {
          var isDisabled = this.realElement.is(':disabled'),
              currentValue = parseFloat(this.realElement.val()); // handle disabled state

          this.fakeElement.toggleClass(this.options.disabledClass, isDisabled); // refresh button classes

          this.btnDec.toggleClass(this.options.disabledClass, currentValue === this.minValue);
          this.btnInc.toggleClass(this.options.disabledClass, currentValue === this.maxValue);
        },
        destroy: function () {
          // restore original structure
          this.realElement.removeClass(this.options.realElementClass).insertBefore(this.fakeElement);
          this.fakeElement.remove();
          clearInterval(this.stepTimer); // remove event handlers

          this.page.off('jcf-pointerup', this.onBtnRelease);
          this.realElement.off({
            keydown: this.onKeyPress,
            focus: this.onFocus,
            blur: this.onBlur
          });
        }
      };
    });
  })(jcf);

  /*!
   * JavaScript Custom Forms : Radio Module
   *
   * Copyright 2014-2015 PSD2HTML - http://psd2html.com/jcf
   * Released under the MIT license (LICENSE.txt)
   *
   * Version: 1.2.3
   */
  (function (jcf) {
    jcf.addModule(function ($) {

      return {
        name: 'Radio',
        selector: 'input[type="radio"]',
        options: {
          wrapNative: true,
          checkedClass: 'jcf-checked',
          uncheckedClass: 'jcf-unchecked',
          labelActiveClass: 'jcf-label-active',
          fakeStructure: '<span class="jcf-radio"><span></span></span>'
        },
        matchElement: function (element) {
          return element.is(':radio');
        },
        init: function () {
          this.initStructure();
          this.attachEvents();
          this.refresh();
        },
        initStructure: function () {
          // prepare structure
          this.doc = $(document);
          this.realElement = $(this.options.element);
          this.fakeElement = $(this.options.fakeStructure).insertAfter(this.realElement);
          this.labelElement = this.getLabelFor();

          if (this.options.wrapNative) {
            // wrap native radio inside fake block
            this.realElement.prependTo(this.fakeElement).css({
              position: 'absolute',
              opacity: 0
            });
          } else {
            // just hide native radio
            this.realElement.addClass(this.options.hiddenClass);
          }
        },
        attachEvents: function () {
          // add event handlers
          this.realElement.on({
            focus: this.onFocus,
            click: this.onRealClick
          });
          this.fakeElement.on('click', this.onFakeClick);
          this.fakeElement.on('jcf-pointerdown', this.onPress);
        },
        onRealClick: function (e) {
          // redraw current radio and its group (setTimeout handles click that might be prevented)
          var self = this;
          this.savedEventObject = e;
          setTimeout(function () {
            self.refreshRadioGroup();
          }, 0);
        },
        onFakeClick: function (e) {
          // skip event if clicked on real element inside wrapper
          if (this.options.wrapNative && this.realElement.is(e.target)) {
            return;
          } // toggle checked class


          if (!this.realElement.is(':disabled')) {
            delete this.savedEventObject;
            this.currentActiveRadio = this.getCurrentActiveRadio();
            this.stateChecked = this.realElement.prop('checked');
            this.realElement.prop('checked', true);
            this.fireNativeEvent(this.realElement, 'click');

            if (this.savedEventObject && this.savedEventObject.isDefaultPrevented()) {
              this.realElement.prop('checked', this.stateChecked);
              this.currentActiveRadio.prop('checked', true);
            } else {
              this.fireNativeEvent(this.realElement, 'change');
            }

            delete this.savedEventObject;
          }
        },
        onFocus: function () {
          if (!this.pressedFlag || !this.focusedFlag) {
            this.focusedFlag = true;
            this.fakeElement.addClass(this.options.focusClass);
            this.realElement.on('blur', this.onBlur);
          }
        },
        onBlur: function () {
          if (!this.pressedFlag) {
            this.focusedFlag = false;
            this.fakeElement.removeClass(this.options.focusClass);
            this.realElement.off('blur', this.onBlur);
          }
        },
        onPress: function (e) {
          if (!this.focusedFlag && e.pointerType === 'mouse') {
            this.realElement.focus();
          }

          this.pressedFlag = true;
          this.fakeElement.addClass(this.options.pressedClass);
          this.doc.on('jcf-pointerup', this.onRelease);
        },
        onRelease: function (e) {
          if (this.focusedFlag && e.pointerType === 'mouse') {
            this.realElement.focus();
          }

          this.pressedFlag = false;
          this.fakeElement.removeClass(this.options.pressedClass);
          this.doc.off('jcf-pointerup', this.onRelease);
        },
        getCurrentActiveRadio: function () {
          return this.getRadioGroup(this.realElement).filter(':checked');
        },
        getRadioGroup: function (radio) {
          // find radio group for specified radio button
          var name = radio.attr('name'),
              parentForm = radio.parents('form');

          if (name) {
            if (parentForm.length) {
              return parentForm.find('input[name="' + name + '"]');
            } else {
              return $('input[name="' + name + '"]:not(form input)');
            }
          } else {
            return radio;
          }
        },
        getLabelFor: function () {
          var parentLabel = this.realElement.closest('label'),
              elementId = this.realElement.prop('id');

          if (!parentLabel.length && elementId) {
            parentLabel = $('label[for="' + elementId + '"]');
          }

          return parentLabel.length ? parentLabel : null;
        },
        refreshRadioGroup: function () {
          // redraw current radio and its group
          this.getRadioGroup(this.realElement).each(function () {
            jcf.refresh(this);
          });
        },
        refresh: function () {
          // redraw current radio button
          var isChecked = this.realElement.is(':checked'),
              isDisabled = this.realElement.is(':disabled');
          this.fakeElement.toggleClass(this.options.checkedClass, isChecked).toggleClass(this.options.uncheckedClass, !isChecked).toggleClass(this.options.disabledClass, isDisabled);

          if (this.labelElement) {
            this.labelElement.toggleClass(this.options.labelActiveClass, isChecked);
          }
        },
        destroy: function () {
          // restore structure
          if (this.options.wrapNative) {
            this.realElement.insertBefore(this.fakeElement).css({
              position: '',
              width: '',
              height: '',
              opacity: '',
              margin: ''
            });
          } else {
            this.realElement.removeClass(this.options.hiddenClass);
          } // removing element will also remove its event handlers


          this.fakeElement.off('jcf-pointerdown', this.onPress);
          this.fakeElement.remove(); // remove other event handlers

          this.doc.off('jcf-pointerup', this.onRelease);
          this.realElement.off({
            blur: this.onBlur,
            focus: this.onFocus,
            click: this.onRealClick
          });
        }
      };
    });
  })(jcf);

  /*!
   * JavaScript Custom Forms : Range Module
   *
   * Copyright 2014-2015 PSD2HTML - http://psd2html.com/jcf
   * Released under the MIT license (LICENSE.txt)
   *
   * Version: 1.2.3
   */
  (function (jcf) {
    jcf.addModule(function ($) {

      return {
        name: 'Range',
        selector: 'input[type="range"]',
        options: {
          realElementClass: 'jcf-real-element',
          fakeStructure: '<span class="jcf-range"><span class="jcf-range-wrapper"><span class="jcf-range-track"><span class="jcf-range-handle"></span></span></span></span>',
          dataListMark: '<span class="jcf-range-mark"></span>',
          rangeDisplayWrapper: '<span class="jcf-range-display-wrapper"></span>',
          rangeDisplay: '<span class="jcf-range-display"></span>',
          handleSelector: '.jcf-range-handle',
          trackSelector: '.jcf-range-track',
          activeHandleClass: 'jcf-active-handle',
          verticalClass: 'jcf-vertical',
          orientation: 'horizontal',
          range: false,
          // or "min", "max", "all"
          dragHandleCenter: true,
          snapToMarks: true,
          snapRadius: 5,
          minRange: 0
        },
        matchElement: function (element) {
          return element.is(this.selector);
        },
        init: function () {
          this.initStructure();
          this.attachEvents();
          this.refresh();
        },
        initStructure: function () {
          this.page = $('html');
          this.realElement = $(this.options.element).addClass(this.options.hiddenClass);
          this.fakeElement = $(this.options.fakeStructure).insertBefore(this.realElement).prepend(this.realElement);
          this.track = this.fakeElement.find(this.options.trackSelector);
          this.trackHolder = this.track.parent();
          this.handle = this.fakeElement.find(this.options.handleSelector);
          this.createdHandleCount = 0;
          this.activeDragHandleIndex = 0;
          this.isMultiple = this.realElement.prop('multiple') || typeof this.realElement.attr('multiple') === 'string';
          this.values = this.isMultiple ? this.realElement.attr('value').split(',') : [this.realElement.val()];
          this.handleCount = this.isMultiple ? this.values.length : 1; // create range display

          this.rangeDisplayWrapper = $(this.options.rangeDisplayWrapper).insertBefore(this.track);

          if (this.options.range === 'min' || this.options.range === 'all') {
            this.rangeMin = $(this.options.rangeDisplay).addClass('jcf-range-min').prependTo(this.rangeDisplayWrapper);
          }

          if (this.options.range === 'max' || this.options.range === 'all') {
            this.rangeMax = $(this.options.rangeDisplay).addClass('jcf-range-max').prependTo(this.rangeDisplayWrapper);
          } // clone handles if needed


          while (this.createdHandleCount < this.handleCount) {
            this.createdHandleCount++;
            this.handle.clone().addClass('jcf-index-' + this.createdHandleCount).insertBefore(this.handle); // create mid ranges

            if (this.createdHandleCount > 1) {
              if (!this.rangeMid) {
                this.rangeMid = $();
              }

              this.rangeMid = this.rangeMid.add($(this.options.rangeDisplay).addClass('jcf-range-mid').prependTo(this.rangeDisplayWrapper));
            }
          } // grab all handles


          this.handle.detach();
          this.handle = null;
          this.handles = this.fakeElement.find(this.options.handleSelector);
          this.handles.eq(0).addClass(this.options.activeHandleClass); // handle orientation

          this.isVertical = this.options.orientation === 'vertical';
          this.directionProperty = this.isVertical ? 'top' : 'left';
          this.offsetProperty = this.isVertical ? 'bottom' : 'left';
          this.eventProperty = this.isVertical ? 'pageY' : 'pageX';
          this.sizeProperty = this.isVertical ? 'height' : 'width';
          this.sizeMethod = this.isVertical ? 'innerHeight' : 'innerWidth';
          this.fakeElement.css('touchAction', this.isVertical ? 'pan-x' : 'pan-y');

          if (this.isVertical) {
            this.fakeElement.addClass(this.options.verticalClass);
          } // set initial values


          this.minValue = parseFloat(this.realElement.attr('min'));
          this.maxValue = parseFloat(this.realElement.attr('max'));
          this.stepValue = parseFloat(this.realElement.attr('step')) || 1; // check attribute values

          this.minValue = isNaN(this.minValue) ? 0 : this.minValue;
          this.maxValue = isNaN(this.maxValue) ? 100 : this.maxValue; // handle range

          if (this.stepValue !== 1) {
            this.maxValue -= (this.maxValue - this.minValue) % this.stepValue;
          }

          this.stepsCount = (this.maxValue - this.minValue) / this.stepValue;
          this.createDataList();
        },
        attachEvents: function () {
          this.realElement.on({
            focus: this.onFocus
          });
          this.trackHolder.on('jcf-pointerdown', this.onTrackPress);
          this.handles.on('jcf-pointerdown', this.onHandlePress);
        },
        createDataList: function () {
          var self = this,
              dataValues = [],
              dataListId = this.realElement.attr('list');

          if (dataListId) {
            $('#' + dataListId).find('option').each(function () {
              var itemValue = parseFloat(this.value || this.innerHTML),
                  mark,
                  markOffset;

              if (!isNaN(itemValue)) {
                markOffset = self.valueToOffset(itemValue);
                dataValues.push({
                  value: itemValue,
                  offset: markOffset
                });
                mark = $(self.options.dataListMark).text(itemValue).attr({
                  'data-mark-value': itemValue
                }).css(self.offsetProperty, markOffset + '%').appendTo(self.track);
              }
            });

            if (dataValues.length) {
              self.dataValues = dataValues;
            }
          }
        },
        getDragHandleRange: function (handleIndex) {
          // calculate range for slider with multiple handles
          var minStep = -Infinity,
              maxStep = Infinity;

          if (handleIndex > 0) {
            minStep = this.valueToStepIndex(parseFloat(this.values[handleIndex - 1]) + this.options.minRange);
          }

          if (handleIndex < this.handleCount - 1) {
            maxStep = this.valueToStepIndex(parseFloat(this.values[handleIndex + 1]) - this.options.minRange);
          }

          return {
            minStepIndex: minStep,
            maxStepIndex: maxStep
          };
        },
        getNearestHandle: function (percent) {
          // handle vertical sliders
          if (this.isVertical) {
            percent = 1 - percent;
          } // detect closest handle when track is pressed


          var closestHandle = this.handles.eq(0),
              closestDistance = Infinity,
              self = this;

          if (this.handleCount > 1) {
            this.handles.each(function () {
              var handleOffset = parseFloat(this.style[self.offsetProperty]) / 100,
                  handleDistance = Math.abs(handleOffset - percent);

              if (handleDistance < closestDistance) {
                closestDistance = handleDistance;
                closestHandle = $(this);
              }
            });
          }

          return closestHandle;
        },
        onTrackPress: function (e) {
          var trackSize, trackOffset, innerOffset;
          e.preventDefault();

          if (!this.realElement.is(':disabled') && !this.activeDragHandle) {
            trackSize = this.track[this.sizeMethod]();
            trackOffset = this.track.offset()[this.directionProperty];
            this.activeDragHandle = this.getNearestHandle((e[this.eventProperty] - trackOffset) / this.trackHolder[this.sizeMethod]());
            this.activeDragHandleIndex = this.handles.index(this.activeDragHandle);
            this.handles.removeClass(this.options.activeHandleClass).eq(this.activeDragHandleIndex).addClass(this.options.activeHandleClass);
            innerOffset = this.activeDragHandle[this.sizeMethod]() / 2;
            this.dragData = {
              trackSize: trackSize,
              innerOffset: innerOffset,
              trackOffset: trackOffset,
              min: trackOffset,
              max: trackOffset + trackSize
            };
            this.page.on({
              'jcf-pointermove': this.onHandleMove,
              'jcf-pointerup': this.onHandleRelease
            });

            if (e.pointerType === 'mouse') {
              this.realElement.focus();
            }

            this.onHandleMove(e);
          }
        },
        onHandlePress: function (e) {
          var trackSize, trackOffset, innerOffset;
          e.preventDefault();

          if (!this.realElement.is(':disabled') && !this.activeDragHandle) {
            this.activeDragHandle = $(e.currentTarget);
            this.activeDragHandleIndex = this.handles.index(this.activeDragHandle);
            this.handles.removeClass(this.options.activeHandleClass).eq(this.activeDragHandleIndex).addClass(this.options.activeHandleClass);
            trackSize = this.track[this.sizeMethod]();
            trackOffset = this.track.offset()[this.directionProperty];
            innerOffset = this.options.dragHandleCenter ? this.activeDragHandle[this.sizeMethod]() / 2 : e[this.eventProperty] - this.handle.offset()[this.directionProperty];
            this.dragData = {
              trackSize: trackSize,
              innerOffset: innerOffset,
              trackOffset: trackOffset,
              min: trackOffset,
              max: trackOffset + trackSize
            };
            this.page.on({
              'jcf-pointermove': this.onHandleMove,
              'jcf-pointerup': this.onHandleRelease
            });

            if (e.pointerType === 'mouse') {
              this.realElement.focus();
            }
          }
        },
        onHandleMove: function (e) {
          var self = this,
              newOffset,
              dragPercent,
              stepIndex,
              valuePercent,
              handleDragRange; // calculate offset

          if (this.isVertical) {
            newOffset = this.dragData.max + (this.dragData.min - e[this.eventProperty]) - this.dragData.innerOffset;
          } else {
            newOffset = e[this.eventProperty] - this.dragData.innerOffset;
          } // fit in range


          if (newOffset < this.dragData.min) {
            newOffset = this.dragData.min;
          } else if (newOffset > this.dragData.max) {
            newOffset = this.dragData.max;
          }

          e.preventDefault();

          if (this.options.snapToMarks && this.dataValues) {
            // snap handle to marks
            var dragOffset = newOffset - this.dragData.trackOffset;
            dragPercent = (newOffset - this.dragData.trackOffset) / this.dragData.trackSize * 100;
            $.each(this.dataValues, function (index, item) {
              var markOffset = item.offset / 100 * self.dragData.trackSize,
                  markMin = markOffset - self.options.snapRadius,
                  markMax = markOffset + self.options.snapRadius;

              if (dragOffset >= markMin && dragOffset <= markMax) {
                dragPercent = item.offset;
                return false;
              }
            });
          } else {
            // snap handle to steps
            dragPercent = (newOffset - this.dragData.trackOffset) / this.dragData.trackSize * 100;
          } // move handle only in range


          stepIndex = Math.round(dragPercent * this.stepsCount / 100);

          if (this.handleCount > 1) {
            handleDragRange = this.getDragHandleRange(this.activeDragHandleIndex);

            if (stepIndex < handleDragRange.minStepIndex) {
              stepIndex = Math.max(handleDragRange.minStepIndex, stepIndex);
            } else if (stepIndex > handleDragRange.maxStepIndex) {
              stepIndex = Math.min(handleDragRange.maxStepIndex, stepIndex);
            }
          }

          valuePercent = stepIndex * (100 / this.stepsCount);

          if (this.dragData.stepIndex !== stepIndex) {
            this.dragData.stepIndex = stepIndex;
            this.dragData.offset = valuePercent;
            this.activeDragHandle.css(this.offsetProperty, this.dragData.offset + '%'); // update value(s) and trigger "input" event

            this.values[this.activeDragHandleIndex] = '' + this.stepIndexToValue(stepIndex);
            this.updateValues();
            this.realElement.trigger('input');
          }
        },
        onHandleRelease: function () {
          var newValue;

          if (typeof this.dragData.offset === 'number') {
            newValue = this.stepIndexToValue(this.dragData.stepIndex);
            this.realElement.val(newValue).trigger('change');
          }

          this.page.off({
            'jcf-pointermove': this.onHandleMove,
            'jcf-pointerup': this.onHandleRelease
          });
          delete this.activeDragHandle;
          delete this.dragData;
        },
        onFocus: function () {
          if (!this.fakeElement.hasClass(this.options.focusClass)) {
            this.fakeElement.addClass(this.options.focusClass);
            this.realElement.on({
              blur: this.onBlur,
              keydown: this.onKeyPress
            });
          }
        },
        onBlur: function () {
          this.fakeElement.removeClass(this.options.focusClass);
          this.realElement.off({
            blur: this.onBlur,
            keydown: this.onKeyPress
          });
        },
        onKeyPress: function (e) {
          var incValue = e.which === 38 || e.which === 39,
              decValue = e.which === 37 || e.which === 40; // handle TAB key in slider with multiple handles

          if (e.which === 9 && this.handleCount > 1) {
            if (e.shiftKey && this.activeDragHandleIndex > 0) {
              this.activeDragHandleIndex--;
            } else if (!e.shiftKey && this.activeDragHandleIndex < this.handleCount - 1) {
              this.activeDragHandleIndex++;
            } else {
              return;
            }

            e.preventDefault();
            this.handles.removeClass(this.options.activeHandleClass).eq(this.activeDragHandleIndex).addClass(this.options.activeHandleClass);
          } // handle cursor keys


          if (decValue || incValue) {
            e.preventDefault();
            this.step(incValue ? this.stepValue : -this.stepValue);
          }
        },
        updateValues: function () {
          var value = this.values.join(',');

          if (this.values.length > 1) {
            this.realElement.prop('valueLow', this.values[0]);
            this.realElement.prop('valueHigh', this.values[this.values.length - 1]);
            this.realElement.val(value); // if browser does not accept multiple values set only one

            if (this.realElement.val() !== value) {
              this.realElement.val(this.values[this.values.length - 1]);
            }
          } else {
            this.realElement.val(value);
          }

          this.updateRanges();
        },
        updateRanges: function () {
          // update display ranges
          var self = this,
              handle;

          if (this.rangeMin) {
            handle = this.handles[0];
            this.rangeMin.css(this.offsetProperty, 0).css(this.sizeProperty, handle.style[this.offsetProperty]);
          }

          if (this.rangeMax) {
            handle = this.handles[this.handles.length - 1];
            this.rangeMax.css(this.offsetProperty, handle.style[this.offsetProperty]).css(this.sizeProperty, 100 - parseFloat(handle.style[this.offsetProperty]) + '%');
          }

          if (this.rangeMid) {
            this.handles.each(function (index, curHandle) {
              var prevHandle, midBox;

              if (index > 0) {
                prevHandle = self.handles[index - 1];
                midBox = self.rangeMid[index - 1];
                midBox.style[self.offsetProperty] = prevHandle.style[self.offsetProperty];
                midBox.style[self.sizeProperty] = parseFloat(curHandle.style[self.offsetProperty]) - parseFloat(prevHandle.style[self.offsetProperty]) + '%';
              }
            });
          }
        },
        step: function (changeValue) {
          var originalValue = parseFloat(this.values[this.activeDragHandleIndex || 0]),
              newValue = originalValue,
              minValue = this.minValue,
              maxValue = this.maxValue;

          if (isNaN(originalValue)) {
            newValue = 0;
          }

          newValue += changeValue;

          if (this.handleCount > 1) {
            if (this.activeDragHandleIndex > 0) {
              minValue = parseFloat(this.values[this.activeDragHandleIndex - 1]) + this.options.minRange;
            }

            if (this.activeDragHandleIndex < this.handleCount - 1) {
              maxValue = parseFloat(this.values[this.activeDragHandleIndex + 1]) - this.options.minRange;
            }
          }

          if (newValue > maxValue) {
            newValue = maxValue;
          } else if (newValue < minValue) {
            newValue = minValue;
          }

          if (newValue !== originalValue) {
            this.values[this.activeDragHandleIndex || 0] = '' + newValue;
            this.updateValues();
            this.realElement.trigger('input').trigger('change');
            this.setSliderValue(this.values);
          }
        },
        valueToStepIndex: function (value) {
          return (value - this.minValue) / this.stepValue;
        },
        stepIndexToValue: function (stepIndex) {
          return this.minValue + this.stepValue * stepIndex;
        },
        valueToOffset: function (value) {
          var range = this.maxValue - this.minValue,
              percent = (value - this.minValue) / range;
          return percent * 100;
        },
        getSliderValue: function () {
          return $.map(this.values, function (value) {
            return parseFloat(value) || 0;
          });
        },
        setSliderValue: function (values) {
          // set handle position accordion according to value
          var self = this;
          this.handles.each(function (index, handle) {
            handle.style[self.offsetProperty] = self.valueToOffset(values[index]) + '%';
          });
        },
        refresh: function () {
          // handle disabled state
          var isDisabled = this.realElement.is(':disabled');
          this.fakeElement.toggleClass(this.options.disabledClass, isDisabled); // refresh handle position according to current value

          this.setSliderValue(this.getSliderValue());
          this.updateRanges();
        },
        destroy: function () {
          this.realElement.removeClass(this.options.hiddenClass).insertBefore(this.fakeElement);
          this.fakeElement.remove();
          this.realElement.off({
            keydown: this.onKeyPress,
            focus: this.onFocus,
            blur: this.onBlur
          });
        }
      };
    });
  })(jcf);

  /*!
   * JavaScript Custom Forms : Scrollbar Module
   *
   * Copyright 2014-2015 PSD2HTML - http://psd2html.com/jcf
   * Released under the MIT license (LICENSE.txt)
   *
   * Version: 1.2.3
   */
  (function (jcf) {
    jcf.addModule(function ($, window) {

      var module = {
        name: 'Scrollable',
        selector: '.jcf-scrollable',
        plugins: {
          ScrollBar: ScrollBar
        },
        options: {
          mouseWheelStep: 150,
          handleResize: true,
          alwaysShowScrollbars: false,
          alwaysPreventMouseWheel: false,
          scrollAreaStructure: '<div class="jcf-scrollable-wrapper"></div>'
        },
        matchElement: function (element) {
          return element.is('.jcf-scrollable');
        },
        init: function () {
          this.initStructure();
          this.attachEvents();
          this.rebuildScrollbars();
        },
        initStructure: function () {
          // prepare structure
          this.doc = $(document);
          this.win = $(window);
          this.realElement = $(this.options.element);
          this.scrollWrapper = $(this.options.scrollAreaStructure).insertAfter(this.realElement); // set initial styles

          this.scrollWrapper.css('position', 'relative');
          this.realElement.css('overflow', 'hidden');
          this.vBarEdge = 0;
        },
        attachEvents: function () {
          // create scrollbars
          var self = this;
          this.vBar = new ScrollBar({
            holder: this.scrollWrapper,
            vertical: true,
            onScroll: function (scrollTop) {
              self.realElement.scrollTop(scrollTop);
            }
          });
          this.hBar = new ScrollBar({
            holder: this.scrollWrapper,
            vertical: false,
            onScroll: function (scrollLeft) {
              self.realElement.scrollLeft(scrollLeft);
            }
          }); // add event handlers

          this.realElement.on('scroll', this.onScroll);

          if (this.options.handleResize) {
            this.win.on('resize orientationchange load', this.onResize);
          } // add pointer/wheel event handlers


          this.realElement.on('jcf-mousewheel', this.onMouseWheel);
          this.realElement.on('jcf-pointerdown', this.onTouchBody);
        },
        onScroll: function () {
          this.redrawScrollbars();
        },
        onResize: function () {
          // do not rebuild scrollbars if form field is in focus
          if (!$(document.activeElement).is(':input')) {
            this.rebuildScrollbars();
          }
        },
        onTouchBody: function (e) {
          if (e.pointerType === 'touch') {
            this.touchData = {
              scrollTop: this.realElement.scrollTop(),
              scrollLeft: this.realElement.scrollLeft(),
              left: e.pageX,
              top: e.pageY
            };
            this.doc.on({
              'jcf-pointermove': this.onMoveBody,
              'jcf-pointerup': this.onReleaseBody
            });
          }
        },
        onMoveBody: function (e) {
          var targetScrollTop,
              targetScrollLeft,
              verticalScrollAllowed = this.verticalScrollActive,
              horizontalScrollAllowed = this.horizontalScrollActive;

          if (e.pointerType === 'touch') {
            targetScrollTop = this.touchData.scrollTop - e.pageY + this.touchData.top;
            targetScrollLeft = this.touchData.scrollLeft - e.pageX + this.touchData.left; // check that scrolling is ended and release outer scrolling

            if (this.verticalScrollActive && (targetScrollTop < 0 || targetScrollTop > this.vBar.maxValue)) {
              verticalScrollAllowed = false;
            }

            if (this.horizontalScrollActive && (targetScrollLeft < 0 || targetScrollLeft > this.hBar.maxValue)) {
              horizontalScrollAllowed = false;
            }

            this.realElement.scrollTop(targetScrollTop);
            this.realElement.scrollLeft(targetScrollLeft);

            if (verticalScrollAllowed || horizontalScrollAllowed) {
              e.preventDefault();
            } else {
              this.onReleaseBody(e);
            }
          }
        },
        onReleaseBody: function (e) {
          if (e.pointerType === 'touch') {
            delete this.touchData;
            this.doc.off({
              'jcf-pointermove': this.onMoveBody,
              'jcf-pointerup': this.onReleaseBody
            });
          }
        },
        onMouseWheel: function (e) {
          var currentScrollTop = this.realElement.scrollTop(),
              currentScrollLeft = this.realElement.scrollLeft(),
              maxScrollTop = this.realElement.prop('scrollHeight') - this.embeddedDimensions.innerHeight,
              maxScrollLeft = this.realElement.prop('scrollWidth') - this.embeddedDimensions.innerWidth,
              extraLeft,
              extraTop,
              preventFlag; // check edge cases

          if (!this.options.alwaysPreventMouseWheel) {
            if (this.verticalScrollActive && e.deltaY) {
              if (!(currentScrollTop <= 0 && e.deltaY < 0) && !(currentScrollTop >= maxScrollTop && e.deltaY > 0)) {
                preventFlag = true;
              }
            }

            if (this.horizontalScrollActive && e.deltaX) {
              if (!(currentScrollLeft <= 0 && e.deltaX < 0) && !(currentScrollLeft >= maxScrollLeft && e.deltaX > 0)) {
                preventFlag = true;
              }
            }

            if (!this.verticalScrollActive && !this.horizontalScrollActive) {
              return;
            }
          } // prevent default action and scroll item


          if (preventFlag || this.options.alwaysPreventMouseWheel) {
            e.preventDefault();
          } else {
            return;
          }

          extraLeft = e.deltaX / 100 * this.options.mouseWheelStep;
          extraTop = e.deltaY / 100 * this.options.mouseWheelStep;
          this.realElement.scrollTop(currentScrollTop + extraTop);
          this.realElement.scrollLeft(currentScrollLeft + extraLeft);
        },
        setScrollBarEdge: function (edgeSize) {
          this.vBarEdge = edgeSize || 0;
          this.redrawScrollbars();
        },
        saveElementDimensions: function () {
          this.savedDimensions = {
            top: this.realElement.width(),
            left: this.realElement.height()
          };
          return this;
        },
        restoreElementDimensions: function () {
          if (this.savedDimensions) {
            this.realElement.css({
              width: this.savedDimensions.width,
              height: this.savedDimensions.height
            });
          }

          return this;
        },
        saveScrollOffsets: function () {
          this.savedOffsets = {
            top: this.realElement.scrollTop(),
            left: this.realElement.scrollLeft()
          };
          return this;
        },
        restoreScrollOffsets: function () {
          if (this.savedOffsets) {
            this.realElement.scrollTop(this.savedOffsets.top);
            this.realElement.scrollLeft(this.savedOffsets.left);
          }

          return this;
        },
        getContainerDimensions: function () {
          // save current styles
          var desiredDimensions, currentStyles, currentHeight, currentWidth;

          if (this.isModifiedStyles) {
            desiredDimensions = {
              width: this.realElement.innerWidth() + this.vBar.getThickness(),
              height: this.realElement.innerHeight() + this.hBar.getThickness()
            };
          } else {
            // unwrap real element and measure it according to CSS
            this.saveElementDimensions().saveScrollOffsets();
            this.realElement.insertAfter(this.scrollWrapper);
            this.scrollWrapper.detach(); // measure element

            currentStyles = this.realElement.prop('style');
            currentWidth = parseFloat(currentStyles.width);
            currentHeight = parseFloat(currentStyles.height); // reset styles if needed

            if (this.embeddedDimensions && currentWidth && currentHeight) {
              this.isModifiedStyles |= currentWidth !== this.embeddedDimensions.width || currentHeight !== this.embeddedDimensions.height;
              this.realElement.css({
                overflow: '',
                width: '',
                height: ''
              });
            } // calculate desired dimensions for real element


            desiredDimensions = {
              width: this.realElement.outerWidth(),
              height: this.realElement.outerHeight()
            }; // restore structure and original scroll offsets

            this.scrollWrapper.insertAfter(this.realElement);
            this.realElement.css('overflow', 'hidden').prependTo(this.scrollWrapper);
            this.restoreElementDimensions().restoreScrollOffsets();
          }

          return desiredDimensions;
        },
        getEmbeddedDimensions: function (dimensions) {
          // handle scrollbars cropping
          var fakeBarWidth = this.vBar.getThickness(),
              fakeBarHeight = this.hBar.getThickness(),
              paddingWidth = this.realElement.outerWidth() - this.realElement.width(),
              paddingHeight = this.realElement.outerHeight() - this.realElement.height(),
              resultDimensions;

          if (this.options.alwaysShowScrollbars) {
            // simply return dimensions without custom scrollbars
            this.verticalScrollActive = true;
            this.horizontalScrollActive = true;
            resultDimensions = {
              innerWidth: dimensions.width - fakeBarWidth,
              innerHeight: dimensions.height - fakeBarHeight
            };
          } else {
            // detect when to display each scrollbar
            this.saveElementDimensions();
            this.verticalScrollActive = false;
            this.horizontalScrollActive = false; // fill container with full size

            this.realElement.css({
              width: dimensions.width - paddingWidth,
              height: dimensions.height - paddingHeight
            });
            this.horizontalScrollActive = this.realElement.prop('scrollWidth') > this.containerDimensions.width;
            this.verticalScrollActive = this.realElement.prop('scrollHeight') > this.containerDimensions.height;
            this.restoreElementDimensions();
            resultDimensions = {
              innerWidth: dimensions.width - (this.verticalScrollActive ? fakeBarWidth : 0),
              innerHeight: dimensions.height - (this.horizontalScrollActive ? fakeBarHeight : 0)
            };
          }

          $.extend(resultDimensions, {
            width: resultDimensions.innerWidth - paddingWidth,
            height: resultDimensions.innerHeight - paddingHeight
          });
          return resultDimensions;
        },
        rebuildScrollbars: function () {
          // resize wrapper according to real element styles
          this.containerDimensions = this.getContainerDimensions();
          this.embeddedDimensions = this.getEmbeddedDimensions(this.containerDimensions); // resize wrapper to desired dimensions

          this.scrollWrapper.css({
            width: this.containerDimensions.width,
            height: this.containerDimensions.height
          }); // resize element inside wrapper excluding scrollbar size

          this.realElement.css({
            overflow: 'hidden',
            width: this.embeddedDimensions.width,
            height: this.embeddedDimensions.height
          }); // redraw scrollbar offset

          this.redrawScrollbars();
        },
        redrawScrollbars: function () {
          var viewSize, maxScrollValue; // redraw vertical scrollbar

          if (this.verticalScrollActive) {
            viewSize = this.vBarEdge ? this.containerDimensions.height - this.vBarEdge : this.embeddedDimensions.innerHeight;
            maxScrollValue = Math.max(this.realElement.prop('offsetHeight'), this.realElement.prop('scrollHeight')) - this.vBarEdge;
            this.vBar.show().setMaxValue(maxScrollValue - viewSize).setRatio(viewSize / maxScrollValue).setSize(viewSize);
            this.vBar.setValue(this.realElement.scrollTop());
          } else {
            this.vBar.hide();
          } // redraw horizontal scrollbar


          if (this.horizontalScrollActive) {
            viewSize = this.embeddedDimensions.innerWidth;
            maxScrollValue = this.realElement.prop('scrollWidth');

            if (maxScrollValue === viewSize) {
              this.horizontalScrollActive = false;
            }

            this.hBar.show().setMaxValue(maxScrollValue - viewSize).setRatio(viewSize / maxScrollValue).setSize(viewSize);
            this.hBar.setValue(this.realElement.scrollLeft());
          } else {
            this.hBar.hide();
          } // set "touch-action" style rule


          var touchAction = '';

          if (this.verticalScrollActive && this.horizontalScrollActive) {
            touchAction = 'none';
          } else if (this.verticalScrollActive) {
            touchAction = 'pan-x';
          } else if (this.horizontalScrollActive) {
            touchAction = 'pan-y';
          }

          this.realElement.css('touchAction', touchAction);
        },
        refresh: function () {
          this.rebuildScrollbars();
        },
        destroy: function () {
          // remove event listeners
          this.win.off('resize orientationchange load', this.onResize);
          this.realElement.off({
            'jcf-mousewheel': this.onMouseWheel,
            'jcf-pointerdown': this.onTouchBody
          });
          this.doc.off({
            'jcf-pointermove': this.onMoveBody,
            'jcf-pointerup': this.onReleaseBody
          }); // restore structure

          this.saveScrollOffsets();
          this.vBar.destroy();
          this.hBar.destroy();
          this.realElement.insertAfter(this.scrollWrapper).css({
            touchAction: '',
            overflow: '',
            width: '',
            height: ''
          });
          this.scrollWrapper.remove();
          this.restoreScrollOffsets();
        }
      }; // custom scrollbar

      function ScrollBar(options) {
        this.options = $.extend({
          holder: null,
          vertical: true,
          inactiveClass: 'jcf-inactive',
          verticalClass: 'jcf-scrollbar-vertical',
          horizontalClass: 'jcf-scrollbar-horizontal',
          scrollbarStructure: '<div class="jcf-scrollbar"><div class="jcf-scrollbar-dec"></div><div class="jcf-scrollbar-slider"><div class="jcf-scrollbar-handle"></div></div><div class="jcf-scrollbar-inc"></div></div>',
          btnDecSelector: '.jcf-scrollbar-dec',
          btnIncSelector: '.jcf-scrollbar-inc',
          sliderSelector: '.jcf-scrollbar-slider',
          handleSelector: '.jcf-scrollbar-handle',
          scrollInterval: 300,
          scrollStep: 400 // px/sec

        }, options);
        this.init();
      }

      $.extend(ScrollBar.prototype, {
        init: function () {
          this.initStructure();
          this.attachEvents();
        },
        initStructure: function () {
          // define proporties
          this.doc = $(document);
          this.isVertical = !!this.options.vertical;
          this.sizeProperty = this.isVertical ? 'height' : 'width';
          this.fullSizeProperty = this.isVertical ? 'outerHeight' : 'outerWidth';
          this.invertedSizeProperty = this.isVertical ? 'width' : 'height';
          this.thicknessMeasureMethod = 'outer' + this.invertedSizeProperty.charAt(0).toUpperCase() + this.invertedSizeProperty.substr(1);
          this.offsetProperty = this.isVertical ? 'top' : 'left';
          this.offsetEventProperty = this.isVertical ? 'pageY' : 'pageX'; // initialize variables

          this.value = this.options.value || 0;
          this.maxValue = this.options.maxValue || 0;
          this.currentSliderSize = 0;
          this.handleSize = 0; // find elements

          this.holder = $(this.options.holder);
          this.scrollbar = $(this.options.scrollbarStructure).appendTo(this.holder);
          this.btnDec = this.scrollbar.find(this.options.btnDecSelector);
          this.btnInc = this.scrollbar.find(this.options.btnIncSelector);
          this.slider = this.scrollbar.find(this.options.sliderSelector);
          this.handle = this.slider.find(this.options.handleSelector); // set initial styles

          this.scrollbar.addClass(this.isVertical ? this.options.verticalClass : this.options.horizontalClass).css({
            touchAction: this.isVertical ? 'pan-x' : 'pan-y',
            position: 'absolute'
          });
          this.slider.css({
            position: 'relative'
          });
          this.handle.css({
            touchAction: 'none',
            position: 'absolute'
          });
        },
        attachEvents: function () {
          this.bindHandlers();
          this.handle.on('jcf-pointerdown', this.onHandlePress);
          this.slider.add(this.btnDec).add(this.btnInc).on('jcf-pointerdown', this.onButtonPress);
        },
        onHandlePress: function (e) {
          if (e.pointerType === 'mouse' && e.button > 1) {
            return;
          } else {
            e.preventDefault();
            this.handleDragActive = true;
            this.sliderOffset = this.slider.offset()[this.offsetProperty];
            this.innerHandleOffset = e[this.offsetEventProperty] - this.handle.offset()[this.offsetProperty];
            this.doc.on('jcf-pointermove', this.onHandleDrag);
            this.doc.on('jcf-pointerup', this.onHandleRelease);
          }
        },
        onHandleDrag: function (e) {
          e.preventDefault();
          this.calcOffset = e[this.offsetEventProperty] - this.sliderOffset - this.innerHandleOffset;
          this.setValue(this.calcOffset / (this.currentSliderSize - this.handleSize) * this.maxValue);
          this.triggerScrollEvent(this.value);
        },
        onHandleRelease: function () {
          this.handleDragActive = false;
          this.doc.off('jcf-pointermove', this.onHandleDrag);
          this.doc.off('jcf-pointerup', this.onHandleRelease);
        },
        onButtonPress: function (e) {
          var direction, clickOffset;

          if (e.pointerType === 'mouse' && e.button > 1) {
            return;
          } else {
            e.preventDefault();

            if (!this.handleDragActive) {
              if (this.slider.is(e.currentTarget)) {
                // slider pressed
                direction = this.handle.offset()[this.offsetProperty] > e[this.offsetEventProperty] ? -1 : 1;
                clickOffset = e[this.offsetEventProperty] - this.slider.offset()[this.offsetProperty];
                this.startPageScrolling(direction, clickOffset);
              } else {
                // scrollbar buttons pressed
                direction = this.btnDec.is(e.currentTarget) ? -1 : 1;
                this.startSmoothScrolling(direction);
              }

              this.doc.on('jcf-pointerup', this.onButtonRelease);
            }
          }
        },
        onButtonRelease: function () {
          this.stopPageScrolling();
          this.stopSmoothScrolling();
          this.doc.off('jcf-pointerup', this.onButtonRelease);
        },
        startPageScrolling: function (direction, clickOffset) {
          var self = this,
              stepValue = direction * self.currentSize; // limit checker

          var isFinishedScrolling = function () {
            var handleTop = self.value / self.maxValue * (self.currentSliderSize - self.handleSize);

            if (direction > 0) {
              return handleTop + self.handleSize >= clickOffset;
            } else {
              return handleTop <= clickOffset;
            }
          }; // scroll by page when track is pressed


          var doPageScroll = function () {
            self.value += stepValue;
            self.setValue(self.value);
            self.triggerScrollEvent(self.value);

            if (isFinishedScrolling()) {
              clearInterval(self.pageScrollTimer);
            }
          }; // start scrolling


          this.pageScrollTimer = setInterval(doPageScroll, this.options.scrollInterval);
          doPageScroll();
        },
        stopPageScrolling: function () {
          clearInterval(this.pageScrollTimer);
        },
        startSmoothScrolling: function (direction) {
          var self = this,
              dt;
          this.stopSmoothScrolling(); // simple animation functions

          var raf = window.requestAnimationFrame || function (func) {
            setTimeout(func, 16);
          };

          var getTimestamp = function () {
            return Date.now ? Date.now() : new Date().getTime();
          }; // set animation limit


          var isFinishedScrolling = function () {
            if (direction > 0) {
              return self.value >= self.maxValue;
            } else {
              return self.value <= 0;
            }
          }; // animation step


          var doScrollAnimation = function () {
            var stepValue = (getTimestamp() - dt) / 1000 * self.options.scrollStep;

            if (self.smoothScrollActive) {
              self.value += stepValue * direction;
              self.setValue(self.value);
              self.triggerScrollEvent(self.value);

              if (!isFinishedScrolling()) {
                dt = getTimestamp();
                raf(doScrollAnimation);
              }
            }
          }; // start animation


          self.smoothScrollActive = true;
          dt = getTimestamp();
          raf(doScrollAnimation);
        },
        stopSmoothScrolling: function () {
          this.smoothScrollActive = false;
        },
        triggerScrollEvent: function (scrollValue) {
          if (this.options.onScroll) {
            this.options.onScroll(scrollValue);
          }
        },
        getThickness: function () {
          return this.scrollbar[this.thicknessMeasureMethod]();
        },
        setSize: function (size) {
          // resize scrollbar
          var btnDecSize = this.btnDec[this.fullSizeProperty](),
              btnIncSize = this.btnInc[this.fullSizeProperty](); // resize slider

          this.currentSize = size;
          this.currentSliderSize = size - btnDecSize - btnIncSize;
          this.scrollbar.css(this.sizeProperty, size);
          this.slider.css(this.sizeProperty, this.currentSliderSize);
          this.currentSliderSize = this.slider[this.sizeProperty](); // resize handle

          this.handleSize = Math.round(this.currentSliderSize * this.ratio);
          this.handle.css(this.sizeProperty, this.handleSize);
          this.handleSize = this.handle[this.fullSizeProperty]();
          return this;
        },
        setRatio: function (ratio) {
          this.ratio = ratio;
          return this;
        },
        setMaxValue: function (maxValue) {
          this.maxValue = maxValue;
          this.setValue(Math.min(this.value, this.maxValue));
          return this;
        },
        setValue: function (value) {
          this.value = value;

          if (this.value < 0) {
            this.value = 0;
          } else if (this.value > this.maxValue) {
            this.value = this.maxValue;
          }

          this.refresh();
        },
        setPosition: function (styles) {
          this.scrollbar.css(styles);
          return this;
        },
        hide: function () {
          this.scrollbar.detach();
          return this;
        },
        show: function () {
          this.scrollbar.appendTo(this.holder);
          return this;
        },
        refresh: function () {
          // recalculate handle position
          if (this.value === 0 || this.maxValue === 0) {
            this.calcOffset = 0;
          } else {
            this.calcOffset = this.value / this.maxValue * (this.currentSliderSize - this.handleSize);
          }

          this.handle.css(this.offsetProperty, this.calcOffset); // toggle inactive classes

          this.btnDec.toggleClass(this.options.inactiveClass, this.value === 0);
          this.btnInc.toggleClass(this.options.inactiveClass, this.value === this.maxValue);
          this.scrollbar.toggleClass(this.options.inactiveClass, this.maxValue === 0);
        },
        destroy: function () {
          // remove event handlers and scrollbar block itself
          this.btnDec.add(this.btnInc).off('jcf-pointerdown', this.onButtonPress);
          this.handle.off('jcf-pointerdown', this.onHandlePress);
          this.doc.off('jcf-pointermove', this.onHandleDrag);
          this.doc.off('jcf-pointerup', this.onHandleRelease);
          this.doc.off('jcf-pointerup', this.onButtonRelease);
          this.stopSmoothScrolling();
          this.stopPageScrolling();
          this.scrollbar.remove();
        }
      });
      return module;
    });
  })(jcf);

  /*!
   * JavaScript Custom Forms : Textarea Module
   *
   * Copyright 2014-2015 PSD2HTML - http://psd2html.com/jcf
   * Released under the MIT license (LICENSE.txt)
   *
   * Version: 1.2.3
   */
  (function (jcf) {
    jcf.addModule(function ($) {

      return {
        name: 'Textarea',
        selector: 'textarea',
        options: {
          resize: true,
          resizerStructure: '<span class="jcf-resize"></span>',
          fakeStructure: '<span class="jcf-textarea"></span>'
        },
        matchElement: function (element) {
          return element.is('textarea');
        },
        init: function () {
          this.initStructure();
          this.attachEvents();
          this.refresh();
        },
        initStructure: function () {
          // prepare structure
          this.doc = $(document);
          this.realElement = $(this.options.element);
          this.fakeElement = $(this.options.fakeStructure).insertAfter(this.realElement);
          this.resizer = $(this.options.resizerStructure).appendTo(this.fakeElement); // add custom scrollbar

          if (jcf.modules.Scrollable) {
            this.realElement.prependTo(this.fakeElement).addClass().css({
              overflow: 'hidden',
              resize: 'none'
            });
            this.scrollable = new jcf.modules.Scrollable({
              element: this.realElement,
              alwaysShowScrollbars: true
            });
            this.scrollable.setScrollBarEdge(this.resizer.outerHeight());
          }
        },
        attachEvents: function () {
          // add event handlers
          this.realElement.on({
            focus: this.onFocus,
            keyup: this.onChange,
            change: this.onChange
          });
          this.resizer.on('jcf-pointerdown', this.onResizePress);
        },
        onResizePress: function (e) {
          var resizerOffset = this.resizer.offset(),
              areaOffset = this.fakeElement.offset();
          e.preventDefault();
          this.dragData = {
            areaOffset: areaOffset,
            innerOffsetLeft: e.pageX - resizerOffset.left,
            innerOffsetTop: e.pageY - resizerOffset.top
          };
          this.doc.on({
            'jcf-pointermove': this.onResizeMove,
            'jcf-pointerup': this.onResizeRelease
          }); // restore focus

          if (this.isFocused) {
            this.focusedDrag = true;
            this.realElement.focus();
          }
        },
        onResizeMove: function (e) {
          var newWidth = e.pageX + this.dragData.innerOffsetLeft - this.dragData.areaOffset.left,
              newHeight = e.pageY + this.dragData.innerOffsetTop - this.dragData.areaOffset.top,
              widthDiff = this.fakeElement.innerWidth() - this.realElement.innerWidth(); // prevent text selection or page scroll on touch devices

          e.preventDefault(); // resize textarea and refresh scrollbars

          this.realElement.innerWidth(newWidth - widthDiff).innerHeight(newHeight);

          if (this.scrollable) {
            this.scrollable.rebuildScrollbars();
          } // restore focus


          if (this.focusedDrag) {
            this.realElement.focus();
          }
        },
        onResizeRelease: function () {
          this.doc.off({
            'jcf-pointermove': this.onResizeMove,
            'jcf-pointerup': this.onResizeRelease
          });
          delete this.focusedDrag;
        },
        onFocus: function () {
          this.isFocused = true;
          this.fakeElement.addClass(this.options.focusClass);
          this.realElement.on('blur', this.onBlur);
        },
        onBlur: function () {
          this.isFocused = false;
          this.fakeElement.removeClass(this.options.focusClass);
          this.realElement.off('blur', this.onBlur);
        },
        onChange: function () {
          this.refreshCustomScrollbars();
        },
        refreshCustomScrollbars: function () {
          if (this.scrollable) {
            if (this.isFocused) {
              this.scrollable.redrawScrollbars();
            } else {
              this.scrollable.rebuildScrollbars();
            }
          }
        },
        refresh: function () {
          // refresh custom scroll position
          var isDisabled = this.realElement.is(':disabled');
          this.fakeElement.toggleClass(this.options.disabledClass, isDisabled);
          this.refreshCustomScrollbars();
        },
        destroy: function () {
          // destroy custom scrollbar
          this.scrollable.destroy(); // restore styles and remove event listeners

          this.realElement.css({
            overflow: '',
            resize: ''
          }).insertBefore(this.fakeElement).off({
            focus: this.onFocus,
            blur: this.onBlur
          }); // remove scrollbar and fake wrapper

          this.fakeElement.remove();
        }
      };
    });
  })(jcf);

  $(document).ready(function () {
    jcf.setOptions('Select', {
      wrapNative: false,
      wrapNativeOnMobile: true,
      maxVisibleItems: 5,
      multipleCompactStyle: true
    });
    $('.jcf').not(".Taxonomy__select,.primary__subject").each(function () {
      jcf.replace($(this));
    });
    jcf.setOptions('Select', {
      maxVisibleItems: 12
    });
    jcf.replace('.Taxonomy__select');
    jcf.setOptions('Select', {
      maxVisibleItems: 10
    });
    jcf.replace('.primary__subject');
  });

  /**
   * @license jquery.panzoom.js v3.2.2
   * Updated: Sat Aug 27 2016
   * Add pan and zoom functionality to any element
   * Copyright (c) timmy willison
   * Released under the MIT license
   * https://github.com/timmywil/jquery.panzoom/blob/master/MIT-License.txt
   */
  (function (global, factory) {
    // AMD

    /*if (typeof define === 'function' && define.amd) {
    	define([ 'jquery' ], function(jQuery) {
    		return factory(global, jQuery);
    	});
    // CommonJS/Browserify
    } else if (typeof exports === 'object') {
    	factory(global, require('jquery'));
    // Global
    } else {
    	factory(global, global.jQuery);
    }*/
    factory(global, global.jQuery);
  })(typeof window !== 'undefined' ? window : window, function (window, $) {

    var document = window.document;
    var datakey = '__pz__';
    var slice = Array.prototype.slice;
    var rIE11 = /trident\/7./i;

    var supportsInputEvent = function () {
      // IE11 returns a false positive
      if (rIE11.test(navigator.userAgent)) {
        return false;
      }

      var input = document.createElement('input');
      input.setAttribute('oninput', 'return');
      return typeof input.oninput === 'function';
    }(); // Regex


    var rupper = /([A-Z])/g;
    var rsvg = /^http:[\w\.\/]+svg$/;
    var floating = '(\\-?\\d[\\d\\.e-]*)';
    var commaSpace = '\\,?\\s*';
    var rmatrix = new RegExp('^matrix\\(' + floating + commaSpace + floating + commaSpace + floating + commaSpace + floating + commaSpace + floating + commaSpace + floating + '\\)$');
    /**
     * Utility for determining transform matrix equality
     * Checks backwards to test translation first
     * @param {Array} first
     * @param {Array} second
     */

    function matrixEquals(first, second) {
      var i = first.length;

      while (--i) {
        if (Math.round(+first[i]) !== Math.round(+second[i])) {
          return false;
        }
      }

      return true;
    }
    /**
     * Creates the options object for reset functions
     * @param {Boolean|Object} opts See reset methods
     * @returns {Object} Returns the newly-created options object
     */


    function createResetOptions(opts) {
      var options = {
        range: true,
        animate: true
      };

      if (typeof opts === 'boolean') {
        options.animate = opts;
      } else {
        $.extend(options, opts);
      }

      return options;
    }
    /**
     * Represent a transformation matrix with a 3x3 matrix for calculations
     * Matrix functions adapted from Louis Remi's jQuery.transform (https://github.com/louisremi/jquery.transform.js)
     * @param {Array|Number} a An array of six values representing a 2d transformation matrix
     */


    function Matrix(a, b, c, d, e, f, g, h, i) {
      if ($.type(a) === 'array') {
        this.elements = [+a[0], +a[2], +a[4], +a[1], +a[3], +a[5], 0, 0, 1];
      } else {
        this.elements = [a, b, c, d, e, f, g || 0, h || 0, i || 1];
      }
    }

    Matrix.prototype = {
      /**
       * Multiply a 3x3 matrix by a similar matrix or a vector
       * @param {Matrix|Vector} matrix
       * @return {Matrix|Vector} Returns a vector if multiplying by a vector
       */
      x: function (matrix) {
        var isVector = matrix instanceof Vector;
        var a = this.elements,
            b = matrix.elements;

        if (isVector && b.length === 3) {
          // b is actually a vector
          return new Vector(a[0] * b[0] + a[1] * b[1] + a[2] * b[2], a[3] * b[0] + a[4] * b[1] + a[5] * b[2], a[6] * b[0] + a[7] * b[1] + a[8] * b[2]);
        } else if (b.length === a.length) {
          // b is a 3x3 matrix
          return new Matrix(a[0] * b[0] + a[1] * b[3] + a[2] * b[6], a[0] * b[1] + a[1] * b[4] + a[2] * b[7], a[0] * b[2] + a[1] * b[5] + a[2] * b[8], a[3] * b[0] + a[4] * b[3] + a[5] * b[6], a[3] * b[1] + a[4] * b[4] + a[5] * b[7], a[3] * b[2] + a[4] * b[5] + a[5] * b[8], a[6] * b[0] + a[7] * b[3] + a[8] * b[6], a[6] * b[1] + a[7] * b[4] + a[8] * b[7], a[6] * b[2] + a[7] * b[5] + a[8] * b[8]);
        }

        return false; // fail
      },

      /**
       * Generates an inverse of the current matrix
       * @returns {Matrix}
       */
      inverse: function () {
        var d = 1 / this.determinant(),
            a = this.elements;
        return new Matrix(d * (a[8] * a[4] - a[7] * a[5]), d * -(a[8] * a[1] - a[7] * a[2]), d * (a[5] * a[1] - a[4] * a[2]), d * -(a[8] * a[3] - a[6] * a[5]), d * (a[8] * a[0] - a[6] * a[2]), d * -(a[5] * a[0] - a[3] * a[2]), d * (a[7] * a[3] - a[6] * a[4]), d * -(a[7] * a[0] - a[6] * a[1]), d * (a[4] * a[0] - a[3] * a[1]));
      },

      /**
       * Calculates the determinant of the current matrix
       * @returns {Number}
       */
      determinant: function () {
        var a = this.elements;
        return a[0] * (a[8] * a[4] - a[7] * a[5]) - a[3] * (a[8] * a[1] - a[7] * a[2]) + a[6] * (a[5] * a[1] - a[4] * a[2]);
      }
    };
    /**
     * Create a vector containing three values
     */

    function Vector(x, y, z) {
      this.elements = [x, y, z];
    }
    /**
     * Get the element at zero-indexed index i
     * @param {Number} i
     */


    Vector.prototype.e = Matrix.prototype.e = function (i) {
      return this.elements[i];
    };
    /**
     * Create a Panzoom object for a given element
     * @constructor
     * @param {Element} elem - Element to use pan and zoom
     * @param {Object} [options] - An object literal containing options to override default options
     *  (See Panzoom.defaults for ones not listed below)
     * @param {jQuery} [options.$zoomIn] - zoom in buttons/links collection (you can also bind these yourself
     *  e.g. $button.on('click', function(e) { e.preventDefault(); $elem.panzoom('zoomIn'); });)
     * @param {jQuery} [options.$zoomOut] - zoom out buttons/links collection on which to bind zoomOut
     * @param {jQuery} [options.$zoomRange] - zoom in/out with this range control
     * @param {jQuery} [options.$reset] - Reset buttons/links collection on which to bind the reset method
     * @param {Function} [options.on[Start|Change|Zoom|Pan|End|Reset] - Optional callbacks for panzoom events
     */


    function Panzoom(elem, options) {
      // Allow instantiation without `new` keyword
      if (!(this instanceof Panzoom)) {
        return new Panzoom(elem, options);
      } // Sanity checks


      if (elem.nodeType !== 1) {
        $.error('Panzoom called on non-Element node');
      }

      if (!$.contains(document, elem)) {
        $.error('Panzoom element must be attached to the document');
      } // Don't remake


      var d = $.data(elem, datakey);

      if (d) {
        return d;
      } // Extend default with given object literal
      // Each instance gets its own options


      this.options = options = $.extend({}, Panzoom.defaults, options);
      this.elem = elem;
      var $elem = this.$elem = $(elem);
      this.$set = options.$set && options.$set.length ? options.$set : $elem;
      this.$doc = $(elem.ownerDocument || document);
      this.$parent = $elem.parent();
      this.parent = this.$parent[0]; // This is SVG if the namespace is SVG
      // However, while <svg> elements are SVG, we want to treat those like other elements

      this.isSVG = rsvg.test(elem.namespaceURI) && elem.nodeName.toLowerCase() !== 'svg';
      this.panning = false; // Save the original transform value
      // Save the prefixed transform style key
      // Set the starting transform

      this._buildTransform(); // Build the appropriately-prefixed transform style property name
      // De-camelcase


      this._transform = $.cssProps.transform.replace(rupper, '-$1').toLowerCase(); // Build the transition value

      this._buildTransition(); // Build containment dimensions


      this.resetDimensions(); // Add zoom and reset buttons to `this`

      var $empty = $();
      var self = this;
      $.each(['$zoomIn', '$zoomOut', '$zoomRange', '$reset'], function (i, name) {
        self[name] = options[name] || $empty;
      });
      this.enable();
      this.scale = this.getMatrix()[0];

      this._checkPanWhenZoomed(); // Save the instance


      $.data(elem, datakey, this);
    } // Attach regex for possible use (immutable)


    Panzoom.rmatrix = rmatrix;
    Panzoom.defaults = {
      // Should always be non-empty
      // Used to bind jQuery events without collisions
      // A guid is not added here as different instantiations/versions of panzoom
      // on the same element is not supported, so don't do it.
      eventNamespace: '.panzoom',
      // Whether or not to transition the scale
      transition: true,
      // Default cursor style for the element
      cursor: 'move',
      // There may be some use cases for zooming without panning or vice versa
      disablePan: false,
      disableZoom: false,
      // Pan only on the X or Y axes
      disableXAxis: false,
      disableYAxis: false,
      // Set whether you'd like to pan on left (1), middle (2), or right click (3)
      which: 1,
      // The increment at which to zoom
      // adds/subtracts to the scale each time zoomIn/Out is called
      increment: 0.3,
      // Turns on exponential zooming
      // If false, zooming will be incremented linearly
      exponential: true,
      // Pan only when the scale is greater than minScale
      panOnlyWhenZoomed: false,
      // min and max zoom scales
      minScale: 0.3,
      maxScale: 6,
      // The default step for the range input
      // Precendence: default < HTML attribute < option setting
      rangeStep: 0.05,
      // Animation duration (ms)
      duration: 200,
      // CSS easing used for scale transition
      easing: 'ease-in-out',
      // Indicate that the element should be contained within it's parent when panning
      // Note: this does not affect zooming outside of the parent
      // Set this value to 'invert' to only allow panning outside of the parent element (basically the opposite of the normal use of contain)
      // 'invert' is useful for a large panzoom element where you don't want to show anything behind it
      contain: false
    };
    Panzoom.prototype = {
      constructor: Panzoom,

      /**
       * @returns {Panzoom} Returns the instance
       */
      instance: function () {
        return this;
      },

      /**
       * Enable or re-enable the panzoom instance
       */
      enable: function () {
        // Unbind first
        this._initStyle();

        this._bind();

        this.disabled = false;
      },

      /**
       * Disable panzoom
       */
      disable: function () {
        this.disabled = true;

        this._resetStyle();

        this._unbind();
      },

      /**
       * @returns {Boolean} Returns whether the current panzoom instance is disabled
       */
      isDisabled: function () {
        return this.disabled;
      },

      /**
       * Destroy the panzoom instance
       */
      destroy: function () {
        this.disable();
        $.removeData(this.elem, datakey);
      },

      /**
       * Builds the restricing dimensions from the containment element
       * Also used with focal points
       * Call this method whenever the dimensions of the element or parent are changed
       */
      resetDimensions: function () {
        // Reset container properties
        this.container = this.parent.getBoundingClientRect(); // Set element properties

        var elem = this.elem; // getBoundingClientRect() works with SVG, offsetWidth does not

        var dims = elem.getBoundingClientRect();
        var absScale = Math.abs(this.scale);
        this.dimensions = {
          width: dims.width,
          height: dims.height,
          left: $.css(elem, 'left', true) || 0,
          top: $.css(elem, 'top', true) || 0,
          // Borders and margins are scaled
          border: {
            top: $.css(elem, 'borderTopWidth', true) * absScale || 0,
            bottom: $.css(elem, 'borderBottomWidth', true) * absScale || 0,
            left: $.css(elem, 'borderLeftWidth', true) * absScale || 0,
            right: $.css(elem, 'borderRightWidth', true) * absScale || 0
          },
          margin: {
            top: $.css(elem, 'marginTop', true) * absScale || 0,
            left: $.css(elem, 'marginLeft', true) * absScale || 0
          }
        };
      },

      /**
       * Return the element to it's original transform matrix
       * @param {Boolean} [options] If a boolean is passed, animate the reset (default: true). If an options object is passed, simply pass that along to setMatrix.
       * @param {Boolean} [options.silent] Silence the reset event
       */
      reset: function (options) {
        options = createResetOptions(options); // Reset the transform to its original value

        var matrix = this.setMatrix(this._origTransform, options);

        if (!options.silent) {
          this._trigger('reset', matrix);
        }
      },

      /**
       * Only resets zoom level
       * @param {Boolean|Object} [options] Whether to animate the reset (default: true) or an object of options to pass to zoom()
       */
      resetZoom: function (options) {
        options = createResetOptions(options);
        var origMatrix = this.getMatrix(this._origTransform);
        options.dValue = origMatrix[3];
        this.zoom(origMatrix[0], options);
      },

      /**
       * Only reset panning
       * @param {Boolean|Object} [options] Whether to animate the reset (default: true) or an object of options to pass to pan()
       */
      resetPan: function (options) {
        var origMatrix = this.getMatrix(this._origTransform);
        this.pan(origMatrix[4], origMatrix[5], createResetOptions(options));
      },

      /**
       * Sets a transform on the $set
       * For SVG, the style attribute takes precedence
       * and allows us to animate
       * @param {String} transform
       */
      setTransform: function (transform) {
        var $set = this.$set;
        var i = $set.length;

        while (i--) {
          $.style($set[i], 'transform', transform); // Support IE9-11, Edge 13-14+
          // Set attribute alongside style attribute
          // since IE and Edge do not respect style settings on SVG
          // See https://css-tricks.com/transforms-on-svg-elements/

          if (this.isSVG) {
            $set[i].setAttribute('transform', transform);
          }
        }
      },

      /**
       * Retrieving the transform is different for SVG
       *  (unless a style transform is already present)
       * Uses the $set collection for retrieving the transform
       * @param {String} [transform] Pass in an transform value (like 'scale(1.1)')
       *  to have it formatted into matrix format for use by Panzoom
       * @returns {String} Returns the current transform value of the element
       */
      getTransform: function (transform) {
        var $set = this.$set;
        var transformElem = $set[0];

        if (transform) {
          this.setTransform(transform);
        } else {
          // IE and Edge still set the transform style properly
          // They just don't render it on SVG
          // So we get a correct value here
          transform = $.style(transformElem, 'transform');

          if (this.isSVG && (!transform || transform === 'none')) {
            transform = $.attr(transformElem, 'transform') || 'none';
          }
        } // Convert any transforms set by the user to matrix format
        // by setting to computed


        if (transform !== 'none' && !rmatrix.test(transform)) {
          // Get computed and set for next time
          this.setTransform(transform = $.css(transformElem, 'transform'));
        }

        return transform || 'none';
      },

      /**
       * Retrieve the current transform matrix for $elem (or turn a transform into it's array values)
       * @param {String} [transform] matrix-formatted transform value
       * @returns {Array} Returns the current transform matrix split up into it's parts, or a default matrix
       */
      getMatrix: function (transform) {
        var matrix = rmatrix.exec(transform || this.getTransform());

        if (matrix) {
          matrix.shift();
        }

        return matrix || [1, 0, 0, 1, 0, 0];
      },

      /**
       * Given a matrix object, quickly set the current matrix of the element
       * @param {Array|String} matrix
       * @param {Object} [options]
       * @param {Boolean|String} [options.animate] Whether to animate the transform change, or 'skip' indicating that it is unnecessary to set
       * @param {Boolean} [options.contain] Override the global contain option
       * @param {Boolean} [options.range] If true, $zoomRange's value will be updated.
       * @param {Boolean} [options.silent] If true, the change event will not be triggered
       * @returns {Array} Returns the newly-set matrix
       */
      setMatrix: function (matrix, options) {
        if (this.disabled) {
          return;
        }

        if (!options) {
          options = {};
        } // Convert to array


        if (typeof matrix === 'string') {
          matrix = this.getMatrix(matrix);
        }

        var scale = +matrix[0];
        var contain = typeof options.contain !== 'undefined' ? options.contain : this.options.contain; // Apply containment

        if (contain) {
          var dims = options.dims;

          if (!dims) {
            this.resetDimensions();
            dims = this.dimensions;
          }

          var spaceWLeft, spaceWRight, scaleDiff;
          var container = this.container;
          var width = dims.width;
          var height = dims.height;
          var conWidth = container.width;
          var conHeight = container.height;
          var zoomAspectW = conWidth / width;
          var zoomAspectH = conHeight / height; // If the element is not naturally centered,
          // assume full space right

          if (this.$parent.css('textAlign') !== 'center' || $.css(this.elem, 'display') !== 'inline') {
            // offsetWidth gets us the width without the transform
            scaleDiff = (width - this.elem.offsetWidth) / 2;
            spaceWLeft = scaleDiff - dims.border.left;
            spaceWRight = width - conWidth - scaleDiff + dims.border.right;
          } else {
            spaceWLeft = spaceWRight = (width - conWidth) / 2;
          }

          var spaceHTop = (height - conHeight) / 2 + dims.border.top;
          var spaceHBottom = (height - conHeight) / 2 - dims.border.top - dims.border.bottom;

          if (contain === 'invert' || contain === 'automatic' && zoomAspectW < 1.01) {
            matrix[4] = Math.max(Math.min(matrix[4], spaceWLeft - dims.border.left), -spaceWRight);
          } else {
            matrix[4] = Math.min(Math.max(matrix[4], spaceWLeft), -spaceWRight);
          }

          if (contain === 'invert' || contain === 'automatic' && zoomAspectH < 1.01) {
            matrix[5] = Math.max(Math.min(matrix[5], spaceHTop - dims.border.top), -spaceHBottom);
          } else {
            matrix[5] = Math.min(Math.max(matrix[5], spaceHTop), -spaceHBottom);
          }
        } // Animate


        if (options.animate !== 'skip') {
          // Set transition
          this.transition(!options.animate);
        } // Update range element


        if (options.range) {
          this.$zoomRange.val(scale);
        } // Set the matrix on this.$set


        if (this.options.disableXAxis || this.options.disableYAxis) {
          var originalMatrix = this.getMatrix();

          if (this.options.disableXAxis) {
            matrix[4] = originalMatrix[4];
          }

          if (this.options.disableYAxis) {
            matrix[5] = originalMatrix[5];
          }
        }

        this.setTransform('matrix(' + matrix.join(',') + ')');
        this.scale = scale; // Disable/enable panning if zooming is at minimum and panOnlyWhenZoomed is true

        this._checkPanWhenZoomed(scale);

        if (!options.silent) {
          this._trigger('change', matrix);
        }

        return matrix;
      },

      /**
       * @returns {Boolean} Returns whether the panzoom element is currently being dragged
       */
      isPanning: function () {
        return this.panning;
      },

      /**
       * Apply the current transition to the element, if allowed
       * @param {Boolean} [off] Indicates that the transition should be turned off
       */
      transition: function (off) {
        if (!this._transition) {
          return;
        }

        var transition = off || !this.options.transition ? 'none' : this._transition;
        var $set = this.$set;
        var i = $set.length;

        while (i--) {
          // Avoid reflows when zooming
          if ($.style($set[i], 'transition') !== transition) {
            $.style($set[i], 'transition', transition);
          }
        }
      },

      /**
       * Pan the element to the specified translation X and Y
       * Note: this is not the same as setting jQuery#offset() or jQuery#position()
       * @param {Number} x
       * @param {Number} y
       * @param {Object} [options] These options are passed along to setMatrix
       * @param {Array} [options.matrix] The matrix being manipulated (if already known so it doesn't have to be retrieved again)
       * @param {Boolean} [options.silent] Silence the pan event. Note that this will also silence the setMatrix change event.
       * @param {Boolean} [options.relative] Make the x and y values relative to the existing matrix
       */
      pan: function (x, y, options) {
        if (this.options.disablePan) {
          return;
        }

        if (!options) {
          options = {};
        }

        var matrix = options.matrix;

        if (!matrix) {
          matrix = this.getMatrix();
        } // Cast existing matrix values to numbers


        if (options.relative) {
          x += +matrix[4];
          y += +matrix[5];
        }

        matrix[4] = x;
        matrix[5] = y;
        this.setMatrix(matrix, options);

        if (!options.silent) {
          this._trigger('pan', matrix[4], matrix[5]);
        }
      },

      /**
       * Zoom in/out the element using the scale properties of a transform matrix
       * @param {Number|Boolean} [scale] The scale to which to zoom or a boolean indicating to transition a zoom out
       * @param {Object} [opts] All global options can be overwritten by this options object. For example, override the default increment.
       * @param {Boolean} [opts.noSetRange] Specify that the method should not set the $zoomRange value (as is the case when $zoomRange is calling zoom on change)
       * @param {jQuery.Event|Object} [opts.focal] A focal point on the panzoom element on which to zoom.
       *  If an object, set the clientX and clientY properties to the position relative to the parent
       * @param {Boolean} [opts.animate] Whether to animate the zoom (defaults to true if scale is not a number, false otherwise)
       * @param {Boolean} [opts.silent] Silence the zoom event
       * @param {Array} [opts.matrix] Optionally pass the current matrix so it doesn't need to be retrieved
       * @param {Number} [opts.dValue] Think of a transform matrix as four values a, b, c, d
       *  where a/d are the horizontal/vertical scale values and b/c are the skew values
       *  (5 and 6 of matrix array are the tx/ty transform values).
       *  Normally, the scale is set to both the a and d values of the matrix.
       *  This option allows you to specify a different d value for the zoom.
       *  For instance, to flip vertically, you could set -1 as the dValue.
       */
      zoom: function (scale, opts) {
        // Shuffle arguments
        if (typeof scale === 'object') {
          opts = scale;
          scale = null;
        } else if (!opts) {
          opts = {};
        }

        var options = $.extend({}, this.options, opts); // Check if disabled

        if (options.disableZoom) {
          return;
        }

        var animate = false;
        var matrix = options.matrix || this.getMatrix();
        var startScale = +matrix[0]; // Calculate zoom based on increment

        if (typeof scale !== 'number') {
          // Just use a number a little greater than 1
          // Below 1 can use normal increments
          if (options.exponential && startScale - options.increment >= 1) {
            scale = Math[scale ? 'sqrt' : 'pow'](startScale, 2);
          } else {
            scale = startScale + options.increment * (scale ? -1 : 1);
          }

          animate = true;
        } // Constrain scale


        if (scale > options.maxScale) {
          scale = options.maxScale;
        } else if (scale < options.minScale) {
          scale = options.minScale;
        } // Calculate focal point based on scale


        var focal = options.focal;

        if (focal && !options.disablePan) {
          // Adapted from code by Florian Günther
          // https://github.com/florianguenther/zui53
          this.resetDimensions();
          var dims = options.dims = this.dimensions;
          var clientX = focal.clientX;
          var clientY = focal.clientY; // Adjust the focal point for transform-origin 50% 50%
          // SVG elements have a transform origin of 0 0

          if (!this.isSVG) {
            clientX -= dims.width / startScale / 2;
            clientY -= dims.height / startScale / 2;
          }

          var clientV = new Vector(clientX, clientY, 1);
          var surfaceM = new Matrix(matrix); // Supply an offset manually if necessary

          var o = this.parentOffset || this.$parent.offset();
          var offsetM = new Matrix(1, 0, o.left - this.$doc.scrollLeft(), 0, 1, o.top - this.$doc.scrollTop());
          var surfaceV = surfaceM.inverse().x(offsetM.inverse().x(clientV));
          var scaleBy = scale / matrix[0];
          surfaceM = surfaceM.x(new Matrix([scaleBy, 0, 0, scaleBy, 0, 0]));
          clientV = offsetM.x(surfaceM.x(surfaceV));
          matrix[4] = +matrix[4] + (clientX - clientV.e(0));
          matrix[5] = +matrix[5] + (clientY - clientV.e(1));
        } // Set the scale


        matrix[0] = scale;
        matrix[3] = typeof options.dValue === 'number' ? options.dValue : scale; // Calling zoom may still pan the element

        this.setMatrix(matrix, {
          animate: typeof options.animate !== 'undefined' ? options.animate : animate,
          // Set the zoomRange value
          range: !options.noSetRange
        }); // Trigger zoom event

        if (!options.silent) {
          this._trigger('zoom', matrix[0], options);
        }
      },

      /**
       * Get/set option on an existing instance
       * @returns {Array|undefined} If getting, returns an array of all values
       *   on each instance for a given key. If setting, continue chaining by returning undefined.
       */
      option: function (key, value) {
        var options;

        if (!key) {
          // Avoids returning direct reference
          return $.extend({}, this.options);
        }

        if (typeof key === 'string') {
          if (arguments.length === 1) {
            return this.options[key] !== undefined ? this.options[key] : null;
          }

          options = {};
          options[key] = value;
        } else {
          options = key;
        }

        this._setOptions(options);
      },

      /**
       * Internally sets options
       * @param {Object} options - An object literal of options to set
       * @private
       */
      _setOptions: function (options) {
        $.each(options, $.proxy(function (key, value) {
          switch (key) {
            case 'disablePan':
              this._resetStyle();

            /* falls through */

            case '$zoomIn':
            case '$zoomOut':
            case '$zoomRange':
            case '$reset':
            case 'disableZoom':
            case 'onStart':
            case 'onChange':
            case 'onZoom':
            case 'onPan':
            case 'onEnd':
            case 'onReset':
            case 'eventNamespace':
              this._unbind();

          }

          this.options[key] = value;

          switch (key) {
            case 'disablePan':
              this._initStyle();

            /* falls through */

            case '$zoomIn':
            case '$zoomOut':
            case '$zoomRange':
            case '$reset':
              // Set these on the instance
              this[key] = value;

            /* falls through */

            case 'disableZoom':
            case 'onStart':
            case 'onChange':
            case 'onZoom':
            case 'onPan':
            case 'onEnd':
            case 'onReset':
            case 'eventNamespace':
              this._bind();

              break;

            case 'cursor':
              $.style(this.elem, 'cursor', value);
              break;

            case 'minScale':
              this.$zoomRange.attr('min', value);
              break;

            case 'maxScale':
              this.$zoomRange.attr('max', value);
              break;

            case 'rangeStep':
              this.$zoomRange.attr('step', value);
              break;

            case 'startTransform':
              this._buildTransform();

              break;

            case 'duration':
            case 'easing':
              this._buildTransition();

            /* falls through */

            case 'transition':
              this.transition();
              break;

            case 'panOnlyWhenZoomed':
              this._checkPanWhenZoomed();

              break;

            case '$set':
              if (value instanceof $ && value.length) {
                this.$set = value; // Reset styles

                this._initStyle();

                this._buildTransform();
              }

          }
        }, this));
      },

      /**
       * Disable/enable panning depending on whether the current scale
       * matches the minimum
       * @param {Number} [scale]
       * @private
       */
      _checkPanWhenZoomed: function (scale) {
        var options = this.options;

        if (options.panOnlyWhenZoomed) {
          if (!scale) {
            scale = this.getMatrix()[0];
          }

          var toDisable = scale <= options.minScale;

          if (options.disablePan !== toDisable) {
            this.option('disablePan', toDisable);
          }
        }
      },

      /**
       * Initialize base styles for the element and its parent
       * @private
       */
      _initStyle: function () {
        var styles = {
          // Set the same default whether SVG or HTML
          // transform-origin cannot be changed to 50% 50% in IE9-11 or Edge 13-14+
          'transform-origin': this.isSVG ? '0 0' : '50% 50%'
        }; // Set elem styles

        if (!this.options.disablePan) {
          styles.cursor = this.options.cursor;
        }

        this.$set.css(styles); // Set parent to relative if set to static

        var $parent = this.$parent; // No need to add styles to the body

        if ($parent.length && !$.nodeName(this.parent, 'body')) {
          styles = {
            overflow: 'hidden'
          };

          if ($parent.css('position') === 'static') {
            styles.position = 'relative';
          }

          $parent.css(styles);
        }
      },

      /**
       * Undo any styles attached in this plugin
       * @private
       */
      _resetStyle: function () {
        this.$elem.css({
          'cursor': '',
          'transition': ''
        });
        this.$parent.css({
          'overflow': '',
          'position': ''
        });
      },

      /**
       * Binds all necessary events
       * @private
       */
      _bind: function () {
        var self = this;
        var options = this.options;
        var ns = options.eventNamespace;
        var str_down = 'mousedown' + ns + ' pointerdown' + ns + ' MSPointerDown' + ns;
        var str_start = 'touchstart' + ns + ' ' + str_down;
        var str_click = 'touchend' + ns + ' click' + ns + ' pointerup' + ns + ' MSPointerUp' + ns;
        var events = {};
        var $reset = this.$reset;
        var $zoomRange = this.$zoomRange; // Bind panzoom events from options

        $.each(['Start', 'Change', 'Zoom', 'Pan', 'End', 'Reset'], function () {
          var m = options['on' + this];

          if ($.isFunction(m)) {
            events['panzoom' + this.toLowerCase() + ns] = m;
          }
        }); // Bind $elem drag and click/touchdown events
        // Bind touchstart if either panning or zooming is enabled

        if (!options.disablePan || !options.disableZoom) {
          events[str_start] = function (e) {
            var touches;

            if (e.type === 'touchstart' ? // Touch
            (touches = e.touches || e.originalEvent.touches) && (touches.length === 1 && !options.disablePan || touches.length === 2) : // Mouse/Pointer: Ignore unexpected click types
            // Support: IE10 only
            // IE10 does not support e.button for MSPointerDown, but does have e.which
            !options.disablePan && (e.which || e.originalEvent.which) === options.which) {
              e.preventDefault();
              e.stopPropagation();

              self._startMove(e, touches);
            }
          }; // Prevent the contextmenu event
          // if we're binding to right-click


          if (options.which === 3) {
            events.contextmenu = false;
          }
        }

        this.$elem.on(events); // Bind reset

        if ($reset.length) {
          $reset.on(str_click, function (e) {
            e.preventDefault();
            self.reset();
          });
        } // Set default attributes for the range input


        if ($zoomRange.length) {
          $zoomRange.attr({
            // Only set the range step if explicit or
            // set the default if there is no attribute present
            step: options.rangeStep === Panzoom.defaults.rangeStep && $zoomRange.attr('step') || options.rangeStep,
            min: options.minScale,
            max: options.maxScale
          }).prop({
            value: this.getMatrix()[0]
          });
        } // No bindings if zooming is disabled


        if (options.disableZoom) {
          return;
        }

        var $zoomIn = this.$zoomIn;
        var $zoomOut = this.$zoomOut; // Bind zoom in/out
        // Don't bind one without the other

        if ($zoomIn.length && $zoomOut.length) {
          // preventDefault cancels future mouse events on touch events
          $zoomIn.on(str_click, function (e) {
            e.preventDefault();
            self.zoom();
          });
          $zoomOut.on(str_click, function (e) {
            e.preventDefault();
            self.zoom(true);
          });
        }

        if ($zoomRange.length) {
          events = {}; // Cannot prevent default action here

          events[str_down] = function () {
            self.transition(true);
          }; // Zoom on input events if available and change events
          // See https://github.com/timmywil/jquery.panzoom/issues/90


          events[(supportsInputEvent ? 'input' : 'change') + ns] = function () {
            self.zoom(+this.value, {
              noSetRange: true
            });
          };

          $zoomRange.on(events);
        }
      },

      /**
       * Unbind all events
       * @private
       */
      _unbind: function () {
        this.$elem.add(this.$zoomIn).add(this.$zoomOut).add(this.$reset).off(this.options.eventNamespace);
      },

      /**
       * Builds the original transform value
       * @private
       */
      _buildTransform: function () {
        // Save the original transform
        // Retrieving this also adds the correct prefixed style name
        // to jQuery's internal $.cssProps
        return this._origTransform = this.getTransform(this.options.startTransform);
      },

      /**
       * Set transition property for later use when zooming
       * @private
       */
      _buildTransition: function () {
        if (this._transform) {
          var options = this.options;
          this._transition = this._transform + ' ' + options.duration + 'ms ' + options.easing;
        }
      },

      /**
       * Calculates the distance between two touch points
       * Remember pythagorean?
       * @param {Array} touches
       * @returns {Number} Returns the distance
       * @private
       */
      _getDistance: function (touches) {
        var touch1 = touches[0];
        var touch2 = touches[1];
        return Math.sqrt(Math.pow(Math.abs(touch2.clientX - touch1.clientX), 2) + Math.pow(Math.abs(touch2.clientY - touch1.clientY), 2));
      },

      /**
       * Constructs an approximated point in the middle of two touch points
       * @returns {Object} Returns an object containing pageX and pageY
       * @private
       */
      _getMiddle: function (touches) {
        var touch1 = touches[0];
        var touch2 = touches[1];
        return {
          clientX: (touch2.clientX - touch1.clientX) / 2 + touch1.clientX,
          clientY: (touch2.clientY - touch1.clientY) / 2 + touch1.clientY
        };
      },

      /**
       * Trigger a panzoom event on our element
       * The event is passed the Panzoom instance
       * @param {String|jQuery.Event} event
       * @param {Mixed} arg1[, arg2, arg3, ...] Arguments to append to the trigger
       * @private
       */
      _trigger: function (event) {
        if (typeof event === 'string') {
          event = 'panzoom' + event;
        }

        this.$elem.triggerHandler(event, [this].concat(slice.call(arguments, 1)));
      },

      /**
       * Starts the pan
       * This is bound to mouse/touchmove on the element
       * @param {jQuery.Event} event An event with pageX, pageY, and possibly the touches list
       * @param {TouchList} [touches] The touches list if present
       * @private
       */
      _startMove: function (event, touches) {
        if (this.panning) {
          return;
        }

        var moveEvent, endEvent, startDistance, startScale, startMiddle, startPageX, startPageY, touch;
        var self = this;
        var options = this.options;
        var ns = options.eventNamespace;
        var matrix = this.getMatrix();
        var original = matrix.slice(0);
        var origPageX = +original[4];
        var origPageY = +original[5];
        var panOptions = {
          matrix: matrix,
          animate: 'skip'
        };
        var type = event.type; // Use proper events

        if (type === 'pointerdown') {
          moveEvent = 'pointermove';
          endEvent = 'pointerup';
        } else if (type === 'touchstart') {
          moveEvent = 'touchmove';
          endEvent = 'touchend';
        } else if (type === 'MSPointerDown') {
          moveEvent = 'MSPointerMove';
          endEvent = 'MSPointerUp';
        } else {
          moveEvent = 'mousemove';
          endEvent = 'mouseup';
        } // Add namespace


        moveEvent += ns;
        endEvent += ns; // Remove any transitions happening

        this.transition(true); // Indicate that we are currently panning

        this.panning = true; // Trigger start event

        this._trigger('start', event, touches);

        var setStart = function (event, touches) {
          if (touches) {
            if (touches.length === 2) {
              if (startDistance != null) {
                return;
              }

              startDistance = self._getDistance(touches);
              startScale = +matrix[0];
              startMiddle = self._getMiddle(touches);
              return;
            }

            if (startPageX != null) {
              return;
            }

            if (touch = touches[0]) {
              startPageX = touch.pageX;
              startPageY = touch.pageY;
            }
          }

          if (startPageX != null) {
            return;
          }

          startPageX = event.pageX;
          startPageY = event.pageY;
        };

        setStart(event, touches);

        var move = function (e) {
          var coords;
          e.preventDefault();
          touches = e.touches || e.originalEvent.touches;
          setStart(e, touches);

          if (touches) {
            if (touches.length === 2) {
              // Calculate move on middle point
              var middle = self._getMiddle(touches);

              var diff = self._getDistance(touches) - startDistance; // Set zoom

              self.zoom(diff * (options.increment / 100) + startScale, {
                focal: middle,
                matrix: matrix,
                animate: 'skip'
              }); // Set pan

              self.pan(+matrix[4] + middle.clientX - startMiddle.clientX, +matrix[5] + middle.clientY - startMiddle.clientY, panOptions);
              startMiddle = middle;
              return;
            }

            coords = touches[0] || {
              pageX: 0,
              pageY: 0
            };
          }

          if (!coords) {
            coords = e;
          }

          self.pan(origPageX + coords.pageX - startPageX, origPageY + coords.pageY - startPageY, panOptions);
        }; // Bind the handlers


        $(document).off(ns).on(moveEvent, move).on(endEvent, function (e) {
          e.preventDefault(); // Unbind all document events

          $(this).off(ns);
          self.panning = false; // Trigger our end event
          // Simply set the type to "panzoomend" to pass through all end properties
          // jQuery's `not` is used here to compare Array equality

          e.type = 'panzoomend';

          self._trigger(e, matrix, !matrixEquals(matrix, original));
        });
      }
    }; // Add Panzoom as a static property

    $.Panzoom = Panzoom;
    /**
     * Extend jQuery
     * @param {Object|String} options - The name of a method to call on the prototype
     *  or an object literal of options
     * @returns {jQuery|Mixed} jQuery instance for regular chaining or the return value(s) of a panzoom method call
     */

    $.fn.panzoom = function (options) {
      var instance, args, m, ret; // Call methods widget-style

      if (typeof options === 'string') {
        ret = [];
        args = slice.call(arguments, 1);
        this.each(function () {
          instance = $.data(this, datakey);

          if (!instance) {
            ret.push(undefined); // Ignore methods beginning with `_`
          } else if (options.charAt(0) !== '_' && typeof (m = instance[options]) === 'function' && // If nothing is returned, do not add to return values
          (m = m.apply(instance, args)) !== undefined) {
            ret.push(m);
          }
        }); // Return an array of values for the jQuery instances
        // Or the value itself if there is only one
        // Or keep chaining

        return ret.length ? ret.length === 1 ? ret[0] : ret : this;
      }

      return this.each(function () {
        new Panzoom(this, options);
      });
    };

    return Panzoom;
  });

  /*! jQuery UI - v1.12.1 - 2018-04-24
  * http://jqueryui.com
  * Includes: widget.js, data.js, jquery-1-7.js, keycode.js, scroll-parent.js, widgets/sortable.js, widgets/datepicker.js, widgets/mouse.js, widgets/slider.js
  * Copyright jQuery Foundation and other contributors; Licensed MIT */
  (function (factory) {
    // if ( typeof define === "function" && define.amd ) {
    //
    // 	// AMD. Register as an anonymous module.
    // 	define([ "jquery" ], factory );
    // } else {
    // Browser globals
    factory(jQuery); //}
  })(function ($) {
    $.ui = $.ui || {};
    var version = $.ui.version = "1.12.1";
    /*!
     * jQuery UI Widget 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    //>>label: Widget
    //>>group: Core
    //>>description: Provides a factory for creating stateful widgets with a common API.
    //>>docs: http://api.jqueryui.com/jQuery.widget/
    //>>demos: http://jqueryui.com/widget/

    var widgetUuid = 0;
    var widgetSlice = Array.prototype.slice;

    $.cleanData = function (orig) {
      return function (elems) {
        var events, elem, i;

        for (i = 0; (elem = elems[i]) != null; i++) {
          try {
            // Only trigger remove when necessary to save time
            events = $._data(elem, "events");

            if (events && events.remove) {
              $(elem).triggerHandler("remove");
            } // Http://bugs.jquery.com/ticket/8235

          } catch (e) {}
        }

        orig(elems);
      };
    }($.cleanData);

    $.widget = function (name, base, prototype) {
      var existingConstructor, constructor, basePrototype; // ProxiedPrototype allows the provided prototype to remain unmodified
      // so that it can be used as a mixin for multiple widgets (#8876)

      var proxiedPrototype = {};
      var namespace = name.split(".")[0];
      name = name.split(".")[1];
      var fullName = namespace + "-" + name;

      if (!prototype) {
        prototype = base;
        base = $.Widget;
      }

      if ($.isArray(prototype)) {
        prototype = $.extend.apply(null, [{}].concat(prototype));
      } // Create selector for plugin


      $.expr[":"][fullName.toLowerCase()] = function (elem) {
        return !!$.data(elem, fullName);
      };

      $[namespace] = $[namespace] || {};
      existingConstructor = $[namespace][name];

      constructor = $[namespace][name] = function (options, element) {
        // Allow instantiation without "new" keyword
        if (!this._createWidget) {
          return new constructor(options, element);
        } // Allow instantiation without initializing for simple inheritance
        // must use "new" keyword (the code above always passes args)


        if (arguments.length) {
          this._createWidget(options, element);
        }
      }; // Extend with the existing constructor to carry over any static properties


      $.extend(constructor, existingConstructor, {
        version: prototype.version,
        // Copy the object used to create the prototype in case we need to
        // redefine the widget later
        _proto: $.extend({}, prototype),
        // Track widgets that inherit from this widget in case this widget is
        // redefined after a widget inherits from it
        _childConstructors: []
      });
      basePrototype = new base(); // We need to make the options hash a property directly on the new instance
      // otherwise we'll modify the options hash on the prototype that we're
      // inheriting from

      basePrototype.options = $.widget.extend({}, basePrototype.options);
      $.each(prototype, function (prop, value) {
        if (!$.isFunction(value)) {
          proxiedPrototype[prop] = value;
          return;
        }

        proxiedPrototype[prop] = function () {
          function _super() {
            return base.prototype[prop].apply(this, arguments);
          }

          function _superApply(args) {
            return base.prototype[prop].apply(this, args);
          }

          return function () {
            var __super = this._super;
            var __superApply = this._superApply;
            var returnValue;
            this._super = _super;
            this._superApply = _superApply;
            returnValue = value.apply(this, arguments);
            this._super = __super;
            this._superApply = __superApply;
            return returnValue;
          };
        }();
      });
      constructor.prototype = $.widget.extend(basePrototype, {
        // TODO: remove support for widgetEventPrefix
        // always use the name + a colon as the prefix, e.g., draggable:start
        // don't prefix for widgets that aren't DOM-based
        widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name
      }, proxiedPrototype, {
        constructor: constructor,
        namespace: namespace,
        widgetName: name,
        widgetFullName: fullName
      }); // If this widget is being redefined then we need to find all widgets that
      // are inheriting from it and redefine all of them so that they inherit from
      // the new version of this widget. We're essentially trying to replace one
      // level in the prototype chain.

      if (existingConstructor) {
        $.each(existingConstructor._childConstructors, function (i, child) {
          var childPrototype = child.prototype; // Redefine the child widget using the same prototype that was
          // originally used, but inherit from the new version of the base

          $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
        }); // Remove the list of existing child constructors from the old constructor
        // so the old child constructors can be garbage collected

        delete existingConstructor._childConstructors;
      } else {
        base._childConstructors.push(constructor);
      }

      $.widget.bridge(name, constructor);
      return constructor;
    };

    $.widget.extend = function (target) {
      var input = widgetSlice.call(arguments, 1);
      var inputIndex = 0;
      var inputLength = input.length;
      var key;
      var value;

      for (; inputIndex < inputLength; inputIndex++) {
        for (key in input[inputIndex]) {
          value = input[inputIndex][key];

          if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
            // Clone objects
            if ($.isPlainObject(value)) {
              target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : // Don't extend strings, arrays, etc. with objects
              $.widget.extend({}, value); // Copy everything else by reference
            } else {
              target[key] = value;
            }
          }
        }
      }

      return target;
    };

    $.widget.bridge = function (name, object) {
      var fullName = object.prototype.widgetFullName || name;

      $.fn[name] = function (options) {
        var isMethodCall = typeof options === "string";
        var args = widgetSlice.call(arguments, 1);
        var returnValue = this;

        if (isMethodCall) {
          // If this is an empty collection, we need to have the instance method
          // return undefined instead of the jQuery instance
          if (!this.length && options === "instance") {
            returnValue = undefined;
          } else {
            this.each(function () {
              var methodValue;
              var instance = $.data(this, fullName);

              if (options === "instance") {
                returnValue = instance;
                return false;
              }

              if (!instance) {
                return $.error("cannot call methods on " + name + " prior to initialization; " + "attempted to call method '" + options + "'");
              }

              if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                return $.error("no such method '" + options + "' for " + name + " widget instance");
              }

              methodValue = instance[options].apply(instance, args);

              if (methodValue !== instance && methodValue !== undefined) {
                returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
                return false;
              }
            });
          }
        } else {
          // Allow multiple hashes to be passed on init
          if (args.length) {
            options = $.widget.extend.apply(null, [options].concat(args));
          }

          this.each(function () {
            var instance = $.data(this, fullName);

            if (instance) {
              instance.option(options || {});

              if (instance._init) {
                instance._init();
              }
            } else {
              $.data(this, fullName, new object(options, this));
            }
          });
        }

        return returnValue;
      };
    };

    $.Widget = function ()
    /* options, element */
    {};

    $.Widget._childConstructors = [];
    $.Widget.prototype = {
      widgetName: "widget",
      widgetEventPrefix: "",
      defaultElement: "<div>",
      options: {
        classes: {},
        disabled: false,
        // Callbacks
        create: null
      },
      _createWidget: function (options, element) {
        element = $(element || this.defaultElement || this)[0];
        this.element = $(element);
        this.uuid = widgetUuid++;
        this.eventNamespace = "." + this.widgetName + this.uuid;
        this.bindings = $();
        this.hoverable = $();
        this.focusable = $();
        this.classesElementLookup = {};

        if (element !== this) {
          $.data(element, this.widgetFullName, this);

          this._on(true, this.element, {
            remove: function (event) {
              if (event.target === element) {
                this.destroy();
              }
            }
          });

          this.document = $(element.style ? // Element within the document
          element.ownerDocument : // Element is window or document
          element.document || element);
          this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
        }

        this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);

        this._create();

        if (this.options.disabled) {
          this._setOptionDisabled(this.options.disabled);
        }

        this._trigger("create", null, this._getCreateEventData());

        this._init();
      },
      _getCreateOptions: function () {
        return {};
      },
      _getCreateEventData: $.noop,
      _create: $.noop,
      _init: $.noop,
      destroy: function () {
        var that = this;

        this._destroy();

        $.each(this.classesElementLookup, function (key, value) {
          that._removeClass(value, key);
        }); // We can probably remove the unbind calls in 2.0
        // all event bindings should go through this._on()

        this.element.off(this.eventNamespace).removeData(this.widgetFullName);
        this.widget().off(this.eventNamespace).removeAttr("aria-disabled"); // Clean up events and states

        this.bindings.off(this.eventNamespace);
      },
      _destroy: $.noop,
      widget: function () {
        return this.element;
      },
      option: function (key, value) {
        var options = key;
        var parts;
        var curOption;
        var i;

        if (arguments.length === 0) {
          // Don't return a reference to the internal hash
          return $.widget.extend({}, this.options);
        }

        if (typeof key === "string") {
          // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
          options = {};
          parts = key.split(".");
          key = parts.shift();

          if (parts.length) {
            curOption = options[key] = $.widget.extend({}, this.options[key]);

            for (i = 0; i < parts.length - 1; i++) {
              curOption[parts[i]] = curOption[parts[i]] || {};
              curOption = curOption[parts[i]];
            }

            key = parts.pop();

            if (arguments.length === 1) {
              return curOption[key] === undefined ? null : curOption[key];
            }

            curOption[key] = value;
          } else {
            if (arguments.length === 1) {
              return this.options[key] === undefined ? null : this.options[key];
            }

            options[key] = value;
          }
        }

        this._setOptions(options);

        return this;
      },
      _setOptions: function (options) {
        var key;

        for (key in options) {
          this._setOption(key, options[key]);
        }

        return this;
      },
      _setOption: function (key, value) {
        if (key === "classes") {
          this._setOptionClasses(value);
        }

        this.options[key] = value;

        if (key === "disabled") {
          this._setOptionDisabled(value);
        }

        return this;
      },
      _setOptionClasses: function (value) {
        var classKey, elements, currentElements;

        for (classKey in value) {
          currentElements = this.classesElementLookup[classKey];

          if (value[classKey] === this.options.classes[classKey] || !currentElements || !currentElements.length) {
            continue;
          } // We are doing this to create a new jQuery object because the _removeClass() call
          // on the next line is going to destroy the reference to the current elements being
          // tracked. We need to save a copy of this collection so that we can add the new classes
          // below.


          elements = $(currentElements.get());

          this._removeClass(currentElements, classKey); // We don't use _addClass() here, because that uses this.options.classes
          // for generating the string of classes. We want to use the value passed in from
          // _setOption(), this is the new value of the classes option which was passed to
          // _setOption(). We pass this value directly to _classes().


          elements.addClass(this._classes({
            element: elements,
            keys: classKey,
            classes: value,
            add: true
          }));
        }
      },
      _setOptionDisabled: function (value) {
        this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!value); // If the widget is becoming disabled, then nothing is interactive


        if (value) {
          this._removeClass(this.hoverable, null, "ui-state-hover");

          this._removeClass(this.focusable, null, "ui-state-focus");
        }
      },
      enable: function () {
        return this._setOptions({
          disabled: false
        });
      },
      disable: function () {
        return this._setOptions({
          disabled: true
        });
      },
      _classes: function (options) {
        var full = [];
        var that = this;
        options = $.extend({
          element: this.element,
          classes: this.options.classes || {}
        }, options);

        function processClassString(classes, checkOption) {
          var current, i;

          for (i = 0; i < classes.length; i++) {
            current = that.classesElementLookup[classes[i]] || $();

            if (options.add) {
              current = $($.unique(current.get().concat(options.element.get())));
            } else {
              current = $(current.not(options.element).get());
            }

            that.classesElementLookup[classes[i]] = current;
            full.push(classes[i]);

            if (checkOption && options.classes[classes[i]]) {
              full.push(options.classes[classes[i]]);
            }
          }
        }

        this._on(options.element, {
          "remove": "_untrackClassesElement"
        });

        if (options.keys) {
          processClassString(options.keys.match(/\S+/g) || [], true);
        }

        if (options.extra) {
          processClassString(options.extra.match(/\S+/g) || []);
        }

        return full.join(" ");
      },
      _untrackClassesElement: function (event) {
        var that = this;
        $.each(that.classesElementLookup, function (key, value) {
          if ($.inArray(event.target, value) !== -1) {
            that.classesElementLookup[key] = $(value.not(event.target).get());
          }
        });
      },
      _removeClass: function (element, keys, extra) {
        return this._toggleClass(element, keys, extra, false);
      },
      _addClass: function (element, keys, extra) {
        return this._toggleClass(element, keys, extra, true);
      },
      _toggleClass: function (element, keys, extra, add) {
        add = typeof add === "boolean" ? add : extra;
        var shift = typeof element === "string" || element === null,
            options = {
          extra: shift ? keys : extra,
          keys: shift ? element : keys,
          element: shift ? this.element : element,
          add: add
        };
        options.element.toggleClass(this._classes(options), add);
        return this;
      },
      _on: function (suppressDisabledCheck, element, handlers) {
        var delegateElement;
        var instance = this; // No suppressDisabledCheck flag, shuffle arguments

        if (typeof suppressDisabledCheck !== "boolean") {
          handlers = element;
          element = suppressDisabledCheck;
          suppressDisabledCheck = false;
        } // No element argument, shuffle and use this.element


        if (!handlers) {
          handlers = element;
          element = this.element;
          delegateElement = this.widget();
        } else {
          element = delegateElement = $(element);
          this.bindings = this.bindings.add(element);
        }

        $.each(handlers, function (event, handler) {
          function handlerProxy() {
            // Allow widgets to customize the disabled handling
            // - disabled as an array instead of boolean
            // - disabled class as method for disabling individual parts
            if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass("ui-state-disabled"))) {
              return;
            }

            return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
          } // Copy the guid so direct unbinding works


          if (typeof handler !== "string") {
            handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
          }

          var match = event.match(/^([\w:-]*)\s*(.*)$/);
          var eventName = match[1] + instance.eventNamespace;
          var selector = match[2];

          if (selector) {
            delegateElement.on(eventName, selector, handlerProxy);
          } else {
            element.on(eventName, handlerProxy);
          }
        });
      },
      _off: function (element, eventName) {
        eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
        element.off(eventName).off(eventName); // Clear the stack to avoid memory leaks (#10056)

        this.bindings = $(this.bindings.not(element).get());
        this.focusable = $(this.focusable.not(element).get());
        this.hoverable = $(this.hoverable.not(element).get());
      },
      _delay: function (handler, delay) {
        function handlerProxy() {
          return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
        }

        var instance = this;
        return setTimeout(handlerProxy, delay || 0);
      },
      _hoverable: function (element) {
        this.hoverable = this.hoverable.add(element);

        this._on(element, {
          mouseenter: function (event) {
            this._addClass($(event.currentTarget), null, "ui-state-hover");
          },
          mouseleave: function (event) {
            this._removeClass($(event.currentTarget), null, "ui-state-hover");
          }
        });
      },
      _focusable: function (element) {
        this.focusable = this.focusable.add(element);

        this._on(element, {
          focusin: function (event) {
            this._addClass($(event.currentTarget), null, "ui-state-focus");
          },
          focusout: function (event) {
            this._removeClass($(event.currentTarget), null, "ui-state-focus");
          }
        });
      },
      _trigger: function (type, event, data) {
        var prop, orig;
        var callback = this.options[type];
        data = data || {};
        event = $.Event(event);
        event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase(); // The original event may come from any element
        // so we need to reset the target on the new event

        event.target = this.element[0]; // Copy original event properties over to the new event

        orig = event.originalEvent;

        if (orig) {
          for (prop in orig) {
            if (!(prop in event)) {
              event[prop] = orig[prop];
            }
          }
        }

        this.element.trigger(event, data);
        return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());
      }
    };
    $.each({
      show: "fadeIn",
      hide: "fadeOut"
    }, function (method, defaultEffect) {
      $.Widget.prototype["_" + method] = function (element, options, callback) {
        if (typeof options === "string") {
          options = {
            effect: options
          };
        }

        var hasOptions;
        var effectName = !options ? method : options === true || typeof options === "number" ? defaultEffect : options.effect || defaultEffect;
        options = options || {};

        if (typeof options === "number") {
          options = {
            duration: options
          };
        }

        hasOptions = !$.isEmptyObject(options);
        options.complete = callback;

        if (options.delay) {
          element.delay(options.delay);
        }

        if (hasOptions && $.effects && $.effects.effect[effectName]) {
          element[method](options);
        } else if (effectName !== method && element[effectName]) {
          element[effectName](options.duration, options.easing, callback);
        } else {
          element.queue(function (next) {
            $(this)[method]();

            if (callback) {
              callback.call(element[0]);
            }

            next();
          });
        }
      };
    });
    var widget = $.widget;
    /*!
     * jQuery UI :data 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    //>>label: :data Selector
    //>>group: Core
    //>>description: Selects elements which have data stored under the specified key.
    //>>docs: http://api.jqueryui.com/data-selector/

    var data = $.extend($.expr[":"], {
      data: $.expr.createPseudo ? $.expr.createPseudo(function (dataName) {
        return function (elem) {
          return !!$.data(elem, dataName);
        };
      }) : // Support: jQuery <1.8
      function (elem, i, match) {
        return !!$.data(elem, match[3]);
      }
    });
    /*!
     * jQuery UI Support for jQuery core 1.7.x 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     */
    //>>label: jQuery 1.7 Support
    //>>group: Core
    //>>description: Support version 1.7.x of jQuery core
    // Support: jQuery 1.7 only
    // Not a great way to check versions, but since we only support 1.7+ and only
    // need to detect <1.8, this is a simple check that should suffice. Checking
    // for "1.7." would be a bit safer, but the version string is 1.7, not 1.7.0
    // and we'll never reach 1.70.0 (if we do, we certainly won't be supporting
    // 1.7 anymore). See #11197 for why we're not using feature detection.

    if ($.fn.jquery.substring(0, 3) === "1.7") {
      // Setters for .innerWidth(), .innerHeight(), .outerWidth(), .outerHeight()
      // Unlike jQuery Core 1.8+, these only support numeric values to set the
      // dimensions in pixels
      $.each(["Width", "Height"], function (i, name) {
        var side = name === "Width" ? ["Left", "Right"] : ["Top", "Bottom"],
            type = name.toLowerCase(),
            orig = {
          innerWidth: $.fn.innerWidth,
          innerHeight: $.fn.innerHeight,
          outerWidth: $.fn.outerWidth,
          outerHeight: $.fn.outerHeight
        };

        function reduce(elem, size, border, margin) {
          $.each(side, function () {
            size -= parseFloat($.css(elem, "padding" + this)) || 0;

            if (border) {
              size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
            }

            if (margin) {
              size -= parseFloat($.css(elem, "margin" + this)) || 0;
            }
          });
          return size;
        }

        $.fn["inner" + name] = function (size) {
          if (size === undefined) {
            return orig["inner" + name].call(this);
          }

          return this.each(function () {
            $(this).css(type, reduce(this, size) + "px");
          });
        };

        $.fn["outer" + name] = function (size, margin) {
          if (typeof size !== "number") {
            return orig["outer" + name].call(this, size);
          }

          return this.each(function () {
            $(this).css(type, reduce(this, size, true, margin) + "px");
          });
        };
      });

      $.fn.addBack = function (selector) {
        return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
      };
    }
    /*!
     * jQuery UI Keycode 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    //>>label: Keycode
    //>>group: Core
    //>>description: Provide keycodes as keynames
    //>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/

    var keycode = $.ui.keyCode = {
      BACKSPACE: 8,
      COMMA: 188,
      DELETE: 46,
      DOWN: 40,
      END: 35,
      ENTER: 13,
      ESCAPE: 27,
      HOME: 36,
      LEFT: 37,
      PAGE_DOWN: 34,
      PAGE_UP: 33,
      PERIOD: 190,
      RIGHT: 39,
      SPACE: 32,
      TAB: 9,
      UP: 38
    };
    /*!
     * jQuery UI Scroll Parent 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    //>>label: scrollParent
    //>>group: Core
    //>>description: Get the closest ancestor element that is scrollable.
    //>>docs: http://api.jqueryui.com/scrollParent/

    var scrollParent = $.fn.scrollParent = function (includeHidden) {
      var position = this.css("position"),
          excludeStaticParent = position === "absolute",
          overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
          scrollParent = this.parents().filter(function () {
        var parent = $(this);

        if (excludeStaticParent && parent.css("position") === "static") {
          return false;
        }

        return overflowRegex.test(parent.css("overflow") + parent.css("overflow-y") + parent.css("overflow-x"));
      }).eq(0);
      return position === "fixed" || !scrollParent.length ? $(this[0].ownerDocument || document) : scrollParent;
    }; // This file is deprecated


    var ie = $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
    /*!
     * jQuery UI Mouse 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    //>>label: Mouse
    //>>group: Widgets
    //>>description: Abstracts mouse-based interactions to assist in creating certain widgets.
    //>>docs: http://api.jqueryui.com/mouse/

    var mouseHandled = false;
    $(document).on("mouseup", function () {
      mouseHandled = false;
    });
    var widgetsMouse = $.widget("ui.mouse", {
      version: "1.12.1",
      options: {
        cancel: "input, textarea, button, select, option",
        distance: 1,
        delay: 0
      },
      _mouseInit: function () {
        var that = this;
        this.element.on("mousedown." + this.widgetName, function (event) {
          return that._mouseDown(event);
        }).on("click." + this.widgetName, function (event) {
          if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
            $.removeData(event.target, that.widgetName + ".preventClickEvent");
            event.stopImmediatePropagation();
            return false;
          }
        });
        this.started = false;
      },
      // TODO: make sure destroying one instance of mouse doesn't mess with
      // other instances of mouse
      _mouseDestroy: function () {
        this.element.off("." + this.widgetName);

        if (this._mouseMoveDelegate) {
          this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate);
        }
      },
      _mouseDown: function (event) {
        // don't let more than one widget handle mouseStart
        if (mouseHandled) {
          return;
        }

        this._mouseMoved = false; // We may have missed mouseup (out of window)

        this._mouseStarted && this._mouseUp(event);
        this._mouseDownEvent = event;
        var that = this,
            btnIsLeft = event.which === 1,
            // event.target.nodeName works around a bug in IE 8 with
        // disabled inputs (#7620)
        elIsCancel = typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false;

        if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
          return true;
        }

        this.mouseDelayMet = !this.options.delay;

        if (!this.mouseDelayMet) {
          this._mouseDelayTimer = setTimeout(function () {
            that.mouseDelayMet = true;
          }, this.options.delay);
        }

        if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
          this._mouseStarted = this._mouseStart(event) !== false;

          if (!this._mouseStarted) {
            event.preventDefault();
            return true;
          }
        } // Click event may never have fired (Gecko & Opera)


        if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
          $.removeData(event.target, this.widgetName + ".preventClickEvent");
        } // These delegates are required to keep context


        this._mouseMoveDelegate = function (event) {
          return that._mouseMove(event);
        };

        this._mouseUpDelegate = function (event) {
          return that._mouseUp(event);
        };

        this.document.on("mousemove." + this.widgetName, this._mouseMoveDelegate).on("mouseup." + this.widgetName, this._mouseUpDelegate);
        event.preventDefault();
        mouseHandled = true;
        return true;
      },
      _mouseMove: function (event) {
        // Only check for mouseups outside the document if you've moved inside the document
        // at least once. This prevents the firing of mouseup in the case of IE<9, which will
        // fire a mousemove event if content is placed under the cursor. See #7778
        // Support: IE <9
        if (this._mouseMoved) {
          // IE mouseup check - mouseup happened when mouse was out of window
          if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
            return this._mouseUp(event); // Iframe mouseup check - mouseup occurred in another document
          } else if (!event.which) {
            // Support: Safari <=8 - 9
            // Safari sets which to 0 if you press any of the following keys
            // during a drag (#14461)
            if (event.originalEvent.altKey || event.originalEvent.ctrlKey || event.originalEvent.metaKey || event.originalEvent.shiftKey) {
              this.ignoreMissingWhich = true;
            } else if (!this.ignoreMissingWhich) {
              return this._mouseUp(event);
            }
          }
        }

        if (event.which || event.button) {
          this._mouseMoved = true;
        }

        if (this._mouseStarted) {
          this._mouseDrag(event);

          return event.preventDefault();
        }

        if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
          this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== false;
          this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event);
        }

        return !this._mouseStarted;
      },
      _mouseUp: function (event) {
        this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate);

        if (this._mouseStarted) {
          this._mouseStarted = false;

          if (event.target === this._mouseDownEvent.target) {
            $.data(event.target, this.widgetName + ".preventClickEvent", true);
          }

          this._mouseStop(event);
        }

        if (this._mouseDelayTimer) {
          clearTimeout(this._mouseDelayTimer);
          delete this._mouseDelayTimer;
        }

        this.ignoreMissingWhich = false;
        mouseHandled = false;
        event.preventDefault();
      },
      _mouseDistanceMet: function (event) {
        return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance;
      },
      _mouseDelayMet: function ()
      /* event */
      {
        return this.mouseDelayMet;
      },
      // These are placeholder methods, to be overriden by extending plugin
      _mouseStart: function ()
      /* event */
      {},
      _mouseDrag: function ()
      /* event */
      {},
      _mouseStop: function ()
      /* event */
      {},
      _mouseCapture: function ()
      /* event */
      {
        return true;
      }
    });
    /*!
     * jQuery UI Sortable 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    //>>label: Sortable
    //>>group: Interactions
    //>>description: Enables items in a list to be sorted using the mouse.
    //>>docs: http://api.jqueryui.com/sortable/
    //>>demos: http://jqueryui.com/sortable/
    //>>css.structure: ../../themes/base/sortable.css

    var widgetsSortable = $.widget("ui.sortable", $.ui.mouse, {
      version: "1.12.1",
      widgetEventPrefix: "sort",
      ready: false,
      options: {
        appendTo: "parent",
        axis: false,
        connectWith: false,
        containment: false,
        cursor: "auto",
        cursorAt: false,
        dropOnEmpty: true,
        forcePlaceholderSize: false,
        forceHelperSize: false,
        grid: false,
        handle: false,
        helper: "original",
        items: "> *",
        opacity: false,
        placeholder: false,
        revert: false,
        scroll: true,
        scrollSensitivity: 20,
        scrollSpeed: 20,
        scope: "default",
        tolerance: "intersect",
        zIndex: 1000,
        // Callbacks
        activate: null,
        beforeStop: null,
        change: null,
        deactivate: null,
        out: null,
        over: null,
        receive: null,
        remove: null,
        sort: null,
        start: null,
        stop: null,
        update: null
      },
      _isOverAxis: function (x, reference, size) {
        return x >= reference && x < reference + size;
      },
      _isFloating: function (item) {
        return /left|right/.test(item.css("float")) || /inline|table-cell/.test(item.css("display"));
      },
      _create: function () {
        this.containerCache = {};

        this._addClass("ui-sortable"); //Get the items


        this.refresh(); //Let's determine the parent's offset

        this.offset = this.element.offset(); //Initialize mouse events for interaction

        this._mouseInit();

        this._setHandleClassName(); //We're ready to go


        this.ready = true;
      },
      _setOption: function (key, value) {
        this._super(key, value);

        if (key === "handle") {
          this._setHandleClassName();
        }
      },
      _setHandleClassName: function () {
        var that = this;

        this._removeClass(this.element.find(".ui-sortable-handle"), "ui-sortable-handle");

        $.each(this.items, function () {
          that._addClass(this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item, "ui-sortable-handle");
        });
      },
      _destroy: function () {
        this._mouseDestroy();

        for (var i = this.items.length - 1; i >= 0; i--) {
          this.items[i].item.removeData(this.widgetName + "-item");
        }

        return this;
      },
      _mouseCapture: function (event, overrideHandle) {
        var currentItem = null,
            validHandle = false,
            that = this;

        if (this.reverting) {
          return false;
        }

        if (this.options.disabled || this.options.type === "static") {
          return false;
        } //We have to refresh the items data once first


        this._refreshItems(event); //Find out if the clicked node (or one of its parents) is a actual item in this.items


        $(event.target).parents().each(function () {
          if ($.data(this, that.widgetName + "-item") === that) {
            currentItem = $(this);
            return false;
          }
        });

        if ($.data(event.target, that.widgetName + "-item") === that) {
          currentItem = $(event.target);
        }

        if (!currentItem) {
          return false;
        }

        if (this.options.handle && !overrideHandle) {
          $(this.options.handle, currentItem).find("*").addBack().each(function () {
            if (this === event.target) {
              validHandle = true;
            }
          });

          if (!validHandle) {
            return false;
          }
        }

        this.currentItem = currentItem;

        this._removeCurrentsFromItems();

        return true;
      },
      _mouseStart: function (event, overrideHandle, noActivation) {
        var i,
            body,
            o = this.options;
        this.currentContainer = this; //We only need to call refreshPositions, because the refreshItems call has been moved to
        // mouseCapture

        this.refreshPositions(); //Create and append the visible helper

        this.helper = this._createHelper(event); //Cache the helper size

        this._cacheHelperProportions();
        /*
         * - Position generation -
         * This block generates everything position related - it's the core of draggables.
         */
        //Cache the margins of the original element


        this._cacheMargins(); //Get the next scrolling parent


        this.scrollParent = this.helper.scrollParent(); //The element's absolute position on the page minus margins

        this.offset = this.currentItem.offset();
        this.offset = {
          top: this.offset.top - this.margins.top,
          left: this.offset.left - this.margins.left
        };
        $.extend(this.offset, {
          click: {
            //Where the click happened, relative to the element
            left: event.pageX - this.offset.left,
            top: event.pageY - this.offset.top
          },
          parent: this._getParentOffset(),
          // This is a relative to absolute position minus the actual position calculation -
          // only used for relative positioned helper
          relative: this._getRelativeOffset()
        }); // Only after we got the offset, we can change the helper's position to absolute
        // TODO: Still need to figure out a way to make relative sorting possible

        this.helper.css("position", "absolute");
        this.cssPosition = this.helper.css("position"); //Generate the original position

        this.originalPosition = this._generatePosition(event);
        this.originalPageX = event.pageX;
        this.originalPageY = event.pageY; //Adjust the mouse offset relative to the helper if "cursorAt" is supplied

        o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt); //Cache the former DOM position

        this.domPosition = {
          prev: this.currentItem.prev()[0],
          parent: this.currentItem.parent()[0]
        }; // If the helper is not the original, hide the original so it's not playing any role during
        // the drag, won't cause anything bad this way

        if (this.helper[0] !== this.currentItem[0]) {
          this.currentItem.hide();
        } //Create the placeholder


        this._createPlaceholder(); //Set a containment if given in the options


        if (o.containment) {
          this._setContainment();
        }

        if (o.cursor && o.cursor !== "auto") {
          // cursor option
          body = this.document.find("body"); // Support: IE

          this.storedCursor = body.css("cursor");
          body.css("cursor", o.cursor);
          this.storedStylesheet = $("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(body);
        }

        if (o.opacity) {
          // opacity option
          if (this.helper.css("opacity")) {
            this._storedOpacity = this.helper.css("opacity");
          }

          this.helper.css("opacity", o.opacity);
        }

        if (o.zIndex) {
          // zIndex option
          if (this.helper.css("zIndex")) {
            this._storedZIndex = this.helper.css("zIndex");
          }

          this.helper.css("zIndex", o.zIndex);
        } //Prepare scrolling


        if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
          this.overflowOffset = this.scrollParent.offset();
        } //Call callbacks


        this._trigger("start", event, this._uiHash()); //Recache the helper size


        if (!this._preserveHelperProportions) {
          this._cacheHelperProportions();
        } //Post "activate" events to possible containers


        if (!noActivation) {
          for (i = this.containers.length - 1; i >= 0; i--) {
            this.containers[i]._trigger("activate", event, this._uiHash(this));
          }
        } //Prepare possible droppables


        if ($.ui.ddmanager) {
          $.ui.ddmanager.current = this;
        }

        if ($.ui.ddmanager && !o.dropBehaviour) {
          $.ui.ddmanager.prepareOffsets(this, event);
        }

        this.dragging = true;

        this._addClass(this.helper, "ui-sortable-helper"); // Execute the drag once - this causes the helper not to be visiblebefore getting its
        // correct position


        this._mouseDrag(event);

        return true;
      },
      _mouseDrag: function (event) {
        var i,
            item,
            itemElement,
            intersection,
            o = this.options,
            scrolled = false; //Compute the helpers position

        this.position = this._generatePosition(event);
        this.positionAbs = this._convertPositionTo("absolute");

        if (!this.lastPositionAbs) {
          this.lastPositionAbs = this.positionAbs;
        } //Do scrolling


        if (this.options.scroll) {
          if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
            if (this.overflowOffset.top + this.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) {
              this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
            } else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
              this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
            }

            if (this.overflowOffset.left + this.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) {
              this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
            } else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
              this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
            }
          } else {
            if (event.pageY - this.document.scrollTop() < o.scrollSensitivity) {
              scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);
            } else if (this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) {
              scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);
            }

            if (event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {
              scrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);
            } else if (this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) {
              scrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed);
            }
          }

          if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
            $.ui.ddmanager.prepareOffsets(this, event);
          }
        } //Regenerate the absolute position used for position checks


        this.positionAbs = this._convertPositionTo("absolute"); //Set the helper position

        if (!this.options.axis || this.options.axis !== "y") {
          this.helper[0].style.left = this.position.left + "px";
        }

        if (!this.options.axis || this.options.axis !== "x") {
          this.helper[0].style.top = this.position.top + "px";
        } //Rearrange


        for (i = this.items.length - 1; i >= 0; i--) {
          //Cache variables and intersection, continue if no intersection
          item = this.items[i];
          itemElement = item.item[0];
          intersection = this._intersectsWithPointer(item);

          if (!intersection) {
            continue;
          } // Only put the placeholder inside the current Container, skip all
          // items from other containers. This works because when moving
          // an item from one container to another the
          // currentContainer is switched before the placeholder is moved.
          //
          // Without this, moving items in "sub-sortables" can cause
          // the placeholder to jitter between the outer and inner container.


          if (item.instance !== this.currentContainer) {
            continue;
          } // Cannot intersect with itself
          // no useless actions that have been done before
          // no action if the item moved is the parent of the item checked


          if (itemElement !== this.currentItem[0] && this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && (this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)) {
            this.direction = intersection === 1 ? "down" : "up";

            if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
              this._rearrange(event, item);
            } else {
              break;
            }

            this._trigger("change", event, this._uiHash());

            break;
          }
        } //Post events to containers


        this._contactContainers(event); //Interconnect with droppables


        if ($.ui.ddmanager) {
          $.ui.ddmanager.drag(this, event);
        } //Call callbacks


        this._trigger("sort", event, this._uiHash());

        this.lastPositionAbs = this.positionAbs;
        return false;
      },
      _mouseStop: function (event, noPropagation) {
        if (!event) {
          return;
        } //If we are using droppables, inform the manager about the drop


        if ($.ui.ddmanager && !this.options.dropBehaviour) {
          $.ui.ddmanager.drop(this, event);
        }

        if (this.options.revert) {
          var that = this,
              cur = this.placeholder.offset(),
              axis = this.options.axis,
              animation = {};

          if (!axis || axis === "x") {
            animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);
          }

          if (!axis || axis === "y") {
            animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);
          }

          this.reverting = true;
          $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function () {
            that._clear(event);
          });
        } else {
          this._clear(event, noPropagation);
        }

        return false;
      },
      cancel: function () {
        if (this.dragging) {
          this._mouseUp(new $.Event("mouseup", {
            target: null
          }));

          if (this.options.helper === "original") {
            this.currentItem.css(this._storedCSS);

            this._removeClass(this.currentItem, "ui-sortable-helper");
          } else {
            this.currentItem.show();
          } //Post deactivating events to containers


          for (var i = this.containers.length - 1; i >= 0; i--) {
            this.containers[i]._trigger("deactivate", null, this._uiHash(this));

            if (this.containers[i].containerCache.over) {
              this.containers[i]._trigger("out", null, this._uiHash(this));

              this.containers[i].containerCache.over = 0;
            }
          }
        }

        if (this.placeholder) {
          //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
          // it unbinds ALL events from the original node!
          if (this.placeholder[0].parentNode) {
            this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
          }

          if (this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
            this.helper.remove();
          }

          $.extend(this, {
            helper: null,
            dragging: false,
            reverting: false,
            _noFinalSort: null
          });

          if (this.domPosition.prev) {
            $(this.domPosition.prev).after(this.currentItem);
          } else {
            $(this.domPosition.parent).prepend(this.currentItem);
          }
        }

        return this;
      },
      serialize: function (o) {
        var items = this._getItemsAsjQuery(o && o.connected),
            str = [];

        o = o || {};
        $(items).each(function () {
          var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || /(.+)[\-=_](.+)/);

          if (res) {
            str.push((o.key || res[1] + "[]") + "=" + (o.key && o.expression ? res[1] : res[2]));
          }
        });

        if (!str.length && o.key) {
          str.push(o.key + "=");
        }

        return str.join("&");
      },
      toArray: function (o) {
        var items = this._getItemsAsjQuery(o && o.connected),
            ret = [];

        o = o || {};
        items.each(function () {
          ret.push($(o.item || this).attr(o.attribute || "id") || "");
        });
        return ret;
      },

      /* Be careful with the following core functions */
      _intersectsWith: function (item) {
        var x1 = this.positionAbs.left,
            x2 = x1 + this.helperProportions.width,
            y1 = this.positionAbs.top,
            y2 = y1 + this.helperProportions.height,
            l = item.left,
            r = l + item.width,
            t = item.top,
            b = t + item.height,
            dyClick = this.offset.click.top,
            dxClick = this.offset.click.left,
            isOverElementHeight = this.options.axis === "x" || y1 + dyClick > t && y1 + dyClick < b,
            isOverElementWidth = this.options.axis === "y" || x1 + dxClick > l && x1 + dxClick < r,
            isOverElement = isOverElementHeight && isOverElementWidth;

        if (this.options.tolerance === "pointer" || this.options.forcePointerForContainers || this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"]) {
          return isOverElement;
        } else {
          return l < x1 + this.helperProportions.width / 2 && // Right Half
          x2 - this.helperProportions.width / 2 < r && // Left Half
          t < y1 + this.helperProportions.height / 2 && // Bottom Half
          y2 - this.helperProportions.height / 2 < b; // Top Half
        }
      },
      _intersectsWithPointer: function (item) {
        var verticalDirection,
            horizontalDirection,
            isOverElementHeight = this.options.axis === "x" || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
            isOverElementWidth = this.options.axis === "y" || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
            isOverElement = isOverElementHeight && isOverElementWidth;

        if (!isOverElement) {
          return false;
        }

        verticalDirection = this._getDragVerticalDirection();
        horizontalDirection = this._getDragHorizontalDirection();
        return this.floating ? horizontalDirection === "right" || verticalDirection === "down" ? 2 : 1 : verticalDirection && (verticalDirection === "down" ? 2 : 1);
      },
      _intersectsWithSides: function (item) {
        var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + item.height / 2, item.height),
            isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + item.width / 2, item.width),
            verticalDirection = this._getDragVerticalDirection(),
            horizontalDirection = this._getDragHorizontalDirection();

        if (this.floating && horizontalDirection) {
          return horizontalDirection === "right" && isOverRightHalf || horizontalDirection === "left" && !isOverRightHalf;
        } else {
          return verticalDirection && (verticalDirection === "down" && isOverBottomHalf || verticalDirection === "up" && !isOverBottomHalf);
        }
      },
      _getDragVerticalDirection: function () {
        var delta = this.positionAbs.top - this.lastPositionAbs.top;
        return delta !== 0 && (delta > 0 ? "down" : "up");
      },
      _getDragHorizontalDirection: function () {
        var delta = this.positionAbs.left - this.lastPositionAbs.left;
        return delta !== 0 && (delta > 0 ? "right" : "left");
      },
      refresh: function (event) {
        this._refreshItems(event);

        this._setHandleClassName();

        this.refreshPositions();
        return this;
      },
      _connectWith: function () {
        var options = this.options;
        return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
      },
      _getItemsAsjQuery: function (connected) {
        var i,
            j,
            cur,
            inst,
            items = [],
            queries = [],
            connectWith = this._connectWith();

        if (connectWith && connected) {
          for (i = connectWith.length - 1; i >= 0; i--) {
            cur = $(connectWith[i], this.document[0]);

            for (j = cur.length - 1; j >= 0; j--) {
              inst = $.data(cur[j], this.widgetFullName);

              if (inst && inst !== this && !inst.options.disabled) {
                queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
              }
            }
          }
        }

        queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
          options: this.options,
          item: this.currentItem
        }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);

        function addItems() {
          items.push(this);
        }

        for (i = queries.length - 1; i >= 0; i--) {
          queries[i][0].each(addItems);
        }

        return $(items);
      },
      _removeCurrentsFromItems: function () {
        var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
        this.items = $.grep(this.items, function (item) {
          for (var j = 0; j < list.length; j++) {
            if (list[j] === item.item[0]) {
              return false;
            }
          }

          return true;
        });
      },
      _refreshItems: function (event) {
        this.items = [];
        this.containers = [this];

        var i,
            j,
            cur,
            inst,
            targetData,
            _queries,
            item,
            queriesLength,
            items = this.items,
            queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, {
          item: this.currentItem
        }) : $(this.options.items, this.element), this]],
            connectWith = this._connectWith(); //Shouldn't be run the first time through due to massive slow-down


        if (connectWith && this.ready) {
          for (i = connectWith.length - 1; i >= 0; i--) {
            cur = $(connectWith[i], this.document[0]);

            for (j = cur.length - 1; j >= 0; j--) {
              inst = $.data(cur[j], this.widgetFullName);

              if (inst && inst !== this && !inst.options.disabled) {
                queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, {
                  item: this.currentItem
                }) : $(inst.options.items, inst.element), inst]);
                this.containers.push(inst);
              }
            }
          }
        }

        for (i = queries.length - 1; i >= 0; i--) {
          targetData = queries[i][1];
          _queries = queries[i][0];

          for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
            item = $(_queries[j]); // Data for target checking (mouse manager)

            item.data(this.widgetName + "-item", targetData);
            items.push({
              item: item,
              instance: targetData,
              width: 0,
              height: 0,
              left: 0,
              top: 0
            });
          }
        }
      },
      refreshPositions: function (fast) {
        // Determine whether items are being displayed horizontally
        this.floating = this.items.length ? this.options.axis === "x" || this._isFloating(this.items[0].item) : false; //This has to be redone because due to the item being moved out/into the offsetParent,
        // the offsetParent's position will change

        if (this.offsetParent && this.helper) {
          this.offset.parent = this._getParentOffset();
        }

        var i, item, t, p;

        for (i = this.items.length - 1; i >= 0; i--) {
          item = this.items[i]; //We ignore calculating positions of all connected containers when we're not over them

          if (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
            continue;
          }

          t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

          if (!fast) {
            item.width = t.outerWidth();
            item.height = t.outerHeight();
          }

          p = t.offset();
          item.left = p.left;
          item.top = p.top;
        }

        if (this.options.custom && this.options.custom.refreshContainers) {
          this.options.custom.refreshContainers.call(this);
        } else {
          for (i = this.containers.length - 1; i >= 0; i--) {
            p = this.containers[i].element.offset();
            this.containers[i].containerCache.left = p.left;
            this.containers[i].containerCache.top = p.top;
            this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
            this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
          }
        }

        return this;
      },
      _createPlaceholder: function (that) {
        that = that || this;
        var className,
            o = that.options;

        if (!o.placeholder || o.placeholder.constructor === String) {
          className = o.placeholder;
          o.placeholder = {
            element: function () {
              var nodeName = that.currentItem[0].nodeName.toLowerCase(),
                  element = $("<" + nodeName + ">", that.document[0]);

              that._addClass(element, "ui-sortable-placeholder", className || that.currentItem[0].className)._removeClass(element, "ui-sortable-helper");

              if (nodeName === "tbody") {
                that._createTrPlaceholder(that.currentItem.find("tr").eq(0), $("<tr>", that.document[0]).appendTo(element));
              } else if (nodeName === "tr") {
                that._createTrPlaceholder(that.currentItem, element);
              } else if (nodeName === "img") {
                element.attr("src", that.currentItem.attr("src"));
              }

              if (!className) {
                element.css("visibility", "hidden");
              }

              return element;
            },
            update: function (container, p) {
              // 1. If a className is set as 'placeholder option, we don't force sizes -
              // the class is responsible for that
              // 2. The option 'forcePlaceholderSize can be enabled to force it even if a
              // class name is specified
              if (className && !o.forcePlaceholderSize) {
                return;
              } //If the element doesn't have a actual height by itself (without styles coming
              // from a stylesheet), it receives the inline height from the dragged item


              if (!p.height()) {
                p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop") || 0, 10) - parseInt(that.currentItem.css("paddingBottom") || 0, 10));
              }

              if (!p.width()) {
                p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft") || 0, 10) - parseInt(that.currentItem.css("paddingRight") || 0, 10));
              }
            }
          };
        } //Create the placeholder


        that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem)); //Append it after the actual current item

        that.currentItem.after(that.placeholder); //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)

        o.placeholder.update(that, that.placeholder);
      },
      _createTrPlaceholder: function (sourceTr, targetTr) {
        var that = this;
        sourceTr.children().each(function () {
          $("<td>&#160;</td>", that.document[0]).attr("colspan", $(this).attr("colspan") || 1).appendTo(targetTr);
        });
      },
      _contactContainers: function (event) {
        var i,
            j,
            dist,
            itemWithLeastDistance,
            posProperty,
            sizeProperty,
            cur,
            nearBottom,
            floating,
            axis,
            innermostContainer = null,
            innermostIndex = null; // Get innermost container that intersects with item

        for (i = this.containers.length - 1; i >= 0; i--) {
          // Never consider a container that's located within the item itself
          if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
            continue;
          }

          if (this._intersectsWith(this.containers[i].containerCache)) {
            // If we've already found a container and it's more "inner" than this, then continue
            if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
              continue;
            }

            innermostContainer = this.containers[i];
            innermostIndex = i;
          } else {
            // container doesn't intersect. trigger "out" event if necessary
            if (this.containers[i].containerCache.over) {
              this.containers[i]._trigger("out", event, this._uiHash(this));

              this.containers[i].containerCache.over = 0;
            }
          }
        } // If no intersecting containers found, return


        if (!innermostContainer) {
          return;
        } // Move the item into the container if it's not there already


        if (this.containers.length === 1) {
          if (!this.containers[innermostIndex].containerCache.over) {
            this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));

            this.containers[innermostIndex].containerCache.over = 1;
          }
        } else {
          // When entering a new container, we will find the item with the least distance and
          // append our item near it
          dist = 10000;
          itemWithLeastDistance = null;
          floating = innermostContainer.floating || this._isFloating(this.currentItem);
          posProperty = floating ? "left" : "top";
          sizeProperty = floating ? "width" : "height";
          axis = floating ? "pageX" : "pageY";

          for (j = this.items.length - 1; j >= 0; j--) {
            if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
              continue;
            }

            if (this.items[j].item[0] === this.currentItem[0]) {
              continue;
            }

            cur = this.items[j].item.offset()[posProperty];
            nearBottom = false;

            if (event[axis] - cur > this.items[j][sizeProperty] / 2) {
              nearBottom = true;
            }

            if (Math.abs(event[axis] - cur) < dist) {
              dist = Math.abs(event[axis] - cur);
              itemWithLeastDistance = this.items[j];
              this.direction = nearBottom ? "up" : "down";
            }
          } //Check if dropOnEmpty is enabled


          if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
            return;
          }

          if (this.currentContainer === this.containers[innermostIndex]) {
            if (!this.currentContainer.containerCache.over) {
              this.containers[innermostIndex]._trigger("over", event, this._uiHash());

              this.currentContainer.containerCache.over = 1;
            }

            return;
          }

          itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);

          this._trigger("change", event, this._uiHash());

          this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));

          this.currentContainer = this.containers[innermostIndex]; //Update the placeholder

          this.options.placeholder.update(this.currentContainer, this.placeholder);

          this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));

          this.containers[innermostIndex].containerCache.over = 1;
        }
      },
      _createHelper: function (event) {
        var o = this.options,
            helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : o.helper === "clone" ? this.currentItem.clone() : this.currentItem; //Add the helper to the DOM if that didn't happen already

        if (!helper.parents("body").length) {
          $(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
        }

        if (helper[0] === this.currentItem[0]) {
          this._storedCSS = {
            width: this.currentItem[0].style.width,
            height: this.currentItem[0].style.height,
            position: this.currentItem.css("position"),
            top: this.currentItem.css("top"),
            left: this.currentItem.css("left")
          };
        }

        if (!helper[0].style.width || o.forceHelperSize) {
          helper.width(this.currentItem.width());
        }

        if (!helper[0].style.height || o.forceHelperSize) {
          helper.height(this.currentItem.height());
        }

        return helper;
      },
      _adjustOffsetFromHelper: function (obj) {
        if (typeof obj === "string") {
          obj = obj.split(" ");
        }

        if ($.isArray(obj)) {
          obj = {
            left: +obj[0],
            top: +obj[1] || 0
          };
        }

        if ("left" in obj) {
          this.offset.click.left = obj.left + this.margins.left;
        }

        if ("right" in obj) {
          this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
        }

        if ("top" in obj) {
          this.offset.click.top = obj.top + this.margins.top;
        }

        if ("bottom" in obj) {
          this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
        }
      },
      _getParentOffset: function () {
        //Get the offsetParent and cache its position
        this.offsetParent = this.helper.offsetParent();
        var po = this.offsetParent.offset(); // This is a special case where we need to modify a offset calculated on start, since the
        // following happened:
        // 1. The position of the helper is absolute, so it's position is calculated based on the
        // next positioned parent
        // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
        // the document, which means that the scroll is included in the initial calculation of the
        // offset of the parent, and never recalculated upon drag

        if (this.cssPosition === "absolute" && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {
          po.left += this.scrollParent.scrollLeft();
          po.top += this.scrollParent.scrollTop();
        } // This needs to be actually done for all browsers, since pageX/pageY includes this
        // information with an ugly IE fix


        if (this.offsetParent[0] === this.document[0].body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie) {
          po = {
            top: 0,
            left: 0
          };
        }

        return {
          top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
          left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
        };
      },
      _getRelativeOffset: function () {
        if (this.cssPosition === "relative") {
          var p = this.currentItem.position();
          return {
            top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
            left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
          };
        } else {
          return {
            top: 0,
            left: 0
          };
        }
      },
      _cacheMargins: function () {
        this.margins = {
          left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
          top: parseInt(this.currentItem.css("marginTop"), 10) || 0
        };
      },
      _cacheHelperProportions: function () {
        this.helperProportions = {
          width: this.helper.outerWidth(),
          height: this.helper.outerHeight()
        };
      },
      _setContainment: function () {
        var ce,
            co,
            over,
            o = this.options;

        if (o.containment === "parent") {
          o.containment = this.helper[0].parentNode;
        }

        if (o.containment === "document" || o.containment === "window") {
          this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, o.containment === "document" ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left, (o.containment === "document" ? this.document.height() || document.body.parentNode.scrollHeight : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];
        }

        if (!/^(document|window|parent)$/.test(o.containment)) {
          ce = $(o.containment)[0];
          co = $(o.containment).offset();
          over = $(ce).css("overflow") !== "hidden";
          this.containment = [co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left, co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top, co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top];
        }
      },
      _convertPositionTo: function (d, pos) {
        if (!pos) {
          pos = this.position;
        }

        var mod = d === "absolute" ? 1 : -1,
            scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
            scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
        return {
          top: // The absolute mouse position
          pos.top + // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.relative.top * mod + // The offsetParent's offset without borders (offset + border)
          this.offset.parent.top * mod - (this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()) * mod,
          left: // The absolute mouse position
          pos.left + // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.relative.left * mod + // The offsetParent's offset without borders (offset + border)
          this.offset.parent.left * mod - (this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod
        };
      },
      _generatePosition: function (event) {
        var top,
            left,
            o = this.options,
            pageX = event.pageX,
            pageY = event.pageY,
            scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
            scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName); // This is another very weird special case that only happens for relative elements:
        // 1. If the css position is relative
        // 2. and the scroll parent is the document or similar to the offset parent
        // we have to refresh the relative offset during the scroll so there are no jumps

        if (this.cssPosition === "relative" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {
          this.offset.relative = this._getRelativeOffset();
        }
        /*
         * - Position constraining -
         * Constrain the position to a mix of grid, containment.
         */


        if (this.originalPosition) {
          //If we are not dragging yet, we won't check for options
          if (this.containment) {
            if (event.pageX - this.offset.click.left < this.containment[0]) {
              pageX = this.containment[0] + this.offset.click.left;
            }

            if (event.pageY - this.offset.click.top < this.containment[1]) {
              pageY = this.containment[1] + this.offset.click.top;
            }

            if (event.pageX - this.offset.click.left > this.containment[2]) {
              pageX = this.containment[2] + this.offset.click.left;
            }

            if (event.pageY - this.offset.click.top > this.containment[3]) {
              pageY = this.containment[3] + this.offset.click.top;
            }
          }

          if (o.grid) {
            top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
            pageY = this.containment ? top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3] ? top : top - this.offset.click.top >= this.containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
            left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
            pageX = this.containment ? left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2] ? left : left - this.offset.click.left >= this.containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
          }
        }

        return {
          top: // The absolute mouse position
          pageY - // Click offset (relative to the element)
          this.offset.click.top - // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.relative.top - // The offsetParent's offset without borders (offset + border)
          this.offset.parent.top + (this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()),
          left: // The absolute mouse position
          pageX - // Click offset (relative to the element)
          this.offset.click.left - // Only for relative positioned nodes: Relative offset from element to offset parent
          this.offset.relative.left - // The offsetParent's offset without borders (offset + border)
          this.offset.parent.left + (this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())
        };
      },
      _rearrange: function (event, i, a, hardRefresh) {
        a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], this.direction === "down" ? i.item[0] : i.item[0].nextSibling); //Various things done here to improve the performance:
        // 1. we create a setTimeout, that calls refreshPositions
        // 2. on the instance, we have a counter variable, that get's higher after every append
        // 3. on the local scope, we copy the counter variable, and check in the timeout,
        // if it's still the same
        // 4. this lets only the last addition to the timeout stack through

        this.counter = this.counter ? ++this.counter : 1;
        var counter = this.counter;

        this._delay(function () {
          if (counter === this.counter) {
            //Precompute after each DOM insertion, NOT on mousemove
            this.refreshPositions(!hardRefresh);
          }
        });
      },
      _clear: function (event, noPropagation) {
        this.reverting = false; // We delay all events that have to be triggered to after the point where the placeholder
        // has been removed and everything else normalized again

        var i,
            delayedTriggers = []; // We first have to update the dom position of the actual currentItem
        // Note: don't do it if the current item is already removed (by a user), or it gets
        // reappended (see #4088)

        if (!this._noFinalSort && this.currentItem.parent().length) {
          this.placeholder.before(this.currentItem);
        }

        this._noFinalSort = null;

        if (this.helper[0] === this.currentItem[0]) {
          for (i in this._storedCSS) {
            if (this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
              this._storedCSS[i] = "";
            }
          }

          this.currentItem.css(this._storedCSS);

          this._removeClass(this.currentItem, "ui-sortable-helper");
        } else {
          this.currentItem.show();
        }

        if (this.fromOutside && !noPropagation) {
          delayedTriggers.push(function (event) {
            this._trigger("receive", event, this._uiHash(this.fromOutside));
          });
        }

        if ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
          // Trigger update callback if the DOM position has changed
          delayedTriggers.push(function (event) {
            this._trigger("update", event, this._uiHash());
          });
        } // Check if the items Container has Changed and trigger appropriate
        // events.


        if (this !== this.currentContainer) {
          if (!noPropagation) {
            delayedTriggers.push(function (event) {
              this._trigger("remove", event, this._uiHash());
            });
            delayedTriggers.push(function (c) {
              return function (event) {
                c._trigger("receive", event, this._uiHash(this));
              };
            }.call(this, this.currentContainer));
            delayedTriggers.push(function (c) {
              return function (event) {
                c._trigger("update", event, this._uiHash(this));
              };
            }.call(this, this.currentContainer));
          }
        } //Post events to containers


        function delayEvent(type, instance, container) {
          return function (event) {
            container._trigger(type, event, instance._uiHash(instance));
          };
        }

        for (i = this.containers.length - 1; i >= 0; i--) {
          if (!noPropagation) {
            delayedTriggers.push(delayEvent("deactivate", this, this.containers[i]));
          }

          if (this.containers[i].containerCache.over) {
            delayedTriggers.push(delayEvent("out", this, this.containers[i]));
            this.containers[i].containerCache.over = 0;
          }
        } //Do what was originally in plugins


        if (this.storedCursor) {
          this.document.find("body").css("cursor", this.storedCursor);
          this.storedStylesheet.remove();
        }

        if (this._storedOpacity) {
          this.helper.css("opacity", this._storedOpacity);
        }

        if (this._storedZIndex) {
          this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
        }

        this.dragging = false;

        if (!noPropagation) {
          this._trigger("beforeStop", event, this._uiHash());
        } //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
        // it unbinds ALL events from the original node!


        this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

        if (!this.cancelHelperRemoval) {
          if (this.helper[0] !== this.currentItem[0]) {
            this.helper.remove();
          }

          this.helper = null;
        }

        if (!noPropagation) {
          for (i = 0; i < delayedTriggers.length; i++) {
            // Trigger all delayed events
            delayedTriggers[i].call(this, event);
          }

          this._trigger("stop", event, this._uiHash());
        }

        this.fromOutside = false;
        return !this.cancelHelperRemoval;
      },
      _trigger: function () {
        if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
          this.cancel();
        }
      },
      _uiHash: function (_inst) {
        var inst = _inst || this;
        return {
          helper: inst.helper,
          placeholder: inst.placeholder || $([]),
          position: inst.position,
          originalPosition: inst.originalPosition,
          offset: inst.positionAbs,
          item: inst.currentItem,
          sender: _inst ? _inst.element : null
        };
      }
    }); // jscs:disable maximumLineLength

    /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */

    /*!
     * jQuery UI Datepicker 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    //>>label: Datepicker
    //>>group: Widgets
    //>>description: Displays a calendar from an input or inline for selecting dates.
    //>>docs: http://api.jqueryui.com/datepicker/
    //>>demos: http://jqueryui.com/datepicker/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/datepicker.css
    //>>css.theme: ../../themes/base/theme.css

    $.extend($.ui, {
      datepicker: {
        version: "1.12.1"
      }
    });
    var datepicker_instActive;

    function datepicker_getZindex(elem) {
      var position, value;

      while (elem.length && elem[0] !== document) {
        // Ignore z-index if position is set to a value where z-index is ignored by the browser
        // This makes behavior of this function consistent across browsers
        // WebKit always returns auto if the element is positioned
        position = elem.css("position");

        if (position === "absolute" || position === "relative" || position === "fixed") {
          // IE returns 0 when zIndex is not specified
          // other browsers return a string
          // we ignore the case of nested elements with an explicit value of 0
          // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
          value = parseInt(elem.css("zIndex"), 10);

          if (!isNaN(value) && value !== 0) {
            return value;
          }
        }

        elem = elem.parent();
      }

      return 0;
    }
    /* Date picker manager.
       Use the singleton instance of this class, $.datepicker, to interact with the date picker.
       Settings for (groups of) date pickers are maintained in an instance object,
       allowing multiple different settings on the same page. */


    function Datepicker() {
      this._curInst = null; // The current instance in use

      this._keyEvent = false; // If the last event was a key event

      this._disabledInputs = []; // List of date picker inputs that have been disabled

      this._datepickerShowing = false; // True if the popup picker is showing , false if not

      this._inDialog = false; // True if showing within a "dialog", false if not

      this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division

      this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class

      this._appendClass = "ui-datepicker-append"; // The name of the append marker class

      this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class

      this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class

      this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class

      this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class

      this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class

      this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class

      this.regional = []; // Available regional settings, indexed by language code

      this.regional[""] = {
        // Default regional settings
        closeText: "Done",
        // Display text for close link
        prevText: "Prev",
        // Display text for previous month link
        nextText: "Next",
        // Display text for next month link
        currentText: "Today",
        // Display text for current month link
        monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        // Names of months for drop-down and formatting
        monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        // For formatting
        dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        // For formatting
        dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        // For formatting
        dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
        // Column headings for days starting at Sunday
        weekHeader: "Wk",
        // Column header for week of the year
        dateFormat: "mm/dd/yy",
        // See format options on parseDate
        firstDay: 0,
        // The first day of the week, Sun = 0, Mon = 1, ...
        isRTL: false,
        // True if right-to-left language, false if left-to-right
        showMonthAfterYear: false,
        // True if the year select precedes month, false for month then year
        yearSuffix: "" // Additional text to append to the year in the month headers

      };
      this._defaults = {
        // Global defaults for all the date picker instances
        showOn: "focus",
        // "focus" for popup on focus,
        // "button" for trigger button, or "both" for either
        showAnim: "fadeIn",
        // Name of jQuery animation for popup
        showOptions: {},
        // Options for enhanced animations
        defaultDate: null,
        // Used when field is blank: actual date,
        // +/-number for offset from today, null for today
        appendText: "",
        // Display text following the input box, e.g. showing the format
        buttonText: "...",
        // Text for trigger button
        buttonImage: "",
        // URL for trigger button image
        buttonImageOnly: false,
        // True if the image appears alone, false if it appears on a button
        hideIfNoPrevNext: false,
        // True to hide next/previous month links
        // if not applicable, false to just disable them
        navigationAsDateFormat: false,
        // True if date formatting applied to prev/today/next links
        gotoCurrent: false,
        // True if today link goes back to current selection instead
        changeMonth: false,
        // True if month can be selected directly, false if only prev/next
        changeYear: false,
        // True if year can be selected directly, false if only prev/next
        yearRange: "c-10:c+10",
        // Range of years to display in drop-down,
        // either relative to today's year (-nn:+nn), relative to currently displayed year
        // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
        showOtherMonths: false,
        // True to show dates in other months, false to leave blank
        selectOtherMonths: false,
        // True to allow selection of dates in other months, false for unselectable
        showWeek: false,
        // True to show week of the year, false to not show it
        calculateWeek: this.iso8601Week,
        // How to calculate the week of the year,
        // takes a Date and returns the number of the week for it
        shortYearCutoff: "+10",
        // Short year values < this are in the current century,
        // > this are in the previous century,
        // string value starting with "+" for current year + value
        minDate: null,
        // The earliest selectable date, or null for no limit
        maxDate: null,
        // The latest selectable date, or null for no limit
        duration: "fast",
        // Duration of display/closure
        beforeShowDay: null,
        // Function that takes a date and returns an array with
        // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
        // [2] = cell title (optional), e.g. $.datepicker.noWeekends
        beforeShow: null,
        // Function that takes an input field and
        // returns a set of custom settings for the date picker
        onSelect: null,
        // Define a callback function when a date is selected
        onChangeMonthYear: null,
        // Define a callback function when the month or year is changed
        onClose: null,
        // Define a callback function when the datepicker is closed
        numberOfMonths: 1,
        // Number of months to show at a time
        showCurrentAtPos: 0,
        // The position in multipe months at which to show the current month (starting at 0)
        stepMonths: 1,
        // Number of months to step back/forward
        stepBigMonths: 12,
        // Number of months to step back/forward for the big links
        altField: "",
        // Selector for an alternate field to store selected dates into
        altFormat: "",
        // The date format to use for the alternate field
        constrainInput: true,
        // The input is constrained by the current date format
        showButtonPanel: false,
        // True to show button panel, false to not show it
        autoSize: false,
        // True to size the input for the date format, false to leave as is
        disabled: false // The initial disabled state

      };
      $.extend(this._defaults, this.regional[""]);
      this.regional.en = $.extend(true, {}, this.regional[""]);
      this.regional["en-US"] = $.extend(true, {}, this.regional.en);
      this.dpDiv = datepicker_bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
    }

    $.extend(Datepicker.prototype, {
      /* Class name added to elements to indicate already configured with a date picker. */
      markerClassName: "hasDatepicker",
      //Keep track of the maximum number of rows displayed (see #7043)
      maxRows: 4,
      // TODO rename to "widget" when switching to widget factory
      _widgetDatepicker: function () {
        return this.dpDiv;
      },

      /* Override the default settings for all instances of the date picker.
       * @param  settings  object - the new settings to use as defaults (anonymous object)
       * @return the manager object
       */
      setDefaults: function (settings) {
        datepicker_extendRemove(this._defaults, settings || {});
        return this;
      },

      /* Attach the date picker to a jQuery selection.
       * @param  target	element - the target input field or division or span
       * @param  settings  object - the new settings to use for this date picker instance (anonymous)
       */
      _attachDatepicker: function (target, settings) {
        var nodeName, inline, inst;
        nodeName = target.nodeName.toLowerCase();
        inline = nodeName === "div" || nodeName === "span";

        if (!target.id) {
          this.uuid += 1;
          target.id = "dp" + this.uuid;
        }

        inst = this._newInst($(target), inline);
        inst.settings = $.extend({}, settings || {});

        if (nodeName === "input") {
          this._connectDatepicker(target, inst);
        } else if (inline) {
          this._inlineDatepicker(target, inst);
        }
      },

      /* Create a new instance object. */
      _newInst: function (target, inline) {
        var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars

        return {
          id: id,
          input: target,
          // associated target
          selectedDay: 0,
          selectedMonth: 0,
          selectedYear: 0,
          // current selection
          drawMonth: 0,
          drawYear: 0,
          // month being drawn
          inline: inline,
          // is datepicker inline or not
          dpDiv: !inline ? this.dpDiv : // presentation div
          datepicker_bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))
        };
      },

      /* Attach the date picker to an input field. */
      _connectDatepicker: function (target, inst) {
        var input = $(target);
        inst.append = $([]);
        inst.trigger = $([]);

        if (input.hasClass(this.markerClassName)) {
          return;
        }

        this._attachments(input, inst);

        input.addClass(this.markerClassName).on("keydown", this._doKeyDown).on("keypress", this._doKeyPress).on("keyup", this._doKeyUp);

        this._autoSize(inst);

        $.data(target, "datepicker", inst); //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)

        if (inst.settings.disabled) {
          this._disableDatepicker(target);
        }
      },

      /* Make attachments based on settings. */
      _attachments: function (input, inst) {
        var showOn,
            buttonText,
            buttonImage,
            appendText = this._get(inst, "appendText"),
            isRTL = this._get(inst, "isRTL");

        if (inst.append) {
          inst.append.remove();
        }

        if (appendText) {
          inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
          input[isRTL ? "before" : "after"](inst.append);
        }

        input.off("focus", this._showDatepicker);

        if (inst.trigger) {
          inst.trigger.remove();
        }

        showOn = this._get(inst, "showOn");

        if (showOn === "focus" || showOn === "both") {
          // pop-up date picker when in the marked field
          input.on("focus", this._showDatepicker);
        }

        if (showOn === "button" || showOn === "both") {
          // pop-up date picker when button clicked
          buttonText = this._get(inst, "buttonText");
          buttonImage = this._get(inst, "buttonImage");
          inst.trigger = $(this._get(inst, "buttonImageOnly") ? $("<img/>").addClass(this._triggerClass).attr({
            src: buttonImage,
            alt: buttonText,
            title: buttonText
          }) : $("<button type='button'></button>").addClass(this._triggerClass).html(!buttonImage ? buttonText : $("<img/>").attr({
            src: buttonImage,
            alt: buttonText,
            title: buttonText
          })));
          input[isRTL ? "before" : "after"](inst.trigger);
          inst.trigger.on("click", function () {
            if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
              $.datepicker._hideDatepicker();
            } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
              $.datepicker._hideDatepicker();

              $.datepicker._showDatepicker(input[0]);
            } else {
              $.datepicker._showDatepicker(input[0]);
            }

            return false;
          });
        }
      },

      /* Apply the maximum length for the date format. */
      _autoSize: function (inst) {
        if (this._get(inst, "autoSize") && !inst.inline) {
          var findMax,
              max,
              maxI,
              i,
              date = new Date(2009, 12 - 1, 20),
              // Ensure double digits
          dateFormat = this._get(inst, "dateFormat");

          if (dateFormat.match(/[DM]/)) {
            findMax = function (names) {
              max = 0;
              maxI = 0;

              for (i = 0; i < names.length; i++) {
                if (names[i].length > max) {
                  max = names[i].length;
                  maxI = i;
                }
              }

              return maxI;
            };

            date.setMonth(findMax(this._get(inst, dateFormat.match(/MM/) ? "monthNames" : "monthNamesShort")));
            date.setDate(findMax(this._get(inst, dateFormat.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - date.getDay());
          }

          inst.input.attr("size", this._formatDate(inst, date).length);
        }
      },

      /* Attach an inline date picker to a div. */
      _inlineDatepicker: function (target, inst) {
        var divSpan = $(target);

        if (divSpan.hasClass(this.markerClassName)) {
          return;
        }

        divSpan.addClass(this.markerClassName).append(inst.dpDiv);
        $.data(target, "datepicker", inst);

        this._setDate(inst, this._getDefaultDate(inst), true);

        this._updateDatepicker(inst);

        this._updateAlternate(inst); //If disabled option is true, disable the datepicker before showing it (see ticket #5665)


        if (inst.settings.disabled) {
          this._disableDatepicker(target);
        } // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
        // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height


        inst.dpDiv.css("display", "block");
      },

      /* Pop-up the date picker in a "dialog" box.
       * @param  input element - ignored
       * @param  date	string or Date - the initial date to display
       * @param  onSelect  function - the function to call when a date is selected
       * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
       * @param  pos int[2] - coordinates for the dialog's position within the screen or
       *					event - with x/y coordinates or
       *					leave empty for default (screen centre)
       * @return the manager object
       */
      _dialogDatepicker: function (input, date, onSelect, settings, pos) {
        var id,
            browserWidth,
            browserHeight,
            scrollX,
            scrollY,
            inst = this._dialogInst; // internal instance

        if (!inst) {
          this.uuid += 1;
          id = "dp" + this.uuid;
          this._dialogInput = $("<input type='text' id='" + id + "' style='position: absolute; top: -100px; width: 0px;'/>");

          this._dialogInput.on("keydown", this._doKeyDown);

          $("body").append(this._dialogInput);
          inst = this._dialogInst = this._newInst(this._dialogInput, false);
          inst.settings = {};
          $.data(this._dialogInput[0], "datepicker", inst);
        }

        datepicker_extendRemove(inst.settings, settings || {});
        date = date && date.constructor === Date ? this._formatDate(inst, date) : date;

        this._dialogInput.val(date);

        this._pos = pos ? pos.length ? pos : [pos.pageX, pos.pageY] : null;

        if (!this._pos) {
          browserWidth = document.documentElement.clientWidth;
          browserHeight = document.documentElement.clientHeight;
          scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
          scrollY = document.documentElement.scrollTop || document.body.scrollTop;
          this._pos = // should use actual width/height below
          [browserWidth / 2 - 100 + scrollX, browserHeight / 2 - 150 + scrollY];
        } // Move input on screen for focus, but hidden behind dialog


        this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px");

        inst.settings.onSelect = onSelect;
        this._inDialog = true;
        this.dpDiv.addClass(this._dialogClass);

        this._showDatepicker(this._dialogInput[0]);

        if ($.blockUI) {
          $.blockUI(this.dpDiv);
        }

        $.data(this._dialogInput[0], "datepicker", inst);
        return this;
      },

      /* Detach a datepicker from its control.
       * @param  target	element - the target input field or division or span
       */
      _destroyDatepicker: function (target) {
        var nodeName,
            $target = $(target),
            inst = $.data(target, "datepicker");

        if (!$target.hasClass(this.markerClassName)) {
          return;
        }

        nodeName = target.nodeName.toLowerCase();
        $.removeData(target, "datepicker");

        if (nodeName === "input") {
          inst.append.remove();
          inst.trigger.remove();
          $target.removeClass(this.markerClassName).off("focus", this._showDatepicker).off("keydown", this._doKeyDown).off("keypress", this._doKeyPress).off("keyup", this._doKeyUp);
        } else if (nodeName === "div" || nodeName === "span") {
          $target.removeClass(this.markerClassName).empty();
        }

        if (datepicker_instActive === inst) {
          datepicker_instActive = null;
        }
      },

      /* Enable the date picker to a jQuery selection.
       * @param  target	element - the target input field or division or span
       */
      _enableDatepicker: function (target) {
        var nodeName,
            inline,
            $target = $(target),
            inst = $.data(target, "datepicker");

        if (!$target.hasClass(this.markerClassName)) {
          return;
        }

        nodeName = target.nodeName.toLowerCase();

        if (nodeName === "input") {
          target.disabled = false;
          inst.trigger.filter("button").each(function () {
            this.disabled = false;
          }).end().filter("img").css({
            opacity: "1.0",
            cursor: ""
          });
        } else if (nodeName === "div" || nodeName === "span") {
          inline = $target.children("." + this._inlineClass);
          inline.children().removeClass("ui-state-disabled");
          inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", false);
        }

        this._disabledInputs = $.map(this._disabledInputs, function (value) {
          return value === target ? null : value;
        }); // delete entry
      },

      /* Disable the date picker to a jQuery selection.
       * @param  target	element - the target input field or division or span
       */
      _disableDatepicker: function (target) {
        var nodeName,
            inline,
            $target = $(target),
            inst = $.data(target, "datepicker");

        if (!$target.hasClass(this.markerClassName)) {
          return;
        }

        nodeName = target.nodeName.toLowerCase();

        if (nodeName === "input") {
          target.disabled = true;
          inst.trigger.filter("button").each(function () {
            this.disabled = true;
          }).end().filter("img").css({
            opacity: "0.5",
            cursor: "default"
          });
        } else if (nodeName === "div" || nodeName === "span") {
          inline = $target.children("." + this._inlineClass);
          inline.children().addClass("ui-state-disabled");
          inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", true);
        }

        this._disabledInputs = $.map(this._disabledInputs, function (value) {
          return value === target ? null : value;
        }); // delete entry

        this._disabledInputs[this._disabledInputs.length] = target;
      },

      /* Is the first field in a jQuery collection disabled as a datepicker?
       * @param  target	element - the target input field or division or span
       * @return boolean - true if disabled, false if enabled
       */
      _isDisabledDatepicker: function (target) {
        if (!target) {
          return false;
        }

        for (var i = 0; i < this._disabledInputs.length; i++) {
          if (this._disabledInputs[i] === target) {
            return true;
          }
        }

        return false;
      },

      /* Retrieve the instance data for the target control.
       * @param  target  element - the target input field or division or span
       * @return  object - the associated instance data
       * @throws  error if a jQuery problem getting data
       */
      _getInst: function (target) {
        try {
          return $.data(target, "datepicker");
        } catch (err) {
          throw "Missing instance data for this datepicker";
        }
      },

      /* Update or retrieve the settings for a date picker attached to an input field or division.
       * @param  target  element - the target input field or division or span
       * @param  name	object - the new settings to update or
       *				string - the name of the setting to change or retrieve,
       *				when retrieving also "all" for all instance settings or
       *				"defaults" for all global defaults
       * @param  value   any - the new value for the setting
       *				(omit if above is an object or to retrieve a value)
       */
      _optionDatepicker: function (target, name, value) {
        var settings,
            date,
            minDate,
            maxDate,
            inst = this._getInst(target);

        if (arguments.length === 2 && typeof name === "string") {
          return name === "defaults" ? $.extend({}, $.datepicker._defaults) : inst ? name === "all" ? $.extend({}, inst.settings) : this._get(inst, name) : null;
        }

        settings = name || {};

        if (typeof name === "string") {
          settings = {};
          settings[name] = value;
        }

        if (inst) {
          if (this._curInst === inst) {
            this._hideDatepicker();
          }

          date = this._getDateDatepicker(target, true);
          minDate = this._getMinMaxDate(inst, "min");
          maxDate = this._getMinMaxDate(inst, "max");
          datepicker_extendRemove(inst.settings, settings); // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided

          if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
            inst.settings.minDate = this._formatDate(inst, minDate);
          }

          if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
            inst.settings.maxDate = this._formatDate(inst, maxDate);
          }

          if ("disabled" in settings) {
            if (settings.disabled) {
              this._disableDatepicker(target);
            } else {
              this._enableDatepicker(target);
            }
          }

          this._attachments($(target), inst);

          this._autoSize(inst);

          this._setDate(inst, date);

          this._updateAlternate(inst);

          this._updateDatepicker(inst);
        }
      },
      // Change method deprecated
      _changeDatepicker: function (target, name, value) {
        this._optionDatepicker(target, name, value);
      },

      /* Redraw the date picker attached to an input field or division.
       * @param  target  element - the target input field or division or span
       */
      _refreshDatepicker: function (target) {
        var inst = this._getInst(target);

        if (inst) {
          this._updateDatepicker(inst);
        }
      },

      /* Set the dates for a jQuery selection.
       * @param  target element - the target input field or division or span
       * @param  date	Date - the new date
       */
      _setDateDatepicker: function (target, date) {
        var inst = this._getInst(target);

        if (inst) {
          this._setDate(inst, date);

          this._updateDatepicker(inst);

          this._updateAlternate(inst);
        }
      },

      /* Get the date(s) for the first entry in a jQuery selection.
       * @param  target element - the target input field or division or span
       * @param  noDefault boolean - true if no default date is to be used
       * @return Date - the current date
       */
      _getDateDatepicker: function (target, noDefault) {
        var inst = this._getInst(target);

        if (inst && !inst.inline) {
          this._setDateFromField(inst, noDefault);
        }

        return inst ? this._getDate(inst) : null;
      },

      /* Handle keystrokes. */
      _doKeyDown: function (event) {
        var onSelect,
            dateStr,
            sel,
            inst = $.datepicker._getInst(event.target),
            handled = true,
            isRTL = inst.dpDiv.is(".ui-datepicker-rtl");

        inst._keyEvent = true;

        if ($.datepicker._datepickerShowing) {
          switch (event.keyCode) {
            case 9:
              $.datepicker._hideDatepicker();

              handled = false;
              break;
            // hide on tab out

            case 13:
              sel = $("td." + $.datepicker._dayOverClass + ":not(." + $.datepicker._currentClass + ")", inst.dpDiv);

              if (sel[0]) {
                $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
              }

              onSelect = $.datepicker._get(inst, "onSelect");

              if (onSelect) {
                dateStr = $.datepicker._formatDate(inst); // Trigger custom callback

                onSelect.apply(inst.input ? inst.input[0] : null, [dateStr, inst]);
              } else {
                $.datepicker._hideDatepicker();
              }

              return false;
            // don't submit the form

            case 27:
              $.datepicker._hideDatepicker();

              break;
            // hide on escape

            case 33:
              $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");

              break;
            // previous month/year on page up/+ ctrl

            case 34:
              $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");

              break;
            // next month/year on page down/+ ctrl

            case 35:
              if (event.ctrlKey || event.metaKey) {
                $.datepicker._clearDate(event.target);
              }

              handled = event.ctrlKey || event.metaKey;
              break;
            // clear on ctrl or command +end

            case 36:
              if (event.ctrlKey || event.metaKey) {
                $.datepicker._gotoToday(event.target);
              }

              handled = event.ctrlKey || event.metaKey;
              break;
            // current on ctrl or command +home

            case 37:
              if (event.ctrlKey || event.metaKey) {
                $.datepicker._adjustDate(event.target, isRTL ? +1 : -1, "D");
              }

              handled = event.ctrlKey || event.metaKey; // -1 day on ctrl or command +left

              if (event.originalEvent.altKey) {
                $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");
              } // next month/year on alt +left on Mac


              break;

            case 38:
              if (event.ctrlKey || event.metaKey) {
                $.datepicker._adjustDate(event.target, -7, "D");
              }

              handled = event.ctrlKey || event.metaKey;
              break;
            // -1 week on ctrl or command +up

            case 39:
              if (event.ctrlKey || event.metaKey) {
                $.datepicker._adjustDate(event.target, isRTL ? -1 : +1, "D");
              }

              handled = event.ctrlKey || event.metaKey; // +1 day on ctrl or command +right

              if (event.originalEvent.altKey) {
                $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");
              } // next month/year on alt +right


              break;

            case 40:
              if (event.ctrlKey || event.metaKey) {
                $.datepicker._adjustDate(event.target, +7, "D");
              }

              handled = event.ctrlKey || event.metaKey;
              break;
            // +1 week on ctrl or command +down

            default:
              handled = false;
          }
        } else if (event.keyCode === 36 && event.ctrlKey) {
          // display the date picker on ctrl+home
          $.datepicker._showDatepicker(this);
        } else {
          handled = false;
        }

        if (handled) {
          event.preventDefault();
          event.stopPropagation();
        }
      },

      /* Filter entered characters - based on date format. */
      _doKeyPress: function (event) {
        var chars,
            chr,
            inst = $.datepicker._getInst(event.target);

        if ($.datepicker._get(inst, "constrainInput")) {
          chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
          chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
          return event.ctrlKey || event.metaKey || chr < " " || !chars || chars.indexOf(chr) > -1;
        }
      },

      /* Synchronise manual entry and field/alternate field. */
      _doKeyUp: function (event) {
        var date,
            inst = $.datepicker._getInst(event.target);

        if (inst.input.val() !== inst.lastVal) {
          try {
            date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), inst.input ? inst.input.val() : null, $.datepicker._getFormatConfig(inst));

            if (date) {
              // only if valid
              $.datepicker._setDateFromField(inst);

              $.datepicker._updateAlternate(inst);

              $.datepicker._updateDatepicker(inst);
            }
          } catch (err) {}
        }

        return true;
      },

      /* Pop-up the date picker for a given input field.
       * If false returned from beforeShow event handler do not show.
       * @param  input  element - the input field attached to the date picker or
       *					event - if triggered by focus
       */
      _showDatepicker: function (input) {
        input = input.target || input;

        if (input.nodeName.toLowerCase() !== "input") {
          // find from button/image trigger
          input = $("input", input.parentNode)[0];
        }

        if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) {
          // already here
          return;
        }

        var inst, beforeShow, beforeShowSettings, isFixed, offset, showAnim, duration;
        inst = $.datepicker._getInst(input);

        if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
          $.datepicker._curInst.dpDiv.stop(true, true);

          if (inst && $.datepicker._datepickerShowing) {
            $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
          }
        }

        beforeShow = $.datepicker._get(inst, "beforeShow");
        beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};

        if (beforeShowSettings === false) {
          return;
        }

        datepicker_extendRemove(inst.settings, beforeShowSettings);
        inst.lastVal = null;
        $.datepicker._lastInput = input;

        $.datepicker._setDateFromField(inst);

        if ($.datepicker._inDialog) {
          // hide cursor
          input.value = "";
        }

        if (!$.datepicker._pos) {
          // position below input
          $.datepicker._pos = $.datepicker._findPos(input);
          $.datepicker._pos[1] += input.offsetHeight; // add the height
        }

        isFixed = false;
        $(input).parents().each(function () {
          isFixed |= $(this).css("position") === "fixed";
          return !isFixed;
        });
        offset = {
          left: $.datepicker._pos[0],
          top: $.datepicker._pos[1]
        };
        $.datepicker._pos = null; //to avoid flashes on Firefox

        inst.dpDiv.empty(); // determine sizing offscreen

        inst.dpDiv.css({
          position: "absolute",
          display: "block",
          top: "-1000px"
        });

        $.datepicker._updateDatepicker(inst); // fix width for dynamic number of date pickers
        // and adjust position before showing


        offset = $.datepicker._checkOffset(inst, offset, isFixed);
        inst.dpDiv.css({
          position: $.datepicker._inDialog && $.blockUI ? "static" : isFixed ? "fixed" : "absolute",
          display: "none",
          left: offset.left + "px",
          top: offset.top + "px"
        });

        if (!inst.inline) {
          showAnim = $.datepicker._get(inst, "showAnim");
          duration = $.datepicker._get(inst, "duration");
          inst.dpDiv.css("z-index", datepicker_getZindex($(input)) + 1);
          $.datepicker._datepickerShowing = true;

          if ($.effects && $.effects.effect[showAnim]) {
            inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
          } else {
            inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
          }

          if ($.datepicker._shouldFocusInput(inst)) {
            inst.input.trigger("focus");
          }

          $.datepicker._curInst = inst;
        }
      },

      /* Generate the date picker content. */
      _updateDatepicker: function (inst) {
        this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)

        datepicker_instActive = inst; // for delegate hover events

        inst.dpDiv.empty().append(this._generateHTML(inst));

        this._attachHandlers(inst);

        var origyearshtml,
            numMonths = this._getNumberOfMonths(inst),
            cols = numMonths[1],
            width = 17,
            activeCell = inst.dpDiv.find("." + this._dayOverClass + " a");

        if (activeCell.length > 0) {
          datepicker_handleMouseover.apply(activeCell.get(0));
        }

        inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");

        if (cols > 1) {
          inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", width * cols + "em");
        }

        inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") + "Class"]("ui-datepicker-multi");
        inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl");

        if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
          inst.input.trigger("focus");
        } // Deffered render of the years select (to avoid flashes on Firefox)


        if (inst.yearshtml) {
          origyearshtml = inst.yearshtml;
          setTimeout(function () {
            //assure that inst.yearshtml didn't change.
            if (origyearshtml === inst.yearshtml && inst.yearshtml) {
              inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
            }

            origyearshtml = inst.yearshtml = null;
          }, 0);
        }
      },
      // #6694 - don't focus the input if it's already focused
      // this breaks the change event in IE
      // Support: IE and jQuery <1.9
      _shouldFocusInput: function (inst) {
        return inst.input && inst.input.is(":visible") && !inst.input.is(":disabled") && !inst.input.is(":focus");
      },

      /* Check positioning to remain on screen. */
      _checkOffset: function (inst, offset, isFixed) {
        var dpWidth = inst.dpDiv.outerWidth(),
            dpHeight = inst.dpDiv.outerHeight(),
            inputWidth = inst.input ? inst.input.outerWidth() : 0,
            inputHeight = inst.input ? inst.input.outerHeight() : 0,
            viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
            viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
        offset.left -= this._get(inst, "isRTL") ? dpWidth - inputWidth : 0;
        offset.left -= isFixed && offset.left === inst.input.offset().left ? $(document).scrollLeft() : 0;
        offset.top -= isFixed && offset.top === inst.input.offset().top + inputHeight ? $(document).scrollTop() : 0; // Now check if datepicker is showing outside window viewport - move to a better place if so.

        offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0);
        offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight) : 0);
        return offset;
      },

      /* Find an object's position on the screen. */
      _findPos: function (obj) {
        var position,
            inst = this._getInst(obj),
            isRTL = this._get(inst, "isRTL");

        while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
          obj = obj[isRTL ? "previousSibling" : "nextSibling"];
        }

        position = $(obj).offset();
        return [position.left, position.top];
      },

      /* Hide the date picker from view.
       * @param  input  element - the input field attached to the date picker
       */
      _hideDatepicker: function (input) {
        var showAnim,
            duration,
            postProcess,
            onClose,
            inst = this._curInst;

        if (!inst || input && inst !== $.data(input, "datepicker")) {
          return;
        }

        if (this._datepickerShowing) {
          showAnim = this._get(inst, "showAnim");
          duration = this._get(inst, "duration");

          postProcess = function () {
            $.datepicker._tidyDialog(inst);
          }; // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed


          if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
            inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
          } else {
            inst.dpDiv[showAnim === "slideDown" ? "slideUp" : showAnim === "fadeIn" ? "fadeOut" : "hide"](showAnim ? duration : null, postProcess);
          }

          if (!showAnim) {
            postProcess();
          }

          this._datepickerShowing = false;
          onClose = this._get(inst, "onClose");

          if (onClose) {
            onClose.apply(inst.input ? inst.input[0] : null, [inst.input ? inst.input.val() : "", inst]);
          }

          this._lastInput = null;

          if (this._inDialog) {
            this._dialogInput.css({
              position: "absolute",
              left: "0",
              top: "-100px"
            });

            if ($.blockUI) {
              $.unblockUI();
              $("body").append(this.dpDiv);
            }
          }

          this._inDialog = false;
        }
      },

      /* Tidy up after a dialog display. */
      _tidyDialog: function (inst) {
        inst.dpDiv.removeClass(this._dialogClass).off(".ui-datepicker-calendar");
      },

      /* Close date picker if clicked elsewhere. */
      _checkExternalClick: function (event) {
        if (!$.datepicker._curInst) {
          return;
        }

        var $target = $(event.target),
            inst = $.datepicker._getInst($target[0]);

        if ($target[0].id !== $.datepicker._mainDivId && $target.parents("#" + $.datepicker._mainDivId).length === 0 && !$target.hasClass($.datepicker.markerClassName) && !$target.closest("." + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) || $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst) {
          $.datepicker._hideDatepicker();
        }
      },

      /* Adjust one of the date sub-fields. */
      _adjustDate: function (id, offset, period) {
        var target = $(id),
            inst = this._getInst(target[0]);

        if (this._isDisabledDatepicker(target[0])) {
          return;
        }

        this._adjustInstDate(inst, offset + (period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
        period);

        this._updateDatepicker(inst);
      },

      /* Action for current link. */
      _gotoToday: function (id) {
        var date,
            target = $(id),
            inst = this._getInst(target[0]);

        if (this._get(inst, "gotoCurrent") && inst.currentDay) {
          inst.selectedDay = inst.currentDay;
          inst.drawMonth = inst.selectedMonth = inst.currentMonth;
          inst.drawYear = inst.selectedYear = inst.currentYear;
        } else {
          date = new Date();
          inst.selectedDay = date.getDate();
          inst.drawMonth = inst.selectedMonth = date.getMonth();
          inst.drawYear = inst.selectedYear = date.getFullYear();
        }

        this._notifyChange(inst);

        this._adjustDate(target);
      },

      /* Action for selecting a new month/year. */
      _selectMonthYear: function (id, select, period) {
        var target = $(id),
            inst = this._getInst(target[0]);

        inst["selected" + (period === "M" ? "Month" : "Year")] = inst["draw" + (period === "M" ? "Month" : "Year")] = parseInt(select.options[select.selectedIndex].value, 10);

        this._notifyChange(inst);

        this._adjustDate(target);
      },

      /* Action for selecting a day. */
      _selectDay: function (id, month, year, td) {
        var inst,
            target = $(id);

        if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
          return;
        }

        inst = this._getInst(target[0]);
        inst.selectedDay = inst.currentDay = $("a", td).html();
        inst.selectedMonth = inst.currentMonth = month;
        inst.selectedYear = inst.currentYear = year;

        this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear));
      },

      /* Erase the input field and hide the date picker. */
      _clearDate: function (id) {
        var target = $(id);

        this._selectDate(target, "");
      },

      /* Update the input field with the selected date. */
      _selectDate: function (id, dateStr) {
        var onSelect,
            target = $(id),
            inst = this._getInst(target[0]);

        dateStr = dateStr != null ? dateStr : this._formatDate(inst);

        if (inst.input) {
          inst.input.val(dateStr);
        }

        this._updateAlternate(inst);

        onSelect = this._get(inst, "onSelect");

        if (onSelect) {
          onSelect.apply(inst.input ? inst.input[0] : null, [dateStr, inst]); // trigger custom callback
        } else if (inst.input) {
          inst.input.trigger("change"); // fire the change event
        }

        if (inst.inline) {
          this._updateDatepicker(inst);
        } else {
          this._hideDatepicker();

          this._lastInput = inst.input[0];

          if (typeof inst.input[0] !== "object") {
            inst.input.trigger("focus"); // restore focus
          }

          this._lastInput = null;
        }
      },

      /* Update any alternate field to synchronise with the main field. */
      _updateAlternate: function (inst) {
        var altFormat,
            date,
            dateStr,
            altField = this._get(inst, "altField");

        if (altField) {
          // update alternate field too
          altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
          date = this._getDate(inst);
          dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
          $(altField).val(dateStr);
        }
      },

      /* Set as beforeShowDay function to prevent selection of weekends.
       * @param  date  Date - the date to customise
       * @return [boolean, string] - is this date selectable?, what is its CSS class?
       */
      noWeekends: function (date) {
        var day = date.getDay();
        return [day > 0 && day < 6, ""];
      },

      /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
       * @param  date  Date - the date to get the week for
       * @return  number - the number of the week within the year that contains this date
       */
      iso8601Week: function (date) {
        var time,
            checkDate = new Date(date.getTime()); // Find Thursday of this week starting on Monday

        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
        time = checkDate.getTime();
        checkDate.setMonth(0); // Compare with Jan 1

        checkDate.setDate(1);
        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
      },

      /* Parse a string value into a date object.
       * See formatDate below for the possible formats.
       *
       * @param  format string - the expected format of the date
       * @param  value string - the date in the above format
       * @param  settings Object - attributes include:
       *					shortYearCutoff  number - the cutoff year for determining the century (optional)
       *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
       *					dayNames		string[7] - names of the days from Sunday (optional)
       *					monthNamesShort string[12] - abbreviated names of the months (optional)
       *					monthNames		string[12] - names of the months (optional)
       * @return  Date - the extracted date value or null if value is blank
       */
      parseDate: function (format, value, settings) {
        if (format == null || value == null) {
          throw "Invalid arguments";
        }

        value = typeof value === "object" ? value.toString() : value + "";

        if (value === "") {
          return null;
        }

        var iFormat,
            dim,
            extra,
            iValue = 0,
            shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
            shortYearCutoff = typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp : new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10),
            dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
            dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
            monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
            monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
            year = -1,
            month = -1,
            day = -1,
            doy = -1,
            literal = false,
            date,
            // Check whether a format character is doubled
        lookAhead = function (match) {
          var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;

          if (matches) {
            iFormat++;
          }

          return matches;
        },
            // Extract a number from the string value
        getNumber = function (match) {
          var isDoubled = lookAhead(match),
              size = match === "@" ? 14 : match === "!" ? 20 : match === "y" && isDoubled ? 4 : match === "o" ? 3 : 2,
              minSize = match === "y" ? size : 1,
              digits = new RegExp("^\\d{" + minSize + "," + size + "}"),
              num = value.substring(iValue).match(digits);

          if (!num) {
            throw "Missing number at position " + iValue;
          }

          iValue += num[0].length;
          return parseInt(num[0], 10);
        },
            // Extract a name from the string value and convert to an index
        getName = function (match, shortNames, longNames) {
          var index = -1,
              names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
            return [[k, v]];
          }).sort(function (a, b) {
            return -(a[1].length - b[1].length);
          });
          $.each(names, function (i, pair) {
            var name = pair[1];

            if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
              index = pair[0];
              iValue += name.length;
              return false;
            }
          });

          if (index !== -1) {
            return index + 1;
          } else {
            throw "Unknown name at position " + iValue;
          }
        },
            // Confirm that a literal character matches the string value
        checkLiteral = function () {
          if (value.charAt(iValue) !== format.charAt(iFormat)) {
            throw "Unexpected literal at position " + iValue;
          }

          iValue++;
        };

        for (iFormat = 0; iFormat < format.length; iFormat++) {
          if (literal) {
            if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
              literal = false;
            } else {
              checkLiteral();
            }
          } else {
            switch (format.charAt(iFormat)) {
              case "d":
                day = getNumber("d");
                break;

              case "D":
                getName("D", dayNamesShort, dayNames);
                break;

              case "o":
                doy = getNumber("o");
                break;

              case "m":
                month = getNumber("m");
                break;

              case "M":
                month = getName("M", monthNamesShort, monthNames);
                break;

              case "y":
                year = getNumber("y");
                break;

              case "@":
                date = new Date(getNumber("@"));
                year = date.getFullYear();
                month = date.getMonth() + 1;
                day = date.getDate();
                break;

              case "!":
                date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
                year = date.getFullYear();
                month = date.getMonth() + 1;
                day = date.getDate();
                break;

              case "'":
                if (lookAhead("'")) {
                  checkLiteral();
                } else {
                  literal = true;
                }

                break;

              default:
                checkLiteral();
            }
          }
        }

        if (iValue < value.length) {
          extra = value.substr(iValue);

          if (!/^\s+/.test(extra)) {
            throw "Extra/unparsed characters found in date: " + extra;
          }
        }

        if (year === -1) {
          year = new Date().getFullYear();
        } else if (year < 100) {
          year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);
        }

        if (doy > -1) {
          month = 1;
          day = doy;

          do {
            dim = this._getDaysInMonth(year, month - 1);

            if (day <= dim) {
              break;
            }

            month++;
            day -= dim;
          } while (true);
        }

        date = this._daylightSavingAdjust(new Date(year, month - 1, day));

        if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
          throw "Invalid date"; // E.g. 31/02/00
        }

        return date;
      },

      /* Standard date formats. */
      ATOM: "yy-mm-dd",
      // RFC 3339 (ISO 8601)
      COOKIE: "D, dd M yy",
      ISO_8601: "yy-mm-dd",
      RFC_822: "D, d M y",
      RFC_850: "DD, dd-M-y",
      RFC_1036: "D, d M y",
      RFC_1123: "D, d M yy",
      RFC_2822: "D, d M yy",
      RSS: "D, d M y",
      // RFC 822
      TICKS: "!",
      TIMESTAMP: "@",
      W3C: "yy-mm-dd",
      // ISO 8601
      _ticksTo1970: ((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000,

      /* Format a date object into a string value.
       * The format can be combinations of the following:
       * d  - day of month (no leading zero)
       * dd - day of month (two digit)
       * o  - day of year (no leading zeros)
       * oo - day of year (three digit)
       * D  - day name short
       * DD - day name long
       * m  - month of year (no leading zero)
       * mm - month of year (two digit)
       * M  - month name short
       * MM - month name long
       * y  - year (two digit)
       * yy - year (four digit)
       * @ - Unix timestamp (ms since 01/01/1970)
       * ! - Windows ticks (100ns since 01/01/0001)
       * "..." - literal text
       * '' - single quote
       *
       * @param  format string - the desired format of the date
       * @param  date Date - the date value to format
       * @param  settings Object - attributes include:
       *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
       *					dayNames		string[7] - names of the days from Sunday (optional)
       *					monthNamesShort string[12] - abbreviated names of the months (optional)
       *					monthNames		string[12] - names of the months (optional)
       * @return  string - the date in the above format
       */
      formatDate: function (format, date, settings) {
        if (!date) {
          return "";
        }

        var iFormat,
            dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
            dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
            monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
            monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
            // Check whether a format character is doubled
        lookAhead = function (match) {
          var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;

          if (matches) {
            iFormat++;
          }

          return matches;
        },
            // Format a number, with leading zero if necessary
        formatNumber = function (match, value, len) {
          var num = "" + value;

          if (lookAhead(match)) {
            while (num.length < len) {
              num = "0" + num;
            }
          }

          return num;
        },
            // Format a name, short or long as requested
        formatName = function (match, value, shortNames, longNames) {
          return lookAhead(match) ? longNames[value] : shortNames[value];
        },
            output = "",
            literal = false;

        if (date) {
          for (iFormat = 0; iFormat < format.length; iFormat++) {
            if (literal) {
              if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                literal = false;
              } else {
                output += format.charAt(iFormat);
              }
            } else {
              switch (format.charAt(iFormat)) {
                case "d":
                  output += formatNumber("d", date.getDate(), 2);
                  break;

                case "D":
                  output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                  break;

                case "o":
                  output += formatNumber("o", Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
                  break;

                case "m":
                  output += formatNumber("m", date.getMonth() + 1, 2);
                  break;

                case "M":
                  output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                  break;

                case "y":
                  output += lookAhead("y") ? date.getFullYear() : (date.getFullYear() % 100 < 10 ? "0" : "") + date.getFullYear() % 100;
                  break;

                case "@":
                  output += date.getTime();
                  break;

                case "!":
                  output += date.getTime() * 10000 + this._ticksTo1970;
                  break;

                case "'":
                  if (lookAhead("'")) {
                    output += "'";
                  } else {
                    literal = true;
                  }

                  break;

                default:
                  output += format.charAt(iFormat);
              }
            }
          }
        }

        return output;
      },

      /* Extract all possible characters from the date format. */
      _possibleChars: function (format) {
        var iFormat,
            chars = "",
            literal = false,
            // Check whether a format character is doubled
        lookAhead = function (match) {
          var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;

          if (matches) {
            iFormat++;
          }

          return matches;
        };

        for (iFormat = 0; iFormat < format.length; iFormat++) {
          if (literal) {
            if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
              literal = false;
            } else {
              chars += format.charAt(iFormat);
            }
          } else {
            switch (format.charAt(iFormat)) {
              case "d":
              case "m":
              case "y":
              case "@":
                chars += "0123456789";
                break;

              case "D":
              case "M":
                return null;
              // Accept anything

              case "'":
                if (lookAhead("'")) {
                  chars += "'";
                } else {
                  literal = true;
                }

                break;

              default:
                chars += format.charAt(iFormat);
            }
          }
        }

        return chars;
      },

      /* Get a setting value, defaulting if necessary. */
      _get: function (inst, name) {
        return inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name];
      },

      /* Parse existing date and initialise date picker. */
      _setDateFromField: function (inst, noDefault) {
        if (inst.input.val() === inst.lastVal) {
          return;
        }

        var dateFormat = this._get(inst, "dateFormat"),
            dates = inst.lastVal = inst.input ? inst.input.val() : null,
            defaultDate = this._getDefaultDate(inst),
            date = defaultDate,
            settings = this._getFormatConfig(inst);

        try {
          date = this.parseDate(dateFormat, dates, settings) || defaultDate;
        } catch (event) {
          dates = noDefault ? "" : dates;
        }

        inst.selectedDay = date.getDate();
        inst.drawMonth = inst.selectedMonth = date.getMonth();
        inst.drawYear = inst.selectedYear = date.getFullYear();
        inst.currentDay = dates ? date.getDate() : 0;
        inst.currentMonth = dates ? date.getMonth() : 0;
        inst.currentYear = dates ? date.getFullYear() : 0;

        this._adjustInstDate(inst);
      },

      /* Retrieve the default date shown on opening. */
      _getDefaultDate: function (inst) {
        return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
      },

      /* A date may be specified as an exact value or a relative one. */
      _determineDate: function (inst, date, defaultDate) {
        var offsetNumeric = function (offset) {
          var date = new Date();
          date.setDate(date.getDate() + offset);
          return date;
        },
            offsetString = function (offset) {
          try {
            return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), offset, $.datepicker._getFormatConfig(inst));
          } catch (e) {// Ignore
          }

          var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(),
              year = date.getFullYear(),
              month = date.getMonth(),
              day = date.getDate(),
              pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
              matches = pattern.exec(offset);

          while (matches) {
            switch (matches[2] || "d") {
              case "d":
              case "D":
                day += parseInt(matches[1], 10);
                break;

              case "w":
              case "W":
                day += parseInt(matches[1], 10) * 7;
                break;

              case "m":
              case "M":
                month += parseInt(matches[1], 10);
                day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                break;

              case "y":
              case "Y":
                year += parseInt(matches[1], 10);
                day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                break;
            }

            matches = pattern.exec(offset);
          }

          return new Date(year, month, day);
        },
            newDate = date == null || date === "" ? defaultDate : typeof date === "string" ? offsetString(date) : typeof date === "number" ? isNaN(date) ? defaultDate : offsetNumeric(date) : new Date(date.getTime());

        newDate = newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate;

        if (newDate) {
          newDate.setHours(0);
          newDate.setMinutes(0);
          newDate.setSeconds(0);
          newDate.setMilliseconds(0);
        }

        return this._daylightSavingAdjust(newDate);
      },

      /* Handle switch to/from daylight saving.
       * Hours may be non-zero on daylight saving cut-over:
       * > 12 when midnight changeover, but then cannot generate
       * midnight datetime, so jump to 1AM, otherwise reset.
       * @param  date  (Date) the date to check
       * @return  (Date) the corrected date
       */
      _daylightSavingAdjust: function (date) {
        if (!date) {
          return null;
        }

        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
        return date;
      },

      /* Set the date(s) directly. */
      _setDate: function (inst, date, noChange) {
        var clear = !date,
            origMonth = inst.selectedMonth,
            origYear = inst.selectedYear,
            newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));

        inst.selectedDay = inst.currentDay = newDate.getDate();
        inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
        inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();

        if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
          this._notifyChange(inst);
        }

        this._adjustInstDate(inst);

        if (inst.input) {
          inst.input.val(clear ? "" : this._formatDate(inst));
        }
      },

      /* Retrieve the date(s) directly. */
      _getDate: function (inst) {
        var startDate = !inst.currentYear || inst.input && inst.input.val() === "" ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
        return startDate;
      },

      /* Attach the onxxx handlers.  These are declared statically so
       * they work with static code transformers like Caja.
       */
      _attachHandlers: function (inst) {
        var stepMonths = this._get(inst, "stepMonths"),
            id = "#" + inst.id.replace(/\\\\/g, "\\");

        inst.dpDiv.find("[data-handler]").map(function () {
          var handler = {
            prev: function () {
              $.datepicker._adjustDate(id, -stepMonths, "M");
            },
            next: function () {
              $.datepicker._adjustDate(id, +stepMonths, "M");
            },
            hide: function () {
              $.datepicker._hideDatepicker();
            },
            today: function () {
              $.datepicker._gotoToday(id);
            },
            selectDay: function () {
              $.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);

              return false;
            },
            selectMonth: function () {
              $.datepicker._selectMonthYear(id, this, "M");

              return false;
            },
            selectYear: function () {
              $.datepicker._selectMonthYear(id, this, "Y");

              return false;
            }
          };
          $(this).on(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
        });
      },

      /* Generate the HTML for the current state of the date picker. */
      _generateHTML: function (inst) {
        var maxDraw,
            prevText,
            prev,
            nextText,
            next,
            currentText,
            gotoDate,
            controls,
            buttonPanel,
            firstDay,
            showWeek,
            dayNames,
            dayNamesMin,
            monthNames,
            monthNamesShort,
            beforeShowDay,
            showOtherMonths,
            selectOtherMonths,
            defaultDate,
            html,
            dow,
            row,
            group,
            col,
            selectedDate,
            cornerClass,
            calender,
            thead,
            day,
            daysInMonth,
            leadDays,
            curRows,
            numRows,
            printDate,
            dRow,
            tbody,
            daySettings,
            otherMonth,
            unselectable,
            tempDate = new Date(),
            today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())),
            // clear time
        isRTL = this._get(inst, "isRTL"),
            showButtonPanel = this._get(inst, "showButtonPanel"),
            hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
            navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
            numMonths = this._getNumberOfMonths(inst),
            showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
            stepMonths = this._get(inst, "stepMonths"),
            isMultiMonth = numMonths[0] !== 1 || numMonths[1] !== 1,
            currentDate = this._daylightSavingAdjust(!inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay)),
            minDate = this._getMinMaxDate(inst, "min"),
            maxDate = this._getMinMaxDate(inst, "max"),
            drawMonth = inst.drawMonth - showCurrentAtPos,
            drawYear = inst.drawYear;

        if (drawMonth < 0) {
          drawMonth += 12;
          drawYear--;
        }

        if (maxDate) {
          maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - numMonths[0] * numMonths[1] + 1, maxDate.getDate()));
          maxDraw = minDate && maxDraw < minDate ? minDate : maxDraw;

          while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
            drawMonth--;

            if (drawMonth < 0) {
              drawMonth = 11;
              drawYear--;
            }
          }
        }

        inst.drawMonth = drawMonth;
        inst.drawYear = drawYear;
        prevText = this._get(inst, "prevText");
        prevText = !navigationAsDateFormat ? prevText : this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst));
        prev = this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" + " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>";
        nextText = this._get(inst, "nextText");
        nextText = !navigationAsDateFormat ? nextText : this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst));
        next = this._canAdjustMonth(inst, +1, drawYear, drawMonth) ? "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" + " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>";
        currentText = this._get(inst, "currentText");
        gotoDate = this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today;
        currentText = !navigationAsDateFormat ? currentText : this.formatDate(currentText, gotoDate, this._getFormatConfig(inst));
        controls = !inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" + this._get(inst, "closeText") + "</button>" : "";
        buttonPanel = showButtonPanel ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") + (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" + ">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";
        firstDay = parseInt(this._get(inst, "firstDay"), 10);
        firstDay = isNaN(firstDay) ? 0 : firstDay;
        showWeek = this._get(inst, "showWeek");
        dayNames = this._get(inst, "dayNames");
        dayNamesMin = this._get(inst, "dayNamesMin");
        monthNames = this._get(inst, "monthNames");
        monthNamesShort = this._get(inst, "monthNamesShort");
        beforeShowDay = this._get(inst, "beforeShowDay");
        showOtherMonths = this._get(inst, "showOtherMonths");
        selectOtherMonths = this._get(inst, "selectOtherMonths");
        defaultDate = this._getDefaultDate(inst);
        html = "";

        for (row = 0; row < numMonths[0]; row++) {
          group = "";
          this.maxRows = 4;

          for (col = 0; col < numMonths[1]; col++) {
            selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
            cornerClass = " ui-corner-all";
            calender = "";

            if (isMultiMonth) {
              calender += "<div class='ui-datepicker-group";

              if (numMonths[1] > 1) {
                switch (col) {
                  case 0:
                    calender += " ui-datepicker-group-first";
                    cornerClass = " ui-corner-" + (isRTL ? "right" : "left");
                    break;

                  case numMonths[1] - 1:
                    calender += " ui-datepicker-group-last";
                    cornerClass = " ui-corner-" + (isRTL ? "left" : "right");
                    break;

                  default:
                    calender += " ui-datepicker-group-middle";
                    cornerClass = "";
                    break;
                }
              }

              calender += "'>";
            }

            calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" + (/all|left/.test(cornerClass) && row === 0 ? isRTL ? next : prev : "") + (/all|right/.test(cornerClass) && row === 0 ? isRTL ? prev : next : "") + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
            "</div><table class='ui-datepicker-calendar'><thead>" + "<tr>";
            thead = showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "";

            for (dow = 0; dow < 7; dow++) {
              // days of the week
              day = (dow + firstDay) % 7;
              thead += "<th scope='col'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" + "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
            }

            calender += thead + "</tr></thead><tbody>";
            daysInMonth = this._getDaysInMonth(drawYear, drawMonth);

            if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
              inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
            }

            leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
            curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate

            numRows = isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows; //If multiple months, use the higher number of rows (see #7043)

            this.maxRows = numRows;
            printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));

            for (dRow = 0; dRow < numRows; dRow++) {
              // create date picker rows
              calender += "<tr>";
              tbody = !showWeek ? "" : "<td class='ui-datepicker-week-col'>" + this._get(inst, "calculateWeek")(printDate) + "</td>";

              for (dow = 0; dow < 7; dow++) {
                // create date picker days
                daySettings = beforeShowDay ? beforeShowDay.apply(inst.input ? inst.input[0] : null, [printDate]) : [true, ""];
                otherMonth = printDate.getMonth() !== drawMonth;
                unselectable = otherMonth && !selectOtherMonths || !daySettings[0] || minDate && printDate < minDate || maxDate && printDate > maxDate;
                tbody += "<td class='" + ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + ( // highlight weekends
                otherMonth ? " ui-datepicker-other-month" : "") + ( // highlight days from other months
                printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent || // user pressed key
                defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ? // or defaultDate is current printedDate and defaultDate is selectedDate
                " " + this._dayOverClass : "") + ( // highlight selected day
                unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "") + ( // highlight unselectable days
                otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + ( // highlight custom dates
                printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + ( // highlight selected day
                printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + ( // highlight today (if different)
                (!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + ( // cell title
                unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + ( // actions
                otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
                unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" + (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") + (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + ( // highlight selected day
                otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
                "' href='#'>" + printDate.getDate() + "</a>") + "</td>"; // display selectable date

                printDate.setDate(printDate.getDate() + 1);
                printDate = this._daylightSavingAdjust(printDate);
              }

              calender += tbody + "</tr>";
            }

            drawMonth++;

            if (drawMonth > 11) {
              drawMonth = 0;
              drawYear++;
            }

            calender += "</tbody></table>" + (isMultiMonth ? "</div>" + (numMonths[0] > 0 && col === numMonths[1] - 1 ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
            group += calender;
          }

          html += group;
        }

        html += buttonPanel;
        inst._keyEvent = false;
        return html;
      },

      /* Generate the month and year header. */
      _generateMonthYearHeader: function (inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) {
        var inMinYear,
            inMaxYear,
            month,
            years,
            thisYear,
            determineYear,
            year,
            endYear,
            changeMonth = this._get(inst, "changeMonth"),
            changeYear = this._get(inst, "changeYear"),
            showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
            html = "<div class='ui-datepicker-title'>",
            monthHtml = ""; // Month selection


        if (secondary || !changeMonth) {
          monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
        } else {
          inMinYear = minDate && minDate.getFullYear() === drawYear;
          inMaxYear = maxDate && maxDate.getFullYear() === drawYear;
          monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";

          for (month = 0; month < 12; month++) {
            if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
              monthHtml += "<option value='" + month + "'" + (month === drawMonth ? " selected='selected'" : "") + ">" + monthNamesShort[month] + "</option>";
            }
          }

          monthHtml += "</select>";
        }

        if (!showMonthAfterYear) {
          html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
        } // Year selection


        if (!inst.yearshtml) {
          inst.yearshtml = "";

          if (secondary || !changeYear) {
            html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
          } else {
            // determine range of years to display
            years = this._get(inst, "yearRange").split(":");
            thisYear = new Date().getFullYear();

            determineYear = function (value) {
              var year = value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) : value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10);
              return isNaN(year) ? thisYear : year;
            };

            year = determineYear(years[0]);
            endYear = Math.max(year, determineYear(years[1] || ""));
            year = minDate ? Math.max(year, minDate.getFullYear()) : year;
            endYear = maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear;
            inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";

            for (; year <= endYear; year++) {
              inst.yearshtml += "<option value='" + year + "'" + (year === drawYear ? " selected='selected'" : "") + ">" + year + "</option>";
            }

            inst.yearshtml += "</select>";
            html += inst.yearshtml;
            inst.yearshtml = null;
          }
        }

        html += this._get(inst, "yearSuffix");

        if (showMonthAfterYear) {
          html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
        }

        html += "</div>"; // Close datepicker_header

        return html;
      },

      /* Adjust one of the date sub-fields. */
      _adjustInstDate: function (inst, offset, period) {
        var year = inst.selectedYear + (period === "Y" ? offset : 0),
            month = inst.selectedMonth + (period === "M" ? offset : 0),
            day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
            date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

        inst.selectedDay = date.getDate();
        inst.drawMonth = inst.selectedMonth = date.getMonth();
        inst.drawYear = inst.selectedYear = date.getFullYear();

        if (period === "M" || period === "Y") {
          this._notifyChange(inst);
        }
      },

      /* Ensure a date is within any min/max bounds. */
      _restrictMinMax: function (inst, date) {
        var minDate = this._getMinMaxDate(inst, "min"),
            maxDate = this._getMinMaxDate(inst, "max"),
            newDate = minDate && date < minDate ? minDate : date;

        return maxDate && newDate > maxDate ? maxDate : newDate;
      },

      /* Notify change of month/year. */
      _notifyChange: function (inst) {
        var onChange = this._get(inst, "onChangeMonthYear");

        if (onChange) {
          onChange.apply(inst.input ? inst.input[0] : null, [inst.selectedYear, inst.selectedMonth + 1, inst]);
        }
      },

      /* Determine the number of months to show. */
      _getNumberOfMonths: function (inst) {
        var numMonths = this._get(inst, "numberOfMonths");

        return numMonths == null ? [1, 1] : typeof numMonths === "number" ? [1, numMonths] : numMonths;
      },

      /* Determine the current maximum date - ensure no time components are set. */
      _getMinMaxDate: function (inst, minMax) {
        return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
      },

      /* Find the number of days in a given month. */
      _getDaysInMonth: function (year, month) {
        return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
      },

      /* Find the day of the week of the first of a month. */
      _getFirstDayOfMonth: function (year, month) {
        return new Date(year, month, 1).getDay();
      },

      /* Determines if we should allow a "next/prev" month display change. */
      _canAdjustMonth: function (inst, offset, curYear, curMonth) {
        var numMonths = this._getNumberOfMonths(inst),
            date = this._daylightSavingAdjust(new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));

        if (offset < 0) {
          date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
        }

        return this._isInRange(inst, date);
      },

      /* Is the given date in the accepted range? */
      _isInRange: function (inst, date) {
        var yearSplit,
            currentYear,
            minDate = this._getMinMaxDate(inst, "min"),
            maxDate = this._getMinMaxDate(inst, "max"),
            minYear = null,
            maxYear = null,
            years = this._get(inst, "yearRange");

        if (years) {
          yearSplit = years.split(":");
          currentYear = new Date().getFullYear();
          minYear = parseInt(yearSplit[0], 10);
          maxYear = parseInt(yearSplit[1], 10);

          if (yearSplit[0].match(/[+\-].*/)) {
            minYear += currentYear;
          }

          if (yearSplit[1].match(/[+\-].*/)) {
            maxYear += currentYear;
          }
        }

        return (!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear);
      },

      /* Provide the configuration settings for formatting/parsing. */
      _getFormatConfig: function (inst) {
        var shortYearCutoff = this._get(inst, "shortYearCutoff");

        shortYearCutoff = typeof shortYearCutoff !== "string" ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10);
        return {
          shortYearCutoff: shortYearCutoff,
          dayNamesShort: this._get(inst, "dayNamesShort"),
          dayNames: this._get(inst, "dayNames"),
          monthNamesShort: this._get(inst, "monthNamesShort"),
          monthNames: this._get(inst, "monthNames")
        };
      },

      /* Format the given date for display. */
      _formatDate: function (inst, day, month, year) {
        if (!day) {
          inst.currentDay = inst.selectedDay;
          inst.currentMonth = inst.selectedMonth;
          inst.currentYear = inst.selectedYear;
        }

        var date = day ? typeof day === "object" ? day : this._daylightSavingAdjust(new Date(year, month, day)) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
        return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
      }
    });
    /*
     * Bind hover events for datepicker elements.
     * Done via delegate so the binding only occurs once in the lifetime of the parent div.
     * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
     */

    function datepicker_bindHover(dpDiv) {
      var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
      return dpDiv.on("mouseout", selector, function () {
        $(this).removeClass("ui-state-hover");

        if (this.className.indexOf("ui-datepicker-prev") !== -1) {
          $(this).removeClass("ui-datepicker-prev-hover");
        }

        if (this.className.indexOf("ui-datepicker-next") !== -1) {
          $(this).removeClass("ui-datepicker-next-hover");
        }
      }).on("mouseover", selector, datepicker_handleMouseover);
    }

    function datepicker_handleMouseover() {
      if (!$.datepicker._isDisabledDatepicker(datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {
        $(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
        $(this).addClass("ui-state-hover");

        if (this.className.indexOf("ui-datepicker-prev") !== -1) {
          $(this).addClass("ui-datepicker-prev-hover");
        }

        if (this.className.indexOf("ui-datepicker-next") !== -1) {
          $(this).addClass("ui-datepicker-next-hover");
        }
      }
    }
    /* jQuery extend now ignores nulls! */


    function datepicker_extendRemove(target, props) {
      $.extend(target, props);

      for (var name in props) {
        if (props[name] == null) {
          target[name] = props[name];
        }
      }

      return target;
    }
    /* Invoke the datepicker functionality.
       @param  options  string - a command, optionally followed by additional parameters or
    					Object - settings for attaching new datepicker functionality
       @return  jQuery object */


    $.fn.datepicker = function (options) {
      /* Verify an empty collection wasn't passed - Fixes #6976 */
      if (!this.length) {
        return this;
      }
      /* Initialise the date picker. */


      if (!$.datepicker.initialized) {
        $(document).on("mousedown", $.datepicker._checkExternalClick);
        $.datepicker.initialized = true;
      }
      /* Append datepicker main container to body if not exist. */


      if ($("#" + $.datepicker._mainDivId).length === 0) {
        $("body").append($.datepicker.dpDiv);
      }

      var otherArgs = Array.prototype.slice.call(arguments, 1);

      if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
        return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [this[0]].concat(otherArgs));
      }

      if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
        return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [this[0]].concat(otherArgs));
      }

      return this.each(function () {
        typeof options === "string" ? $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [this].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options);
      });
    };

    $.datepicker = new Datepicker(); // singleton instance

    $.datepicker.initialized = false;
    $.datepicker.uuid = new Date().getTime();
    $.datepicker.version = "1.12.1";
    var widgetsDatepicker = $.datepicker;
    /*!
     * jQuery UI Slider 1.12.1
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */
    //>>label: Slider
    //>>group: Widgets
    //>>description: Displays a flexible slider with ranges and accessibility via keyboard.
    //>>docs: http://api.jqueryui.com/slider/
    //>>demos: http://jqueryui.com/slider/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/slider.css
    //>>css.theme: ../../themes/base/theme.css

    var widgetsSlider = $.widget("ui.slider", $.ui.mouse, {
      version: "1.12.1",
      widgetEventPrefix: "slide",
      options: {
        animate: false,
        classes: {
          "ui-slider": "ui-corner-all",
          "ui-slider-handle": "ui-corner-all",
          // Note: ui-widget-header isn't the most fittingly semantic framework class for this
          // element, but worked best visually with a variety of themes
          "ui-slider-range": "ui-corner-all ui-widget-header"
        },
        distance: 0,
        max: 100,
        min: 0,
        orientation: "horizontal",
        range: false,
        step: 1,
        value: 0,
        values: null,
        // Callbacks
        change: null,
        slide: null,
        start: null,
        stop: null
      },
      // Number of pages in a slider
      // (how many times can you page up/down to go through the whole range)
      numPages: 5,
      _create: function () {
        this._keySliding = false;
        this._mouseSliding = false;
        this._animateOff = true;
        this._handleIndex = null;

        this._detectOrientation();

        this._mouseInit();

        this._calculateNewMax();

        this._addClass("ui-slider ui-slider-" + this.orientation, "ui-widget ui-widget-content");

        this._refresh();

        this._animateOff = false;
      },
      _refresh: function () {
        this._createRange();

        this._createHandles();

        this._setupEvents();

        this._refreshValue();
      },
      _createHandles: function () {
        var i,
            handleCount,
            options = this.options,
            existingHandles = this.element.find(".ui-slider-handle"),
            handle = "<span tabindex='0'></span>",
            handles = [];
        handleCount = options.values && options.values.length || 1;

        if (existingHandles.length > handleCount) {
          existingHandles.slice(handleCount).remove();
          existingHandles = existingHandles.slice(0, handleCount);
        }

        for (i = existingHandles.length; i < handleCount; i++) {
          handles.push(handle);
        }

        this.handles = existingHandles.add($(handles.join("")).appendTo(this.element));

        this._addClass(this.handles, "ui-slider-handle", "ui-state-default");

        this.handle = this.handles.eq(0);
        this.handles.each(function (i) {
          $(this).data("ui-slider-handle-index", i).attr("tabIndex", 0);
        });
      },
      _createRange: function () {
        var options = this.options;

        if (options.range) {
          if (options.range === true) {
            if (!options.values) {
              options.values = [this._valueMin(), this._valueMin()];
            } else if (options.values.length && options.values.length !== 2) {
              options.values = [options.values[0], options.values[0]];
            } else if ($.isArray(options.values)) {
              options.values = options.values.slice(0);
            }
          }

          if (!this.range || !this.range.length) {
            this.range = $("<div>").appendTo(this.element);

            this._addClass(this.range, "ui-slider-range");
          } else {
            this._removeClass(this.range, "ui-slider-range-min ui-slider-range-max"); // Handle range switching from true to min/max


            this.range.css({
              "left": "",
              "bottom": ""
            });
          }

          if (options.range === "min" || options.range === "max") {
            this._addClass(this.range, "ui-slider-range-" + options.range);
          }
        } else {
          if (this.range) {
            this.range.remove();
          }

          this.range = null;
        }
      },
      _setupEvents: function () {
        this._off(this.handles);

        this._on(this.handles, this._handleEvents);

        this._hoverable(this.handles);

        this._focusable(this.handles);
      },
      _destroy: function () {
        this.handles.remove();

        if (this.range) {
          this.range.remove();
        }

        this._mouseDestroy();
      },
      _mouseCapture: function (event) {
        var position,
            normValue,
            distance,
            closestHandle,
            index,
            allowed,
            offset,
            mouseOverHandle,
            that = this,
            o = this.options;

        if (o.disabled) {
          return false;
        }

        this.elementSize = {
          width: this.element.outerWidth(),
          height: this.element.outerHeight()
        };
        this.elementOffset = this.element.offset();
        position = {
          x: event.pageX,
          y: event.pageY
        };
        normValue = this._normValueFromMouse(position);
        distance = this._valueMax() - this._valueMin() + 1;
        this.handles.each(function (i) {
          var thisDistance = Math.abs(normValue - that.values(i));

          if (distance > thisDistance || distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min)) {
            distance = thisDistance;
            closestHandle = $(this);
            index = i;
          }
        });
        allowed = this._start(event, index);

        if (allowed === false) {
          return false;
        }

        this._mouseSliding = true;
        this._handleIndex = index;

        this._addClass(closestHandle, null, "ui-state-active");

        closestHandle.trigger("focus");
        offset = closestHandle.offset();
        mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle");
        this._clickOffset = mouseOverHandle ? {
          left: 0,
          top: 0
        } : {
          left: event.pageX - offset.left - closestHandle.width() / 2,
          top: event.pageY - offset.top - closestHandle.height() / 2 - (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) - (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) + (parseInt(closestHandle.css("marginTop"), 10) || 0)
        };

        if (!this.handles.hasClass("ui-state-hover")) {
          this._slide(event, index, normValue);
        }

        this._animateOff = true;
        return true;
      },
      _mouseStart: function () {
        return true;
      },
      _mouseDrag: function (event) {
        var position = {
          x: event.pageX,
          y: event.pageY
        },
            normValue = this._normValueFromMouse(position);

        this._slide(event, this._handleIndex, normValue);

        return false;
      },
      _mouseStop: function (event) {
        this._removeClass(this.handles, null, "ui-state-active");

        this._mouseSliding = false;

        this._stop(event, this._handleIndex);

        this._change(event, this._handleIndex);

        this._handleIndex = null;
        this._clickOffset = null;
        this._animateOff = false;
        return false;
      },
      _detectOrientation: function () {
        this.orientation = this.options.orientation === "vertical" ? "vertical" : "horizontal";
      },
      _normValueFromMouse: function (position) {
        var pixelTotal, pixelMouse, percentMouse, valueTotal, valueMouse;

        if (this.orientation === "horizontal") {
          pixelTotal = this.elementSize.width;
          pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);
        } else {
          pixelTotal = this.elementSize.height;
          pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);
        }

        percentMouse = pixelMouse / pixelTotal;

        if (percentMouse > 1) {
          percentMouse = 1;
        }

        if (percentMouse < 0) {
          percentMouse = 0;
        }

        if (this.orientation === "vertical") {
          percentMouse = 1 - percentMouse;
        }

        valueTotal = this._valueMax() - this._valueMin();
        valueMouse = this._valueMin() + percentMouse * valueTotal;
        return this._trimAlignValue(valueMouse);
      },
      _uiHash: function (index, value, values) {
        var uiHash = {
          handle: this.handles[index],
          handleIndex: index,
          value: value !== undefined ? value : this.value()
        };

        if (this._hasMultipleValues()) {
          uiHash.value = value !== undefined ? value : this.values(index);
          uiHash.values = values || this.values();
        }

        return uiHash;
      },
      _hasMultipleValues: function () {
        return this.options.values && this.options.values.length;
      },
      _start: function (event, index) {
        return this._trigger("start", event, this._uiHash(index));
      },
      _slide: function (event, index, newVal) {
        var allowed,
            otherVal,
            currentValue = this.value(),
            newValues = this.values();

        if (this._hasMultipleValues()) {
          otherVal = this.values(index ? 0 : 1);
          currentValue = this.values(index);

          if (this.options.values.length === 2 && this.options.range === true) {
            newVal = index === 0 ? Math.min(otherVal, newVal) : Math.max(otherVal, newVal);
          }

          newValues[index] = newVal;
        }

        if (newVal === currentValue) {
          return;
        }

        allowed = this._trigger("slide", event, this._uiHash(index, newVal, newValues)); // A slide can be canceled by returning false from the slide callback

        if (allowed === false) {
          return;
        }

        if (this._hasMultipleValues()) {
          this.values(index, newVal);
        } else {
          this.value(newVal);
        }
      },
      _stop: function (event, index) {
        this._trigger("stop", event, this._uiHash(index));
      },
      _change: function (event, index) {
        if (!this._keySliding && !this._mouseSliding) {
          //store the last changed value index for reference when handles overlap
          this._lastChangedValue = index;

          this._trigger("change", event, this._uiHash(index));
        }
      },
      value: function (newValue) {
        if (arguments.length) {
          this.options.value = this._trimAlignValue(newValue);

          this._refreshValue();

          this._change(null, 0);

          return;
        }

        return this._value();
      },
      values: function (index, newValue) {
        var vals, newValues, i;

        if (arguments.length > 1) {
          this.options.values[index] = this._trimAlignValue(newValue);

          this._refreshValue();

          this._change(null, index);

          return;
        }

        if (arguments.length) {
          if ($.isArray(arguments[0])) {
            vals = this.options.values;
            newValues = arguments[0];

            for (i = 0; i < vals.length; i += 1) {
              vals[i] = this._trimAlignValue(newValues[i]);

              this._change(null, i);
            }

            this._refreshValue();
          } else {
            if (this._hasMultipleValues()) {
              return this._values(index);
            } else {
              return this.value();
            }
          }
        } else {
          return this._values();
        }
      },
      _setOption: function (key, value) {
        var i,
            valsLength = 0;

        if (key === "range" && this.options.range === true) {
          if (value === "min") {
            this.options.value = this._values(0);
            this.options.values = null;
          } else if (value === "max") {
            this.options.value = this._values(this.options.values.length - 1);
            this.options.values = null;
          }
        }

        if ($.isArray(this.options.values)) {
          valsLength = this.options.values.length;
        }

        this._super(key, value);

        switch (key) {
          case "orientation":
            this._detectOrientation();

            this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-" + this.orientation);

            this._refreshValue();

            if (this.options.range) {
              this._refreshRange(value);
            } // Reset positioning from previous orientation


            this.handles.css(value === "horizontal" ? "bottom" : "left", "");
            break;

          case "value":
            this._animateOff = true;

            this._refreshValue();

            this._change(null, 0);

            this._animateOff = false;
            break;

          case "values":
            this._animateOff = true;

            this._refreshValue(); // Start from the last handle to prevent unreachable handles (#9046)


            for (i = valsLength - 1; i >= 0; i--) {
              this._change(null, i);
            }

            this._animateOff = false;
            break;

          case "step":
          case "min":
          case "max":
            this._animateOff = true;

            this._calculateNewMax();

            this._refreshValue();

            this._animateOff = false;
            break;

          case "range":
            this._animateOff = true;

            this._refresh();

            this._animateOff = false;
            break;
        }
      },
      _setOptionDisabled: function (value) {
        this._super(value);

        this._toggleClass(null, "ui-state-disabled", !!value);
      },
      //internal value getter
      // _value() returns value trimmed by min and max, aligned by step
      _value: function () {
        var val = this.options.value;
        val = this._trimAlignValue(val);
        return val;
      },
      //internal values getter
      // _values() returns array of values trimmed by min and max, aligned by step
      // _values( index ) returns single value trimmed by min and max, aligned by step
      _values: function (index) {
        var val, vals, i;

        if (arguments.length) {
          val = this.options.values[index];
          val = this._trimAlignValue(val);
          return val;
        } else if (this._hasMultipleValues()) {
          // .slice() creates a copy of the array
          // this copy gets trimmed by min and max and then returned
          vals = this.options.values.slice();

          for (i = 0; i < vals.length; i += 1) {
            vals[i] = this._trimAlignValue(vals[i]);
          }

          return vals;
        } else {
          return [];
        }
      },
      // Returns the step-aligned value that val is closest to, between (inclusive) min and max
      _trimAlignValue: function (val) {
        if (val <= this._valueMin()) {
          return this._valueMin();
        }

        if (val >= this._valueMax()) {
          return this._valueMax();
        }

        var step = this.options.step > 0 ? this.options.step : 1,
            valModStep = (val - this._valueMin()) % step,
            alignValue = val - valModStep;

        if (Math.abs(valModStep) * 2 >= step) {
          alignValue += valModStep > 0 ? step : -step;
        } // Since JavaScript has problems with large floats, round
        // the final value to 5 digits after the decimal point (see #4124)


        return parseFloat(alignValue.toFixed(5));
      },
      _calculateNewMax: function () {
        var max = this.options.max,
            min = this._valueMin(),
            step = this.options.step,
            aboveMin = Math.round((max - min) / step) * step;

        max = aboveMin + min;

        if (max > this.options.max) {
          //If max is not divisible by step, rounding off may increase its value
          max -= step;
        }

        this.max = parseFloat(max.toFixed(this._precision()));
      },
      _precision: function () {
        var precision = this._precisionOf(this.options.step);

        if (this.options.min !== null) {
          precision = Math.max(precision, this._precisionOf(this.options.min));
        }

        return precision;
      },
      _precisionOf: function (num) {
        var str = num.toString(),
            decimal = str.indexOf(".");
        return decimal === -1 ? 0 : str.length - decimal - 1;
      },
      _valueMin: function () {
        return this.options.min;
      },
      _valueMax: function () {
        return this.max;
      },
      _refreshRange: function (orientation) {
        if (orientation === "vertical") {
          this.range.css({
            "width": "",
            "left": ""
          });
        }

        if (orientation === "horizontal") {
          this.range.css({
            "height": "",
            "bottom": ""
          });
        }
      },
      _refreshValue: function () {
        var lastValPercent,
            valPercent,
            value,
            valueMin,
            valueMax,
            oRange = this.options.range,
            o = this.options,
            that = this,
            animate = !this._animateOff ? o.animate : false,
            _set = {};

        if (this._hasMultipleValues()) {
          this.handles.each(function (i) {
            valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;
            _set[that.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
            $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);

            if (that.options.range === true) {
              if (that.orientation === "horizontal") {
                if (i === 0) {
                  that.range.stop(1, 1)[animate ? "animate" : "css"]({
                    left: valPercent + "%"
                  }, o.animate);
                }

                if (i === 1) {
                  that.range[animate ? "animate" : "css"]({
                    width: valPercent - lastValPercent + "%"
                  }, {
                    queue: false,
                    duration: o.animate
                  });
                }
              } else {
                if (i === 0) {
                  that.range.stop(1, 1)[animate ? "animate" : "css"]({
                    bottom: valPercent + "%"
                  }, o.animate);
                }

                if (i === 1) {
                  that.range[animate ? "animate" : "css"]({
                    height: valPercent - lastValPercent + "%"
                  }, {
                    queue: false,
                    duration: o.animate
                  });
                }
              }
            }

            lastValPercent = valPercent;
          });
        } else {
          value = this.value();
          valueMin = this._valueMin();
          valueMax = this._valueMax();
          valPercent = valueMax !== valueMin ? (value - valueMin) / (valueMax - valueMin) * 100 : 0;
          _set[this.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
          this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);

          if (oRange === "min" && this.orientation === "horizontal") {
            this.range.stop(1, 1)[animate ? "animate" : "css"]({
              width: valPercent + "%"
            }, o.animate);
          }

          if (oRange === "max" && this.orientation === "horizontal") {
            this.range.stop(1, 1)[animate ? "animate" : "css"]({
              width: 100 - valPercent + "%"
            }, o.animate);
          }

          if (oRange === "min" && this.orientation === "vertical") {
            this.range.stop(1, 1)[animate ? "animate" : "css"]({
              height: valPercent + "%"
            }, o.animate);
          }

          if (oRange === "max" && this.orientation === "vertical") {
            this.range.stop(1, 1)[animate ? "animate" : "css"]({
              height: 100 - valPercent + "%"
            }, o.animate);
          }
        }
      },
      _handleEvents: {
        keydown: function (event) {
          var allowed,
              curVal,
              newVal,
              step,
              index = $(event.target).data("ui-slider-handle-index");

          switch (event.keyCode) {
            case $.ui.keyCode.HOME:
            case $.ui.keyCode.END:
            case $.ui.keyCode.PAGE_UP:
            case $.ui.keyCode.PAGE_DOWN:
            case $.ui.keyCode.UP:
            case $.ui.keyCode.RIGHT:
            case $.ui.keyCode.DOWN:
            case $.ui.keyCode.LEFT:
              event.preventDefault();

              if (!this._keySliding) {
                this._keySliding = true;

                this._addClass($(event.target), null, "ui-state-active");

                allowed = this._start(event, index);

                if (allowed === false) {
                  return;
                }
              }

              break;
          }

          step = this.options.step;

          if (this._hasMultipleValues()) {
            curVal = newVal = this.values(index);
          } else {
            curVal = newVal = this.value();
          }

          switch (event.keyCode) {
            case $.ui.keyCode.HOME:
              newVal = this._valueMin();
              break;

            case $.ui.keyCode.END:
              newVal = this._valueMax();
              break;

            case $.ui.keyCode.PAGE_UP:
              newVal = this._trimAlignValue(curVal + (this._valueMax() - this._valueMin()) / this.numPages);
              break;

            case $.ui.keyCode.PAGE_DOWN:
              newVal = this._trimAlignValue(curVal - (this._valueMax() - this._valueMin()) / this.numPages);
              break;

            case $.ui.keyCode.UP:
            case $.ui.keyCode.RIGHT:
              if (curVal === this._valueMax()) {
                return;
              }

              newVal = this._trimAlignValue(curVal + step);
              break;

            case $.ui.keyCode.DOWN:
            case $.ui.keyCode.LEFT:
              if (curVal === this._valueMin()) {
                return;
              }

              newVal = this._trimAlignValue(curVal - step);
              break;
          }

          this._slide(event, index, newVal);
        },
        keyup: function (event) {
          var index = $(event.target).data("ui-slider-handle-index");

          if (this._keySliding) {
            this._keySliding = false;

            this._stop(event, index);

            this._change(event, index);

            this._removeClass($(event.target), null, "ui-state-active");
          }
        }
      }
    });
  });

  /*!
   * jQuery UI Touch Punch 0.2.3
   *
   * Copyright 2011–2014, Dave Furfero
   * Dual licensed under the MIT or GPL Version 2 licenses.
   *
   * Depends:
   *  jquery.ui.widget.js
   *  jquery.ui.mouse.js
   */
  !function (a) {
    function f(a, b) {
      if (!(a.originalEvent.touches.length > 1)) {
        a.preventDefault();
        var c = a.originalEvent.changedTouches[0],
            d = document.createEvent("MouseEvents");
        d.initMouseEvent(b, !0, !0, window, 1, c.screenX, c.screenY, c.clientX, c.clientY, !1, !1, !1, !1, 0, null), a.target.dispatchEvent(d);
      }
    }

    if (a.support.touch = "ontouchend" in document, a.support.touch) {
      var e,
          b = a.ui.mouse.prototype,
          c = b._mouseInit,
          d = b._mouseDestroy;
      b._touchStart = function (a) {
        var b = this;
        !e && b._mouseCapture(a.originalEvent.changedTouches[0]) && (e = !0, b._touchMoved = !1, f(a, "mouseover"), f(a, "mousemove"), f(a, "mousedown"));
      }, b._touchMove = function (a) {
        e && (this._touchMoved = !0, f(a, "mousemove"));
      }, b._touchEnd = function (a) {
        e && (f(a, "mouseup"), f(a, "mouseout"), this._touchMoved || f(a, "click"), e = !1);
      }, b._mouseInit = function () {
        var b = this;
        b.element.bind({
          touchstart: a.proxy(b, "_touchStart"),
          touchmove: a.proxy(b, "_touchMove"),
          touchend: a.proxy(b, "_touchEnd")
        }), c.call(b);
      }, b._mouseDestroy = function () {
        var b = this;
        b.element.unbind({
          touchstart: a.proxy(b, "_touchStart"),
          touchmove: a.proxy(b, "_touchMove"),
          touchend: a.proxy(b, "_touchEnd")
        }), d.call(b);
      };
    }
  }(jQuery);

  /*!
   * @fileOverview TouchSwipe - jQuery Plugin
   * @version 1.6.18
   *
   * @author Matt Bryson http://www.github.com/mattbryson
   * @see https://github.com/mattbryson/TouchSwipe-Jquery-Plugin
   * @see http://labs.rampinteractive.co.uk/touchSwipe/
   * @see http://plugins.jquery.com/project/touchSwipe
   * @license
   * Copyright (c) 2010-2015 Matt Bryson
   * Dual licensed under the MIT or GPL Version 2 licenses.
   *
   */

  /*
   *
   * Changelog
   * $Date: 2010-12-12 (Wed, 12 Dec 2010) $
   * $version: 1.0.0
   * $version: 1.0.1 - removed multibyte comments
   *
   * $Date: 2011-21-02 (Mon, 21 Feb 2011) $
   * $version: 1.1.0 	- added allowPageScroll property to allow swiping and scrolling of page
   *					- changed handler signatures so one handler can be used for multiple events
   * $Date: 2011-23-02 (Wed, 23 Feb 2011) $
   * $version: 1.2.0 	- added click handler. This is fired if the user simply clicks and does not swipe. The event object and click target are passed to handler.
   *					- If you use the http://code.google.com/p/jquery-ui-for-ipad-and-iphone/ plugin, you can also assign jQuery mouse events to children of a touchSwipe object.
   * $version: 1.2.1 	- removed console log!
   *
   * $version: 1.2.2 	- Fixed bug where scope was not preserved in callback methods.
   *
   * $Date: 2011-28-04 (Thurs, 28 April 2011) $
   * $version: 1.2.4 	- Changed licence terms to be MIT or GPL inline with jQuery. Added check for support of touch events to stop non compatible browsers erroring.
   *
   * $Date: 2011-27-09 (Tues, 27 September 2011) $
   * $version: 1.2.5 	- Added support for testing swipes with mouse on desktop browser (thanks to https://github.com/joelhy)
   *
   * $Date: 2012-14-05 (Mon, 14 May 2012) $
   * $version: 1.2.6 	- Added timeThreshold between start and end touch, so user can ignore slow swipes (thanks to Mark Chase). Default is null, all swipes are detected
   *
   * $Date: 2012-05-06 (Tues, 05 June 2012) $
   * $version: 1.2.7 	- Changed time threshold to have null default for backwards compatibility. Added duration param passed back in events, and refactored how time is handled.
   *
   * $Date: 2012-05-06 (Tues, 05 June 2012) $
   * $version: 1.2.8 	- Added the possibility to return a value like null or false in the trigger callback. In that way we can control when the touch start/move should take effect or not (simply by returning in some cases return null; or return false;) This effects the ontouchstart/ontouchmove event.
   *
   * $Date: 2012-06-06 (Wed, 06 June 2012) $
   * $version: 1.3.0 	- Refactored whole plugin to allow for methods to be executed, as well as exposed defaults for user override. Added 'enable', 'disable', and 'destroy' methods
   *
   * $Date: 2012-05-06 (Fri, 05 June 2012) $
   * $version: 1.3.1 	- Bug fixes  - bind() with false as last argument is no longer supported in jQuery 1.6, also, if you just click, the duration is now returned correctly.
   *
   * $Date: 2012-29-07 (Sun, 29 July 2012) $
   * $version: 1.3.2	- Added fallbackToMouseEvents option to NOT capture mouse events on non touch devices.
   * 			- Added "all" fingers value to the fingers property, so any combination of fingers triggers the swipe, allowing event handlers to check the finger count
   *
   * $Date: 2012-09-08 (Thurs, 9 Aug 2012) $
   * $version: 1.3.3	- Code tidy prep for minefied version
   *
   * $Date: 2012-04-10 (wed, 4 Oct 2012) $
   * $version: 1.4.0	- Added pinch support, pinchIn and pinchOut
   *
   * $Date: 2012-11-10 (Thurs, 11 Oct 2012) $
   * $version: 1.5.0	- Added excludedElements, a jquery selector that specifies child elements that do NOT trigger swipes. By default, this is .noSwipe
   *
   * $Date: 2012-22-10 (Mon, 22 Oct 2012) $
   * $version: 1.5.1	- Fixed bug with jQuery 1.8 and trailing comma in excludedElements
   *					- Fixed bug with IE and eventPreventDefault()
   * $Date: 2013-01-12 (Fri, 12 Jan 2013) $
   * $version: 1.6.0	- Fixed bugs with pinching, mainly when both pinch and swipe enabled, as well as adding time threshold for multifinger gestures, so releasing one finger beofre the other doesnt trigger as single finger gesture.
   *					- made the demo site all static local HTML pages so they can be run locally by a developer
   *					- added jsDoc comments and added documentation for the plugin
   *					- code tidy
   *					- added triggerOnTouchLeave property that will end the event when the user swipes off the element.
   * $Date: 2013-03-23 (Sat, 23 Mar 2013) $
   * $version: 1.6.1	- Added support for ie8 touch events
   * $version: 1.6.2	- Added support for events binding with on / off / bind in jQ for all callback names.
   *                   - Deprecated the 'click' handler in favour of tap.
   *                   - added cancelThreshold property
   *                   - added option method to update init options at runtime
   * $version 1.6.3    - added doubletap, longtap events and longTapThreshold, doubleTapThreshold property
   *
   * $Date: 2013-04-04 (Thurs, 04 April 2013) $
   * $version 1.6.4    - Fixed bug with cancelThreshold introduced in 1.6.3, where swipe status no longer fired start event, and stopped once swiping back.
   *
   * $Date: 2013-08-24 (Sat, 24 Aug 2013) $
   * $version 1.6.5    - Merged a few pull requests fixing various bugs, added AMD support.
   *
   * $Date: 2014-06-04 (Wed, 04 June 2014) $
   * $version 1.6.6 	- Merge of pull requests.
   *    				- IE10 touch support
   *    				- Only prevent default event handling on valid swipe
   *    				- Separate license/changelog comment
   *    				- Detect if the swipe is valid at the end of the touch event.
   *    				- Pass fingerdata to event handlers.
   *    				- Add 'hold' gesture
   *    				- Be more tolerant about the tap distance
   *    				- Typos and minor fixes
   *
   * $Date: 2015-22-01 (Thurs, 22 Jan 2015) $
   * $version 1.6.7    - Added patch from https://github.com/mattbryson/TouchSwipe-Jquery-Plugin/issues/206 to fix memory leak
   *
   * $Date: 2015-2-2 (Mon, 2 Feb 2015) $
   * $version 1.6.8    - Added preventDefaultEvents option to proxy events regardless.
   *					- Fixed issue with swipe and pinch not triggering at the same time
   *
   * $Date: 2015-9-6 (Tues, 9 June 2015) $
   * $version 1.6.9    - Added PR from jdalton/hybrid to fix pointer events
   *					- Added scrolling demo
   *					- Added version property to plugin
   *
   * $Date: 2015-1-10 (Wed, 1 October 2015) $
   * $version 1.6.10    - Added PR from beatspace to fix tap events
   * $version 1.6.11    - Added PRs from indri-indri ( Doc tidyup), kkirsche ( Bower tidy up ), UziTech (preventDefaultEvents fixes )
   *					 - Allowed setting multiple options via .swipe("options", options_hash) and more simply .swipe(options_hash) or exisitng instances
   * $version 1.6.12    - Fixed bug with multi finger releases above 2 not triggering events
   *
   * $Date: 2015-12-18 (Fri, 18 December 2015) $
   * $version 1.6.13    - Added PRs
   *                    - Fixed #267 allowPageScroll not working correctly
   * $version 1.6.14    - Fixed #220 / #248 doubletap not firing with swipes, #223 commonJS compatible
   * $version 1.6.15    - More bug fixes
   *
   * $Date: 2016-04-29 (Fri, 29 April 2016) $
   * $version 1.6.16    - Swipes with 0 distance now allow default events to trigger.  So tapping any form elements or A tags will allow default interaction, but swiping will trigger a swipe.
                          Removed the a, input, select etc from the excluded Children list as the 0 distance tap solves that issue.
  * $Date: 2016-05-19  (Fri, 29 April 2016) $
  * $version 1.6.17     - Fixed context issue when calling instance methods via $("selector").swipe("method");
  * $version 1.6.18     - now honors fallbackToMouseEvents=false for MS Pointer events when a Mouse is used.

   */

  /**
   * See (http://jquery.com/).
   * @name $
   * @class
   * See the jQuery Library  (http://jquery.com/) for full details.  This just
   * documents the function and classes that are added to jQuery by this plug-in.
   */

  /**
   * See (http://jquery.com/)
   * @name fn
   * @class
   * See the jQuery Library  (http://jquery.com/) for full details.  This just
   * documents the function and classes that are added to jQuery by this plug-in.
   * @memberOf $
   */
  (function (factory) {
    if (typeof module !== 'undefined' && module.exports) {
      // CommonJS Module
      factory(require("jquery"));
    } else {
      // Browser globals.
      factory(jQuery);
    }
  })(function ($) {

    var VERSION = "1.6.18",
        LEFT = "left",
        RIGHT = "right",
        UP = "up",
        DOWN = "down",
        IN = "in",
        OUT = "out",
        NONE = "none",
        AUTO = "auto",
        SWIPE = "swipe",
        PINCH = "pinch",
        TAP = "tap",
        DOUBLE_TAP = "doubletap",
        LONG_TAP = "longtap",
        HORIZONTAL = "horizontal",
        VERTICAL = "vertical",
        ALL_FINGERS = "all",
        DOUBLE_TAP_THRESHOLD = 10,
        PHASE_START = "start",
        PHASE_MOVE = "move",
        PHASE_END = "end",
        PHASE_CANCEL = "cancel",
        SUPPORTS_TOUCH = 'ontouchstart' in window,
        SUPPORTS_POINTER_IE10 = window.navigator.msPointerEnabled && !window.navigator.pointerEnabled && !SUPPORTS_TOUCH,
        SUPPORTS_POINTER = (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) && !SUPPORTS_TOUCH,
        PLUGIN_NS = 'TouchSwipe';
    /**
    * The default configuration, and available options to configure touch swipe with.
    * You can set the default values by updating any of the properties prior to instantiation.
    * @name $.fn.swipe.defaults
    * @namespace
    * @property {int} [fingers=1] The number of fingers to detect in a swipe. Any swipes that do not meet this requirement will NOT trigger swipe handlers.
    * @property {int} [threshold=75] The number of pixels that the user must move their finger by before it is considered a swipe.
    * @property {int} [cancelThreshold=null] The number of pixels that the user must move their finger back from the original swipe direction to cancel the gesture.
    * @property {int} [pinchThreshold=20] The number of pixels that the user must pinch their finger by before it is considered a pinch.
    * @property {int} [maxTimeThreshold=null] Time, in milliseconds, between touchStart and touchEnd must NOT exceed in order to be considered a swipe.
    * @property {int} [fingerReleaseThreshold=250] Time in milliseconds between releasing multiple fingers.  If 2 fingers are down, and are released one after the other, if they are within this threshold, it counts as a simultaneous release.
    * @property {int} [longTapThreshold=500] Time in milliseconds between tap and release for a long tap
    * @property {int} [doubleTapThreshold=200] Time in milliseconds between 2 taps to count as a double tap
    * @property {function} [swipe=null] A handler to catch all swipes. See {@link $.fn.swipe#event:swipe}
    * @property {function} [swipeLeft=null] A handler that is triggered for "left" swipes. See {@link $.fn.swipe#event:swipeLeft}
    * @property {function} [swipeRight=null] A handler that is triggered for "right" swipes. See {@link $.fn.swipe#event:swipeRight}
    * @property {function} [swipeUp=null] A handler that is triggered for "up" swipes. See {@link $.fn.swipe#event:swipeUp}
    * @property {function} [swipeDown=null] A handler that is triggered for "down" swipes. See {@link $.fn.swipe#event:swipeDown}
    * @property {function} [swipeStatus=null] A handler triggered for every phase of the swipe. See {@link $.fn.swipe#event:swipeStatus}
    * @property {function} [pinchIn=null] A handler triggered for pinch in events. See {@link $.fn.swipe#event:pinchIn}
    * @property {function} [pinchOut=null] A handler triggered for pinch out events. See {@link $.fn.swipe#event:pinchOut}
    * @property {function} [pinchStatus=null] A handler triggered for every phase of a pinch. See {@link $.fn.swipe#event:pinchStatus}
    * @property {function} [tap=null] A handler triggered when a user just taps on the item, rather than swipes it. If they do not move, tap is triggered, if they do move, it is not.
    * @property {function} [doubleTap=null] A handler triggered when a user double taps on the item. The delay between taps can be set with the doubleTapThreshold property. See {@link $.fn.swipe.defaults#doubleTapThreshold}
    * @property {function} [longTap=null] A handler triggered when a user long taps on the item. The delay between start and end can be set with the longTapThreshold property. See {@link $.fn.swipe.defaults#longTapThreshold}
    * @property (function) [hold=null] A handler triggered when a user reaches longTapThreshold on the item. See {@link $.fn.swipe.defaults#longTapThreshold}
    * @property {boolean} [triggerOnTouchEnd=true] If true, the swipe events are triggered when the touch end event is received (user releases finger).  If false, it will be triggered on reaching the threshold, and then cancel the touch event automatically.
    * @property {boolean} [triggerOnTouchLeave=false] If true, then when the user leaves the swipe object, the swipe will end and trigger appropriate handlers.
    * @property {string|undefined} [allowPageScroll='auto'] How the browser handles page scrolls when the user is swiping on a touchSwipe object. See {@link $.fn.swipe.pageScroll}.  <br/><br/>
    									<code>"auto"</code> : all undefined swipes will cause the page to scroll in that direction. <br/>
    									<code>"none"</code> : the page will not scroll when user swipes. <br/>
    									<code>"horizontal"</code> : will force page to scroll on horizontal swipes. <br/>
    									<code>"vertical"</code> : will force page to scroll on vertical swipes. <br/>
    * @property {boolean} [fallbackToMouseEvents=true] If true mouse events are used when run on a non touch device, false will stop swipes being triggered by mouse events on non touch devices.
    * @property {string} [excludedElements=".noSwipe"] A jquery selector that specifies child elements that do NOT trigger swipes. By default this excludes elements with the class .noSwipe .
    * @property {boolean} [preventDefaultEvents=true] by default default events are cancelled, so the page doesn't move.  You can disable this so both native events fire as well as your handlers.
     */

    var defaults = {
      fingers: 1,
      threshold: 75,
      cancelThreshold: null,
      pinchThreshold: 20,
      maxTimeThreshold: null,
      fingerReleaseThreshold: 250,
      longTapThreshold: 500,
      doubleTapThreshold: 200,
      swipe: null,
      swipeLeft: null,
      swipeRight: null,
      swipeUp: null,
      swipeDown: null,
      swipeStatus: null,
      pinchIn: null,
      pinchOut: null,
      pinchStatus: null,
      click: null,
      //Deprecated since 1.6.2
      tap: null,
      doubleTap: null,
      longTap: null,
      hold: null,
      triggerOnTouchEnd: true,
      triggerOnTouchLeave: false,
      allowPageScroll: "auto",
      fallbackToMouseEvents: true,
      excludedElements: ".noSwipe",
      preventDefaultEvents: true
    };
    /**
     * Applies TouchSwipe behaviour to one or more jQuery objects.
     * The TouchSwipe plugin can be instantiated via this method, or methods within
     * TouchSwipe can be executed via this method as per jQuery plugin architecture.
     * An existing plugin can have its options changed simply by re calling .swipe(options)
     * @see TouchSwipe
     * @class
     * @param {Mixed} method If the current DOMNode is a TouchSwipe object, and <code>method</code> is a TouchSwipe method, then
     * the <code>method</code> is executed, and any following arguments are passed to the TouchSwipe method.
     * If <code>method</code> is an object, then the TouchSwipe class is instantiated on the current DOMNode, passing the
     * configuration properties defined in the object. See TouchSwipe
     *
     */

    $.fn.swipe = function (method) {
      var $this = $(this),
          plugin = $this.data(PLUGIN_NS); //Check if we are already instantiated and trying to execute a method

      if (plugin && typeof method === 'string') {
        if (plugin[method]) {
          return plugin[method].apply(plugin, Array.prototype.slice.call(arguments, 1));
        } else {
          $.error('Method ' + method + ' does not exist on jQuery.swipe');
        }
      } //Else update existing plugin with new options hash
      else if (plugin && typeof method === 'object') {
          plugin['option'].apply(plugin, arguments);
        } //Else not instantiated and trying to pass init object (or nothing)
        else if (!plugin && (typeof method === 'object' || !method)) {
            return init.apply(this, arguments);
          }

      return $this;
    };
    /**
     * The version of the plugin
     * @readonly
     */


    $.fn.swipe.version = VERSION; //Expose our defaults so a user could override the plugin defaults

    $.fn.swipe.defaults = defaults;
    /**
     * The phases that a touch event goes through.  The <code>phase</code> is passed to the event handlers.
     * These properties are read only, attempting to change them will not alter the values passed to the event handlers.
     * @namespace
     * @readonly
     * @property {string} PHASE_START Constant indicating the start phase of the touch event. Value is <code>"start"</code>.
     * @property {string} PHASE_MOVE Constant indicating the move phase of the touch event. Value is <code>"move"</code>.
     * @property {string} PHASE_END Constant indicating the end phase of the touch event. Value is <code>"end"</code>.
     * @property {string} PHASE_CANCEL Constant indicating the cancel phase of the touch event. Value is <code>"cancel"</code>.
     */

    $.fn.swipe.phases = {
      PHASE_START: PHASE_START,
      PHASE_MOVE: PHASE_MOVE,
      PHASE_END: PHASE_END,
      PHASE_CANCEL: PHASE_CANCEL
    };
    /**
     * The direction constants that are passed to the event handlers.
     * These properties are read only, attempting to change them will not alter the values passed to the event handlers.
     * @namespace
     * @readonly
     * @property {string} LEFT Constant indicating the left direction. Value is <code>"left"</code>.
     * @property {string} RIGHT Constant indicating the right direction. Value is <code>"right"</code>.
     * @property {string} UP Constant indicating the up direction. Value is <code>"up"</code>.
     * @property {string} DOWN Constant indicating the down direction. Value is <code>"cancel"</code>.
     * @property {string} IN Constant indicating the in direction. Value is <code>"in"</code>.
     * @property {string} OUT Constant indicating the out direction. Value is <code>"out"</code>.
     */

    $.fn.swipe.directions = {
      LEFT: LEFT,
      RIGHT: RIGHT,
      UP: UP,
      DOWN: DOWN,
      IN: IN,
      OUT: OUT
    };
    /**
     * The page scroll constants that can be used to set the value of <code>allowPageScroll</code> option
     * These properties are read only
     * @namespace
     * @readonly
     * @see $.fn.swipe.defaults#allowPageScroll
     * @property {string} NONE Constant indicating no page scrolling is allowed. Value is <code>"none"</code>.
     * @property {string} HORIZONTAL Constant indicating horizontal page scrolling is allowed. Value is <code>"horizontal"</code>.
     * @property {string} VERTICAL Constant indicating vertical page scrolling is allowed. Value is <code>"vertical"</code>.
     * @property {string} AUTO Constant indicating either horizontal or vertical will be allowed, depending on the swipe handlers registered. Value is <code>"auto"</code>.
     */

    $.fn.swipe.pageScroll = {
      NONE: NONE,
      HORIZONTAL: HORIZONTAL,
      VERTICAL: VERTICAL,
      AUTO: AUTO
    };
    /**
     * Constants representing the number of fingers used in a swipe.  These are used to set both the value of <code>fingers</code> in the
     * options object, as well as the value of the <code>fingers</code> event property.
     * These properties are read only, attempting to change them will not alter the values passed to the event handlers.
     * @namespace
     * @readonly
     * @see $.fn.swipe.defaults#fingers
     * @property {string} ONE Constant indicating 1 finger is to be detected / was detected. Value is <code>1</code>.
     * @property {string} TWO Constant indicating 2 fingers are to be detected / were detected. Value is <code>2</code>.
     * @property {string} THREE Constant indicating 3 finger are to be detected / were detected. Value is <code>3</code>.
     * @property {string} FOUR Constant indicating 4 finger are to be detected / were detected. Not all devices support this. Value is <code>4</code>.
     * @property {string} FIVE Constant indicating 5 finger are to be detected / were detected. Not all devices support this. Value is <code>5</code>.
     * @property {string} ALL Constant indicating any combination of finger are to be detected.  Value is <code>"all"</code>.
     */

    $.fn.swipe.fingers = {
      ONE: 1,
      TWO: 2,
      THREE: 3,
      FOUR: 4,
      FIVE: 5,
      ALL: ALL_FINGERS
    };
    /**
     * Initialise the plugin for each DOM element matched
     * This creates a new instance of the main TouchSwipe class for each DOM element, and then
     * saves a reference to that instance in the elements data property.
     * @internal
     */

    function init(options) {
      //Prep and extend the options
      if (options && options.allowPageScroll === undefined && (options.swipe !== undefined || options.swipeStatus !== undefined)) {
        options.allowPageScroll = NONE;
      } //Check for deprecated options
      //Ensure that any old click handlers are assigned to the new tap, unless we have a tap


      if (options.click !== undefined && options.tap === undefined) {
        options.tap = options.click;
      }

      if (!options) {
        options = {};
      } //pass empty object so we dont modify the defaults


      options = $.extend({}, $.fn.swipe.defaults, options); //For each element instantiate the plugin

      return this.each(function () {
        var $this = $(this); //Check we havent already initialised the plugin

        var plugin = $this.data(PLUGIN_NS);

        if (!plugin) {
          plugin = new TouchSwipe(this, options);
          $this.data(PLUGIN_NS, plugin);
        }
      });
    }
    /**
     * Main TouchSwipe Plugin Class.
     * Do not use this to construct your TouchSwipe object, use the jQuery plugin method $.fn.swipe(); {@link $.fn.swipe}
     * @private
     * @name TouchSwipe
     * @param {DOMNode} element The HTML DOM object to apply to plugin to
     * @param {Object} options The options to configure the plugin with.  @link {$.fn.swipe.defaults}
     * @see $.fh.swipe.defaults
     * @see $.fh.swipe
     * @class
     */


    function TouchSwipe(element, options) {
      //take a local/instacne level copy of the options - should make it this.options really...
      var options = $.extend({}, options);
      var useTouchEvents = SUPPORTS_TOUCH || SUPPORTS_POINTER || !options.fallbackToMouseEvents,
          START_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? 'MSPointerDown' : 'pointerdown' : 'touchstart' : 'mousedown',
          MOVE_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? 'MSPointerMove' : 'pointermove' : 'touchmove' : 'mousemove',
          END_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? 'MSPointerUp' : 'pointerup' : 'touchend' : 'mouseup',
          LEAVE_EV = useTouchEvents ? SUPPORTS_POINTER ? 'mouseleave' : null : 'mouseleave',
          //we manually detect leave on touch devices, so null event here
      CANCEL_EV = SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? 'MSPointerCancel' : 'pointercancel' : 'touchcancel'; //touch properties

      var distance = 0,
          direction = null,
          currentDirection = null,
          duration = 0,
          startTouchesDistance = 0,
          endTouchesDistance = 0,
          pinchZoom = 1,
          pinchDistance = 0,
          pinchDirection = 0,
          maximumsMap = null; //jQuery wrapped element for this instance

      var $element = $(element); //Current phase of th touch cycle

      var phase = "start"; // the current number of fingers being used.

      var fingerCount = 0; //track mouse points / delta

      var fingerData = {}; //track times

      var startTime = 0,
          endTime = 0,
          previousTouchEndTime = 0,
          fingerCountAtRelease = 0,
          doubleTapStartTime = 0; //Timeouts

      var singleTapTimeout = null,
          holdTimeout = null; // Add gestures to all swipable areas if supported

      try {
        $element.bind(START_EV, touchStart);
        $element.bind(CANCEL_EV, touchCancel);
      } catch (e) {
        $.error('events not supported ' + START_EV + ',' + CANCEL_EV + ' on jQuery.swipe');
      } //
      //Public methods
      //

      /**
       * re-enables the swipe plugin with the previous configuration
       * @function
       * @name $.fn.swipe#enable
       * @return {DOMNode} The Dom element that was registered with TouchSwipe
       * @example $("#element").swipe("enable");
       */


      this.enable = function () {
        //Incase we are already enabled, clean up...
        this.disable();
        $element.bind(START_EV, touchStart);
        $element.bind(CANCEL_EV, touchCancel);
        return $element;
      };
      /**
       * disables the swipe plugin
       * @function
       * @name $.fn.swipe#disable
       * @return {DOMNode} The Dom element that is now registered with TouchSwipe
       * @example $("#element").swipe("disable");
       */


      this.disable = function () {
        removeListeners();
        return $element;
      };
      /**
       * Destroy the swipe plugin completely. To use any swipe methods, you must re initialise the plugin.
       * @function
       * @name $.fn.swipe#destroy
       * @example $("#element").swipe("destroy");
       */


      this.destroy = function () {
        removeListeners();
        $element.data(PLUGIN_NS, null);
        $element = null;
      };
      /**
       * Allows run time updating of the swipe configuration options.
       * @function
       * @name $.fn.swipe#option
       * @param {String} property The option property to get or set, or a has of multiple options to set
       * @param {Object} [value] The value to set the property to
       * @return {Object} If only a property name is passed, then that property value is returned. If nothing is passed the current options hash is returned.
       * @example $("#element").swipe("option", "threshold"); // return the threshold
       * @example $("#element").swipe("option", "threshold", 100); // set the threshold after init
       * @example $("#element").swipe("option", {threshold:100, fingers:3} ); // set multiple properties after init
       * @example $("#element").swipe({threshold:100, fingers:3} ); // set multiple properties after init - the "option" method is optional!
       * @example $("#element").swipe("option"); // Return the current options hash
       * @see $.fn.swipe.defaults
       *
       */


      this.option = function (property, value) {
        if (typeof property === 'object') {
          options = $.extend(options, property);
        } else if (options[property] !== undefined) {
          if (value === undefined) {
            return options[property];
          } else {
            options[property] = value;
          }
        } else if (!property) {
          return options;
        } else {
          $.error('Option ' + property + ' does not exist on jQuery.swipe.options');
        }

        return null;
      }; //
      // Private methods
      //
      //
      // EVENTS
      //

      /**
       * Event handler for a touch start event.
       * Stops the default click event from triggering and stores where we touched
       * @inner
       * @param {object} jqEvent The normalised jQuery event object.
       */


      function touchStart(jqEvent) {
        //If we already in a touch event (a finger already in use) then ignore subsequent ones..
        if (getTouchInProgress()) {
          return;
        } //Check if this element matches any in the excluded elements selectors,  or its parent is excluded, if so, DON'T swipe


        if ($(jqEvent.target).closest(options.excludedElements, $element).length > 0) {
          return;
        } //As we use Jquery bind for events, we need to target the original event object
        //If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.


        var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent; //If we have a pointer event, whoes type is 'mouse' and we have said NO mouse events, then dont do anything.

        if (event.pointerType && event.pointerType == "mouse" && options.fallbackToMouseEvents == false) {
          return;
        }
        var ret,
            touches = event.touches,
            evt = touches ? touches[0] : event;
        phase = PHASE_START; //If we support touches, get the finger count

        if (touches) {
          // get the total number of fingers touching the screen
          fingerCount = touches.length;
        } //Else this is the desktop, so stop the browser from dragging content
        else if (options.preventDefaultEvents !== false) {
            jqEvent.preventDefault(); //call this on jq event so we are cross browser
          } //clear vars..


        distance = 0;
        direction = null;
        currentDirection = null;
        pinchDirection = null;
        duration = 0;
        startTouchesDistance = 0;
        endTouchesDistance = 0;
        pinchZoom = 1;
        pinchDistance = 0;
        maximumsMap = createMaximumsData();
        cancelMultiFingerRelease(); //Create the default finger data

        createFingerData(0, evt); // check the number of fingers is what we are looking for, or we are capturing pinches

        if (!touches || fingerCount === options.fingers || options.fingers === ALL_FINGERS || hasPinches()) {
          // get the coordinates of the touch
          startTime = getTimeStamp();

          if (fingerCount == 2) {
            //Keep track of the initial pinch distance, so we can calculate the diff later
            //Store second finger data as start
            createFingerData(1, touches[1]);
            startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start);
          }

          if (options.swipeStatus || options.pinchStatus) {
            ret = triggerHandler(event, phase);
          }
        } else {
          //A touch with more or less than the fingers we are looking for, so cancel
          ret = false;
        } //If we have a return value from the users handler, then return and cancel


        if (ret === false) {
          phase = PHASE_CANCEL;
          triggerHandler(event, phase);
          return ret;
        } else {
          if (options.hold) {
            holdTimeout = setTimeout($.proxy(function () {
              //Trigger the event
              $element.trigger('hold', [event.target]); //Fire the callback

              if (options.hold) {
                ret = options.hold.call($element, event, event.target);
              }
            }, this), options.longTapThreshold);
          }

          setTouchInProgress(true);
        }

        return null;
      }
      /**
       * Event handler for a touch move event.
       * If we change fingers during move, then cancel the event
       * @inner
       * @param {object} jqEvent The normalised jQuery event object.
       */

      function touchMove(jqEvent) {
        //As we use Jquery bind for events, we need to target the original event object
        //If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
        var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent; //If we are ending, cancelling, or within the threshold of 2 fingers being released, don't track anything..

        if (phase === PHASE_END || phase === PHASE_CANCEL || inMultiFingerRelease()) return;
        var ret,
            touches = event.touches,
            evt = touches ? touches[0] : event; //Update the  finger data

        var currentFinger = updateFingerData(evt);
        endTime = getTimeStamp();

        if (touches) {
          fingerCount = touches.length;
        }

        if (options.hold) {
          clearTimeout(holdTimeout);
        }

        phase = PHASE_MOVE; //If we have 2 fingers get Touches distance as well

        if (fingerCount == 2) {
          //Keep track of the initial pinch distance, so we can calculate the diff later
          //We do this here as well as the start event, in case they start with 1 finger, and the press 2 fingers
          if (startTouchesDistance == 0) {
            //Create second finger if this is the first time...
            createFingerData(1, touches[1]);
            startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start);
          } else {
            //Else just update the second finger
            updateFingerData(touches[1]);
            endTouchesDistance = calculateTouchesDistance(fingerData[0].end, fingerData[1].end);
            pinchDirection = calculatePinchDirection(fingerData[0].end, fingerData[1].end);
          }

          pinchZoom = calculatePinchZoom(startTouchesDistance, endTouchesDistance);
          pinchDistance = Math.abs(startTouchesDistance - endTouchesDistance);
        }

        if (fingerCount === options.fingers || options.fingers === ALL_FINGERS || !touches || hasPinches()) {
          //The overall direction of the swipe. From start to now.
          direction = calculateDirection(currentFinger.start, currentFinger.end); //The immediate direction of the swipe, direction between the last movement and this one.

          currentDirection = calculateDirection(currentFinger.last, currentFinger.end); //Check if we need to prevent default event (page scroll / pinch zoom) or not

          validateDefaultEvent(jqEvent, currentDirection); //Distance and duration are all off the main finger

          distance = calculateDistance(currentFinger.start, currentFinger.end);
          duration = calculateDuration(); //Cache the maximum distance we made in this direction

          setMaxDistance(direction, distance); //Trigger status handler

          ret = triggerHandler(event, phase); //If we trigger end events when threshold are met, or trigger events when touch leaves element

          if (!options.triggerOnTouchEnd || options.triggerOnTouchLeave) {
            var inBounds = true; //If checking if we leave the element, run the bounds check (we can use touchleave as its not supported on webkit)

            if (options.triggerOnTouchLeave) {
              var bounds = getbounds(this);
              inBounds = isInBounds(currentFinger.end, bounds);
            } //Trigger end handles as we swipe if thresholds met or if we have left the element if the user has asked to check these..


            if (!options.triggerOnTouchEnd && inBounds) {
              phase = getNextPhase(PHASE_MOVE);
            } //We end if out of bounds here, so set current phase to END, and check if its modified
            else if (options.triggerOnTouchLeave && !inBounds) {
                phase = getNextPhase(PHASE_END);
              }

            if (phase == PHASE_CANCEL || phase == PHASE_END) {
              triggerHandler(event, phase);
            }
          }
        } else {
          phase = PHASE_CANCEL;
          triggerHandler(event, phase);
        }

        if (ret === false) {
          phase = PHASE_CANCEL;
          triggerHandler(event, phase);
        }
      }
      /**
       * Event handler for a touch end event.
       * Calculate the direction and trigger events
       * @inner
       * @param {object} jqEvent The normalised jQuery event object.
       */


      function touchEnd(jqEvent) {
        //As we use Jquery bind for events, we need to target the original event object
        //If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
        var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent,
            touches = event.touches; //If we are still in a touch with the device wait a fraction and see if the other finger comes up
        //if it does within the threshold, then we treat it as a multi release, not a single release and end the touch / swipe

        if (touches) {
          if (touches.length && !inMultiFingerRelease()) {
            startMultiFingerRelease(event);
            return true;
          } else if (touches.length && inMultiFingerRelease()) {
            return true;
          }
        } //If a previous finger has been released, check how long ago, if within the threshold, then assume it was a multifinger release.
        //This is used to allow 2 fingers to release fractionally after each other, whilst maintaining the event as containing 2 fingers, not 1


        if (inMultiFingerRelease()) {
          fingerCount = fingerCountAtRelease;
        } //Set end of swipe


        endTime = getTimeStamp(); //Get duration incase move was never fired

        duration = calculateDuration(); //If we trigger handlers at end of swipe OR, we trigger during, but they didnt trigger and we are still in the move phase

        if (didSwipeBackToCancel() || !validateSwipeDistance()) {
          phase = PHASE_CANCEL;
          triggerHandler(event, phase);
        } else if (options.triggerOnTouchEnd || options.triggerOnTouchEnd === false && phase === PHASE_MOVE) {
          //call this on jq event so we are cross browser
          if (options.preventDefaultEvents !== false) {
            jqEvent.preventDefault();
          }

          phase = PHASE_END;
          triggerHandler(event, phase);
        } //Special cases - A tap should always fire on touch end regardless,
        //So here we manually trigger the tap end handler by itself
        //We dont run trigger handler as it will re-trigger events that may have fired already
        else if (!options.triggerOnTouchEnd && hasTap()) {
            //Trigger the pinch events...
            phase = PHASE_END;
            triggerHandlerForGesture(event, phase, TAP);
          } else if (phase === PHASE_MOVE) {
            phase = PHASE_CANCEL;
            triggerHandler(event, phase);
          }

        setTouchInProgress(false);
        return null;
      }
      /**
       * Event handler for a touch cancel event.
       * Clears current vars
       * @inner
       */


      function touchCancel() {
        // reset the variables back to default values
        fingerCount = 0;
        endTime = 0;
        startTime = 0;
        startTouchesDistance = 0;
        endTouchesDistance = 0;
        pinchZoom = 1; //If we were in progress of tracking a possible multi touch end, then re set it.

        cancelMultiFingerRelease();
        setTouchInProgress(false);
      }
      /**
       * Event handler for a touch leave event.
       * This is only triggered on desktops, in touch we work this out manually
       * as the touchleave event is not supported in webkit
       * @inner
       */


      function touchLeave(jqEvent) {
        //If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
        var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent; //If we have the trigger on leave property set....

        if (options.triggerOnTouchLeave) {
          phase = getNextPhase(PHASE_END);
          triggerHandler(event, phase);
        }
      }
      /**
       * Removes all listeners that were associated with the plugin
       * @inner
       */


      function removeListeners() {
        $element.unbind(START_EV, touchStart);
        $element.unbind(CANCEL_EV, touchCancel);
        $element.unbind(MOVE_EV, touchMove);
        $element.unbind(END_EV, touchEnd); //we only have leave events on desktop, we manually calculate leave on touch as its not supported in webkit

        if (LEAVE_EV) {
          $element.unbind(LEAVE_EV, touchLeave);
        }

        setTouchInProgress(false);
      }
      /**
       * Checks if the time and distance thresholds have been met, and if so then the appropriate handlers are fired.
       */


      function getNextPhase(currentPhase) {
        var nextPhase = currentPhase; // Ensure we have valid swipe (under time and over distance  and check if we are out of bound...)

        var validTime = validateSwipeTime();
        var validDistance = validateSwipeDistance();
        var didCancel = didSwipeBackToCancel(); //If we have exceeded our time, then cancel

        if (!validTime || didCancel) {
          nextPhase = PHASE_CANCEL;
        } //Else if we are moving, and have reached distance then end
        else if (validDistance && currentPhase == PHASE_MOVE && (!options.triggerOnTouchEnd || options.triggerOnTouchLeave)) {
            nextPhase = PHASE_END;
          } //Else if we have ended by leaving and didn't reach distance, then cancel
          else if (!validDistance && currentPhase == PHASE_END && options.triggerOnTouchLeave) {
              nextPhase = PHASE_CANCEL;
            }

        return nextPhase;
      }
      /**
       * Trigger the relevant event handler
       * The handlers are passed the original event, the element that was swiped, and in the case of the catch all handler, the direction that was swiped, "left", "right", "up", or "down"
       * @param {object} event the original event object
       * @param {string} phase the phase of the swipe (start, end cancel etc) {@link $.fn.swipe.phases}
       * @inner
       */


      function triggerHandler(event, phase) {
        var ret,
            touches = event.touches; // SWIPE GESTURES

        if (didSwipe() || hasSwipes()) {
          ret = triggerHandlerForGesture(event, phase, SWIPE);
        } // PINCH GESTURES (if the above didn't cancel)


        if ((didPinch() || hasPinches()) && ret !== false) {
          ret = triggerHandlerForGesture(event, phase, PINCH);
        } // CLICK / TAP (if the above didn't cancel)


        if (didDoubleTap() && ret !== false) {
          //Trigger the tap events...
          ret = triggerHandlerForGesture(event, phase, DOUBLE_TAP);
        } // CLICK / TAP (if the above didn't cancel)
        else if (didLongTap() && ret !== false) {
            //Trigger the tap events...
            ret = triggerHandlerForGesture(event, phase, LONG_TAP);
          } // CLICK / TAP (if the above didn't cancel)
          else if (didTap() && ret !== false) {
              //Trigger the tap event..
              ret = triggerHandlerForGesture(event, phase, TAP);
            } // If we are cancelling the gesture, then manually trigger the reset handler


        if (phase === PHASE_CANCEL) {
          touchCancel(event);
        } // If we are ending the gesture, then manually trigger the reset handler IF all fingers are off


        if (phase === PHASE_END) {
          //If we support touch, then check that all fingers are off before we cancel
          if (touches) {
            if (!touches.length) {
              touchCancel(event);
            }
          } else {
            touchCancel(event);
          }
        }

        return ret;
      }
      /**
       * Trigger the relevant event handler
       * The handlers are passed the original event, the element that was swiped, and in the case of the catch all handler, the direction that was swiped, "left", "right", "up", or "down"
       * @param {object} event the original event object
       * @param {string} phase the phase of the swipe (start, end cancel etc) {@link $.fn.swipe.phases}
       * @param {string} gesture the gesture to trigger a handler for : PINCH or SWIPE {@link $.fn.swipe.gestures}
       * @return Boolean False, to indicate that the event should stop propagation, or void.
       * @inner
       */


      function triggerHandlerForGesture(event, phase, gesture) {
        var ret; //SWIPES....

        if (gesture == SWIPE) {
          //Trigger status every time..
          $element.trigger('swipeStatus', [phase, direction || null, distance || 0, duration || 0, fingerCount, fingerData, currentDirection]);

          if (options.swipeStatus) {
            ret = options.swipeStatus.call($element, event, phase, direction || null, distance || 0, duration || 0, fingerCount, fingerData, currentDirection); //If the status cancels, then dont run the subsequent event handlers..

            if (ret === false) return false;
          }

          if (phase == PHASE_END && validateSwipe()) {
            //Cancel any taps that were in progress...
            clearTimeout(singleTapTimeout);
            clearTimeout(holdTimeout);
            $element.trigger('swipe', [direction, distance, duration, fingerCount, fingerData, currentDirection]);

            if (options.swipe) {
              ret = options.swipe.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection); //If the status cancels, then dont run the subsequent event handlers..

              if (ret === false) return false;
            } //trigger direction specific event handlers


            switch (direction) {
              case LEFT:
                $element.trigger('swipeLeft', [direction, distance, duration, fingerCount, fingerData, currentDirection]);

                if (options.swipeLeft) {
                  ret = options.swipeLeft.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection);
                }

                break;

              case RIGHT:
                $element.trigger('swipeRight', [direction, distance, duration, fingerCount, fingerData, currentDirection]);

                if (options.swipeRight) {
                  ret = options.swipeRight.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection);
                }

                break;

              case UP:
                $element.trigger('swipeUp', [direction, distance, duration, fingerCount, fingerData, currentDirection]);

                if (options.swipeUp) {
                  ret = options.swipeUp.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection);
                }

                break;

              case DOWN:
                $element.trigger('swipeDown', [direction, distance, duration, fingerCount, fingerData, currentDirection]);

                if (options.swipeDown) {
                  ret = options.swipeDown.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection);
                }

                break;
            }
          }
        } //PINCHES....


        if (gesture == PINCH) {
          $element.trigger('pinchStatus', [phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]);

          if (options.pinchStatus) {
            ret = options.pinchStatus.call($element, event, phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData); //If the status cancels, then dont run the subsequent event handlers..

            if (ret === false) return false;
          }

          if (phase == PHASE_END && validatePinch()) {
            switch (pinchDirection) {
              case IN:
                $element.trigger('pinchIn', [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]);

                if (options.pinchIn) {
                  ret = options.pinchIn.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData);
                }

                break;

              case OUT:
                $element.trigger('pinchOut', [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]);

                if (options.pinchOut) {
                  ret = options.pinchOut.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData);
                }

                break;
            }
          }
        }

        if (gesture == TAP) {
          if (phase === PHASE_CANCEL || phase === PHASE_END) {
            clearTimeout(singleTapTimeout);
            clearTimeout(holdTimeout); //If we are also looking for doubelTaps, wait incase this is one...

            if (hasDoubleTap() && !inDoubleTap()) {
              doubleTapStartTime = getTimeStamp(); //Now wait for the double tap timeout, and trigger this single tap
              //if its not cancelled by a double tap

              singleTapTimeout = setTimeout($.proxy(function () {
                doubleTapStartTime = null;
                $element.trigger('tap', [event.target]);

                if (options.tap) {
                  ret = options.tap.call($element, event, event.target);
                }
              }, this), options.doubleTapThreshold);
            } else {
              doubleTapStartTime = null;
              $element.trigger('tap', [event.target]);

              if (options.tap) {
                ret = options.tap.call($element, event, event.target);
              }
            }
          }
        } else if (gesture == DOUBLE_TAP) {
          if (phase === PHASE_CANCEL || phase === PHASE_END) {
            clearTimeout(singleTapTimeout);
            clearTimeout(holdTimeout);
            doubleTapStartTime = null;
            $element.trigger('doubletap', [event.target]);

            if (options.doubleTap) {
              ret = options.doubleTap.call($element, event, event.target);
            }
          }
        } else if (gesture == LONG_TAP) {
          if (phase === PHASE_CANCEL || phase === PHASE_END) {
            clearTimeout(singleTapTimeout);
            doubleTapStartTime = null;
            $element.trigger('longtap', [event.target]);

            if (options.longTap) {
              ret = options.longTap.call($element, event, event.target);
            }
          }
        }

        return ret;
      } //
      // GESTURE VALIDATION
      //

      /**
       * Checks the user has swipe far enough
       * @return Boolean if <code>threshold</code> has been set, return true if the threshold was met, else false.
       * If no threshold was set, then we return true.
       * @inner
       */


      function validateSwipeDistance() {
        var valid = true; //If we made it past the min swipe distance..

        if (options.threshold !== null) {
          valid = distance >= options.threshold;
        }

        return valid;
      }
      /**
       * Checks the user has swiped back to cancel.
       * @return Boolean if <code>cancelThreshold</code> has been set, return true if the cancelThreshold was met, else false.
       * If no cancelThreshold was set, then we return true.
       * @inner
       */


      function didSwipeBackToCancel() {
        var cancelled = false;

        if (options.cancelThreshold !== null && direction !== null) {
          cancelled = getMaxDistance(direction) - distance >= options.cancelThreshold;
        }

        return cancelled;
      }
      /**
       * Checks the user has pinched far enough
       * @return Boolean if <code>pinchThreshold</code> has been set, return true if the threshold was met, else false.
       * If no threshold was set, then we return true.
       * @inner
       */


      function validatePinchDistance() {
        if (options.pinchThreshold !== null) {
          return pinchDistance >= options.pinchThreshold;
        }

        return true;
      }
      /**
       * Checks that the time taken to swipe meets the minimum / maximum requirements
       * @return Boolean
       * @inner
       */


      function validateSwipeTime() {
        var result; //If no time set, then return true

        if (options.maxTimeThreshold) {
          if (duration >= options.maxTimeThreshold) {
            result = false;
          } else {
            result = true;
          }
        } else {
          result = true;
        }

        return result;
      }
      /**
       * Checks direction of the swipe and the value allowPageScroll to see if we should allow or prevent the default behaviour from occurring.
       * This will essentially allow page scrolling or not when the user is swiping on a touchSwipe object.
       * @param {object} jqEvent The normalised jQuery representation of the event object.
       * @param {string} direction The direction of the event. See {@link $.fn.swipe.directions}
       * @see $.fn.swipe.directions
       * @inner
       */


      function validateDefaultEvent(jqEvent, direction) {
        //If the option is set, allways allow the event to bubble up (let user handle weirdness)
        if (options.preventDefaultEvents === false) {
          return;
        }

        if (options.allowPageScroll === NONE) {
          jqEvent.preventDefault();
        } else {
          var auto = options.allowPageScroll === AUTO;

          switch (direction) {
            case LEFT:
              if (options.swipeLeft && auto || !auto && options.allowPageScroll != HORIZONTAL) {
                jqEvent.preventDefault();
              }

              break;

            case RIGHT:
              if (options.swipeRight && auto || !auto && options.allowPageScroll != HORIZONTAL) {
                jqEvent.preventDefault();
              }

              break;

            case UP:
              if (options.swipeUp && auto || !auto && options.allowPageScroll != VERTICAL) {
                jqEvent.preventDefault();
              }

              break;

            case DOWN:
              if (options.swipeDown && auto || !auto && options.allowPageScroll != VERTICAL) {
                jqEvent.preventDefault();
              }

              break;

            case NONE:
              break;
          }
        }
      } // PINCHES

      /**
       * Returns true of the current pinch meets the thresholds
       * @return Boolean
       * @inner
       */


      function validatePinch() {
        var hasCorrectFingerCount = validateFingers();
        var hasEndPoint = validateEndPoint();
        var hasCorrectDistance = validatePinchDistance();
        return hasCorrectFingerCount && hasEndPoint && hasCorrectDistance;
      }
      /**
       * Returns true if any Pinch events have been registered
       * @return Boolean
       * @inner
       */


      function hasPinches() {
        //Enure we dont return 0 or null for false values
        return !!(options.pinchStatus || options.pinchIn || options.pinchOut);
      }
      /**
       * Returns true if we are detecting pinches, and have one
       * @return Boolean
       * @inner
       */


      function didPinch() {
        //Enure we dont return 0 or null for false values
        return !!(validatePinch() && hasPinches());
      } // SWIPES

      /**
       * Returns true if the current swipe meets the thresholds
       * @return Boolean
       * @inner
       */


      function validateSwipe() {
        //Check validity of swipe
        var hasValidTime = validateSwipeTime();
        var hasValidDistance = validateSwipeDistance();
        var hasCorrectFingerCount = validateFingers();
        var hasEndPoint = validateEndPoint();
        var didCancel = didSwipeBackToCancel(); // if the user swiped more than the minimum length, perform the appropriate action
        // hasValidDistance is null when no distance is set

        var valid = !didCancel && hasEndPoint && hasCorrectFingerCount && hasValidDistance && hasValidTime;
        return valid;
      }
      /**
       * Returns true if any Swipe events have been registered
       * @return Boolean
       * @inner
       */


      function hasSwipes() {
        //Enure we dont return 0 or null for false values
        return !!(options.swipe || options.swipeStatus || options.swipeLeft || options.swipeRight || options.swipeUp || options.swipeDown);
      }
      /**
       * Returns true if we are detecting swipes and have one
       * @return Boolean
       * @inner
       */


      function didSwipe() {
        //Enure we dont return 0 or null for false values
        return !!(validateSwipe() && hasSwipes());
      }
      /**
       * Returns true if we have matched the number of fingers we are looking for
       * @return Boolean
       * @inner
       */


      function validateFingers() {
        //The number of fingers we want were matched, or on desktop we ignore
        return fingerCount === options.fingers || options.fingers === ALL_FINGERS || !SUPPORTS_TOUCH;
      }
      /**
       * Returns true if we have an end point for the swipe
       * @return Boolean
       * @inner
       */


      function validateEndPoint() {
        //We have an end value for the finger
        return fingerData[0].end.x !== 0;
      } // TAP / CLICK

      /**
       * Returns true if a click / tap events have been registered
       * @return Boolean
       * @inner
       */


      function hasTap() {
        //Enure we dont return 0 or null for false values
        return !!options.tap;
      }
      /**
       * Returns true if a double tap events have been registered
       * @return Boolean
       * @inner
       */


      function hasDoubleTap() {
        //Enure we dont return 0 or null for false values
        return !!options.doubleTap;
      }
      /**
       * Returns true if any long tap events have been registered
       * @return Boolean
       * @inner
       */


      function hasLongTap() {
        //Enure we dont return 0 or null for false values
        return !!options.longTap;
      }
      /**
       * Returns true if we could be in the process of a double tap (one tap has occurred, we are listening for double taps, and the threshold hasn't past.
       * @return Boolean
       * @inner
       */


      function validateDoubleTap() {
        if (doubleTapStartTime == null) {
          return false;
        }

        var now = getTimeStamp();
        return hasDoubleTap() && now - doubleTapStartTime <= options.doubleTapThreshold;
      }
      /**
       * Returns true if we could be in the process of a double tap (one tap has occurred, we are listening for double taps, and the threshold hasn't past.
       * @return Boolean
       * @inner
       */


      function inDoubleTap() {
        return validateDoubleTap();
      }
      /**
       * Returns true if we have a valid tap
       * @return Boolean
       * @inner
       */


      function validateTap() {
        return (fingerCount === 1 || !SUPPORTS_TOUCH) && (isNaN(distance) || distance < options.threshold);
      }
      /**
       * Returns true if we have a valid long tap
       * @return Boolean
       * @inner
       */


      function validateLongTap() {
        //slight threshold on moving finger
        return duration > options.longTapThreshold && distance < DOUBLE_TAP_THRESHOLD;
      }
      /**
       * Returns true if we are detecting taps and have one
       * @return Boolean
       * @inner
       */


      function didTap() {
        //Enure we dont return 0 or null for false values
        return !!(validateTap() && hasTap());
      }
      /**
       * Returns true if we are detecting double taps and have one
       * @return Boolean
       * @inner
       */


      function didDoubleTap() {
        //Enure we dont return 0 or null for false values
        return !!(validateDoubleTap() && hasDoubleTap());
      }
      /**
       * Returns true if we are detecting long taps and have one
       * @return Boolean
       * @inner
       */


      function didLongTap() {
        //Enure we dont return 0 or null for false values
        return !!(validateLongTap() && hasLongTap());
      } // MULTI FINGER TOUCH

      /**
       * Starts tracking the time between 2 finger releases, and keeps track of how many fingers we initially had up
       * @inner
       */


      function startMultiFingerRelease(event) {
        previousTouchEndTime = getTimeStamp();
        fingerCountAtRelease = event.touches.length + 1;
      }
      /**
       * Cancels the tracking of time between 2 finger releases, and resets counters
       * @inner
       */


      function cancelMultiFingerRelease() {
        previousTouchEndTime = 0;
        fingerCountAtRelease = 0;
      }
      /**
       * Checks if we are in the threshold between 2 fingers being released
       * @return Boolean
       * @inner
       */


      function inMultiFingerRelease() {
        var withinThreshold = false;

        if (previousTouchEndTime) {
          var diff = getTimeStamp() - previousTouchEndTime;

          if (diff <= options.fingerReleaseThreshold) {
            withinThreshold = true;
          }
        }

        return withinThreshold;
      }
      /**
       * gets a data flag to indicate that a touch is in progress
       * @return Boolean
       * @inner
       */


      function getTouchInProgress() {
        //strict equality to ensure only true and false are returned
        return !!($element.data(PLUGIN_NS + '_intouch') === true);
      }
      /**
       * Sets a data flag to indicate that a touch is in progress
       * @param {boolean} val The value to set the property to
       * @inner
       */


      function setTouchInProgress(val) {
        //If destroy is called in an event handler, we have no el, and we have already cleaned up, so return.
        if (!$element) {
          return;
        } //Add or remove event listeners depending on touch status


        if (val === true) {
          $element.bind(MOVE_EV, touchMove);
          $element.bind(END_EV, touchEnd); //we only have leave events on desktop, we manually calcuate leave on touch as its not supported in webkit

          if (LEAVE_EV) {
            $element.bind(LEAVE_EV, touchLeave);
          }
        } else {
          $element.unbind(MOVE_EV, touchMove, false);
          $element.unbind(END_EV, touchEnd, false); //we only have leave events on desktop, we manually calcuate leave on touch as its not supported in webkit

          if (LEAVE_EV) {
            $element.unbind(LEAVE_EV, touchLeave, false);
          }
        } //strict equality to ensure only true and false can update the value


        $element.data(PLUGIN_NS + '_intouch', val === true);
      }
      /**
       * Creates the finger data for the touch/finger in the event object.
       * @param {int} id The id to store the finger data under (usually the order the fingers were pressed)
       * @param {object} evt The event object containing finger data
       * @return finger data object
       * @inner
       */


      function createFingerData(id, evt) {
        var f = {
          start: {
            x: 0,
            y: 0
          },
          last: {
            x: 0,
            y: 0
          },
          end: {
            x: 0,
            y: 0
          }
        };
        f.start.x = f.last.x = f.end.x = evt.pageX || evt.clientX;
        f.start.y = f.last.y = f.end.y = evt.pageY || evt.clientY;
        fingerData[id] = f;
        return f;
      }
      /**
       * Updates the finger data for a particular event object
       * @param {object} evt The event object containing the touch/finger data to upadte
       * @return a finger data object.
       * @inner
       */


      function updateFingerData(evt) {
        var id = evt.identifier !== undefined ? evt.identifier : 0;
        var f = getFingerData(id);

        if (f === null) {
          f = createFingerData(id, evt);
        }

        f.last.x = f.end.x;
        f.last.y = f.end.y;
        f.end.x = evt.pageX || evt.clientX;
        f.end.y = evt.pageY || evt.clientY;
        return f;
      }
      /**
       * Returns a finger data object by its event ID.
       * Each touch event has an identifier property, which is used
       * to track repeat touches
       * @param {int} id The unique id of the finger in the sequence of touch events.
       * @return a finger data object.
       * @inner
       */


      function getFingerData(id) {
        return fingerData[id] || null;
      }
      /**
       * Sets the maximum distance swiped in the given direction.
       * If the new value is lower than the current value, the max value is not changed.
       * @param {string}  direction The direction of the swipe
       * @param {int}  distance The distance of the swipe
       * @inner
       */


      function setMaxDistance(direction, distance) {
        if (direction == NONE) return;
        distance = Math.max(distance, getMaxDistance(direction));
        maximumsMap[direction].distance = distance;
      }
      /**
       * gets the maximum distance swiped in the given direction.
       * @param {string}  direction The direction of the swipe
       * @return int  The distance of the swipe
       * @inner
       */


      function getMaxDistance(direction) {
        if (maximumsMap[direction]) return maximumsMap[direction].distance;
        return undefined;
      }
      /**
       * Creats a map of directions to maximum swiped values.
       * @return Object A dictionary of maximum values, indexed by direction.
       * @inner
       */


      function createMaximumsData() {
        var maxData = {};
        maxData[LEFT] = createMaximumVO(LEFT);
        maxData[RIGHT] = createMaximumVO(RIGHT);
        maxData[UP] = createMaximumVO(UP);
        maxData[DOWN] = createMaximumVO(DOWN);
        return maxData;
      }
      /**
       * Creates a map maximum swiped values for a given swipe direction
       * @param {string} The direction that these values will be associated with
       * @return Object Maximum values
       * @inner
       */


      function createMaximumVO(dir) {
        return {
          direction: dir,
          distance: 0
        };
      } //
      // MATHS / UTILS
      //

      /**
       * Calculate the duration of the swipe
       * @return int
       * @inner
       */


      function calculateDuration() {
        return endTime - startTime;
      }
      /**
       * Calculate the distance between 2 touches (pinch)
       * @param {point} startPoint A point object containing x and y co-ordinates
       * @param {point} endPoint A point object containing x and y co-ordinates
       * @return int;
       * @inner
       */


      function calculateTouchesDistance(startPoint, endPoint) {
        var diffX = Math.abs(startPoint.x - endPoint.x);
        var diffY = Math.abs(startPoint.y - endPoint.y);
        return Math.round(Math.sqrt(diffX * diffX + diffY * diffY));
      }
      /**
       * Calculate the zoom factor between the start and end distances
       * @param {int} startDistance Distance (between 2 fingers) the user started pinching at
       * @param {int} endDistance Distance (between 2 fingers) the user ended pinching at
       * @return float The zoom value from 0 to 1.
       * @inner
       */


      function calculatePinchZoom(startDistance, endDistance) {
        var percent = endDistance / startDistance * 1;
        return percent.toFixed(2);
      }
      /**
       * Returns the pinch direction, either IN or OUT for the given points
       * @return string Either {@link $.fn.swipe.directions.IN} or {@link $.fn.swipe.directions.OUT}
       * @see $.fn.swipe.directions
       * @inner
       */


      function calculatePinchDirection() {
        if (pinchZoom < 1) {
          return OUT;
        } else {
          return IN;
        }
      }
      /**
       * Calculate the length / distance of the swipe
       * @param {point} startPoint A point object containing x and y co-ordinates
       * @param {point} endPoint A point object containing x and y co-ordinates
       * @return int
       * @inner
       */


      function calculateDistance(startPoint, endPoint) {
        return Math.round(Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)));
      }
      /**
       * Calculate the angle of the swipe
       * @param {point} startPoint A point object containing x and y co-ordinates
       * @param {point} endPoint A point object containing x and y co-ordinates
       * @return int
       * @inner
       */


      function calculateAngle(startPoint, endPoint) {
        var x = startPoint.x - endPoint.x;
        var y = endPoint.y - startPoint.y;
        var r = Math.atan2(y, x); //radians

        var angle = Math.round(r * 180 / Math.PI); //degrees
        //ensure value is positive

        if (angle < 0) {
          angle = 360 - Math.abs(angle);
        }

        return angle;
      }
      /**
       * Calculate the direction of the swipe
       * This will also call calculateAngle to get the latest angle of swipe
       * @param {point} startPoint A point object containing x and y co-ordinates
       * @param {point} endPoint A point object containing x and y co-ordinates
       * @return string Either {@link $.fn.swipe.directions.LEFT} / {@link $.fn.swipe.directions.RIGHT} / {@link $.fn.swipe.directions.DOWN} / {@link $.fn.swipe.directions.UP}
       * @see $.fn.swipe.directions
       * @inner
       */


      function calculateDirection(startPoint, endPoint) {
        if (comparePoints(startPoint, endPoint)) {
          return NONE;
        }

        var angle = calculateAngle(startPoint, endPoint);

        if (angle <= 45 && angle >= 0) {
          return LEFT;
        } else if (angle <= 360 && angle >= 315) {
          return LEFT;
        } else if (angle >= 135 && angle <= 225) {
          return RIGHT;
        } else if (angle > 45 && angle < 135) {
          return DOWN;
        } else {
          return UP;
        }
      }
      /**
       * Returns a MS time stamp of the current time
       * @return int
       * @inner
       */


      function getTimeStamp() {
        var now = new Date();
        return now.getTime();
      }
      /**
       * Returns a bounds object with left, right, top and bottom properties for the element specified.
       * @param {DomNode} The DOM node to get the bounds for.
       */


      function getbounds(el) {
        el = $(el);
        var offset = el.offset();
        var bounds = {
          left: offset.left,
          right: offset.left + el.outerWidth(),
          top: offset.top,
          bottom: offset.top + el.outerHeight()
        };
        return bounds;
      }
      /**
       * Checks if the point object is in the bounds object.
       * @param {object} point A point object.
       * @param {int} point.x The x value of the point.
       * @param {int} point.y The x value of the point.
       * @param {object} bounds The bounds object to test
       * @param {int} bounds.left The leftmost value
       * @param {int} bounds.right The righttmost value
       * @param {int} bounds.top The topmost value
       * @param {int} bounds.bottom The bottommost value
       */


      function isInBounds(point, bounds) {
        return point.x > bounds.left && point.x < bounds.right && point.y > bounds.top && point.y < bounds.bottom;
      }
      /**
       * Checks if the two points are equal
       * @param {object} point A point object.
       * @param {object} point B point object.
       * @return true of the points match
       */

      function comparePoints(pointA, pointB) {
        return pointA.x == pointB.x && pointA.y == pointB.y;
      }
    }
    /**
     * A catch all handler that is triggered for all swipe directions.
     * @name $.fn.swipe#swipe
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
     * @param {int} distance The distance the user swiped
     * @param {int} duration The duration of the swipe in milliseconds
     * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
     * @param {object} fingerData The coordinates of fingers in event
     * @param {string} currentDirection The current direction the user is swiping.
     */

    /**
     * A handler that is triggered for "left" swipes.
     * @name $.fn.swipe#swipeLeft
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
     * @param {int} distance The distance the user swiped
     * @param {int} duration The duration of the swipe in milliseconds
     * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
     * @param {object} fingerData The coordinates of fingers in event
     * @param {string} currentDirection The current direction the user is swiping.
     */

    /**
     * A handler that is triggered for "right" swipes.
     * @name $.fn.swipe#swipeRight
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
     * @param {int} distance The distance the user swiped
     * @param {int} duration The duration of the swipe in milliseconds
     * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
     * @param {object} fingerData The coordinates of fingers in event
     * @param {string} currentDirection The current direction the user is swiping.
     */

    /**
     * A handler that is triggered for "up" swipes.
     * @name $.fn.swipe#swipeUp
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
     * @param {int} distance The distance the user swiped
     * @param {int} duration The duration of the swipe in milliseconds
     * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
     * @param {object} fingerData The coordinates of fingers in event
     * @param {string} currentDirection The current direction the user is swiping.
     */

    /**
     * A handler that is triggered for "down" swipes.
     * @name $.fn.swipe#swipeDown
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
     * @param {int} distance The distance the user swiped
     * @param {int} duration The duration of the swipe in milliseconds
     * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
     * @param {object} fingerData The coordinates of fingers in event
     * @param {string} currentDirection The current direction the user is swiping.
     */

    /**
     * A handler triggered for every phase of the swipe. This handler is constantly fired for the duration of the pinch.
     * This is triggered regardless of swipe thresholds.
     * @name $.fn.swipe#swipeStatus
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {string} phase The phase of the swipe event. See {@link $.fn.swipe.phases}
     * @param {string} direction The direction the user swiped in. This is null if the user has yet to move. See {@link $.fn.swipe.directions}
     * @param {int} distance The distance the user swiped. This is 0 if the user has yet to move.
     * @param {int} duration The duration of the swipe in milliseconds
     * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
     * @param {object} fingerData The coordinates of fingers in event
     * @param {string} currentDirection The current direction the user is swiping.
     */

    /**
     * A handler triggered for pinch in events.
     * @name $.fn.swipe#pinchIn
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {int} direction The direction the user pinched in. See {@link $.fn.swipe.directions}
     * @param {int} distance The distance the user pinched
     * @param {int} duration The duration of the swipe in milliseconds
     * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
     * @param {int} zoom The zoom/scale level the user pinched too, 0-1.
     * @param {object} fingerData The coordinates of fingers in event
     */

    /**
     * A handler triggered for pinch out events.
     * @name $.fn.swipe#pinchOut
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {int} direction The direction the user pinched in. See {@link $.fn.swipe.directions}
     * @param {int} distance The distance the user pinched
     * @param {int} duration The duration of the swipe in milliseconds
     * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
     * @param {int} zoom The zoom/scale level the user pinched too, 0-1.
     * @param {object} fingerData The coordinates of fingers in event
     */

    /**
     * A handler triggered for all pinch events. This handler is constantly fired for the duration of the pinch. This is triggered regardless of thresholds.
     * @name $.fn.swipe#pinchStatus
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {int} direction The direction the user pinched in. See {@link $.fn.swipe.directions}
     * @param {int} distance The distance the user pinched
     * @param {int} duration The duration of the swipe in milliseconds
     * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
     * @param {int} zoom The zoom/scale level the user pinched too, 0-1.
     * @param {object} fingerData The coordinates of fingers in event
     */

    /**
     * A click handler triggered when a user simply clicks, rather than swipes on an element.
     * This is deprecated since version 1.6.2, any assignment to click will be assigned to the tap handler.
     * You cannot use <code>on</code> to bind to this event as the default jQ <code>click</code> event will be triggered.
     * Use the <code>tap</code> event instead.
     * @name $.fn.swipe#click
     * @event
     * @deprecated since version 1.6.2, please use {@link $.fn.swipe#tap} instead
     * @default null
     * @param {EventObject} event The original event object
     * @param {DomObject} target The element clicked on.
     */

    /**
     * A click / tap handler triggered when a user simply clicks or taps, rather than swipes on an element.
     * @name $.fn.swipe#tap
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {DomObject} target The element clicked on.
     */

    /**
     * A double tap handler triggered when a user double clicks or taps on an element.
     * You can set the time delay for a double tap with the {@link $.fn.swipe.defaults#doubleTapThreshold} property.
     * Note: If you set both <code>doubleTap</code> and <code>tap</code> handlers, the <code>tap</code> event will be delayed by the <code>doubleTapThreshold</code>
     * as the script needs to check if its a double tap.
     * @name $.fn.swipe#doubleTap
     * @see  $.fn.swipe.defaults#doubleTapThreshold
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {DomObject} target The element clicked on.
     */

    /**
     * A long tap handler triggered once a tap has been release if the tap was longer than the longTapThreshold.
     * You can set the time delay for a long tap with the {@link $.fn.swipe.defaults#longTapThreshold} property.
     * @name $.fn.swipe#longTap
     * @see  $.fn.swipe.defaults#longTapThreshold
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {DomObject} target The element clicked on.
     */

    /**
     * A hold tap handler triggered as soon as the longTapThreshold is reached
     * You can set the time delay for a long tap with the {@link $.fn.swipe.defaults#longTapThreshold} property.
     * @name $.fn.swipe#hold
     * @see  $.fn.swipe.defaults#longTapThreshold
     * @event
     * @default null
     * @param {EventObject} event The original event object
     * @param {DomObject} target The element clicked on.
     */

  });

  (function () {
    var $body = $('body');
    var scrollo = {
      init: function () {
        scrollo.control();
      },
      offset: function (el) {
        var rect = el.getBoundingClientRect();
        var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
        var scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        return {
          top: rect.top + scrollTop,
          left: rect.left + scrollLeft
        };
      },
      adjustAnchor: function (e) {
        e.preventDefault();
        var $anchor = $(':target');
        var fixedElementsHeight = scrollo.get.fixedpageElementsHeight();

        if ($anchor.length > 0) {
          e.stopPropagation(); // When we prevent default, we have to also change focus to target manually

          $anchor.eq(0).focus();
          window.scrollTo(0, scrollo.offset($anchor.get(0)).top - fixedElementsHeight);
        }
      },
      control: function () {
        $(window).on('hashchange load', scrollo.adjustAnchor);
        /**
         * checks for any <a> tag that has the hash-tag prefix and execute the adjustAnchor function
         * the .content a[href^="#"] was added to support the publication content <a> tags
         */

        $body.on('click', 'a.table-fn[href^="#"], a.ref.fn[href^="#"], .scroll-to-target a[href^="#"], .content a[href^="#"]', function (e) {
          if (window.location.hash === $(this).attr('href')) {
            scrollo.adjustAnchor(e);
          }
        });
        $body.on('click keydown', 'a[href^="#"].sr-only-focusable', function (e) {
          // pass click and ENTER to action
          if (e.keyCode && e.keyCode !== 13) {
            return;
          }

          if (window.location.hash === $(this).attr('href')) {
            scrollo.adjustAnchor(e);
          }
        });
        $body.on("click", ".w-slide__back", function () {
          if ($("[data-scroll-back-to]").length) {
            $(document).scrollTop($("[data-scroll-back-to]").data("scroll-back-to"));
            $("[data-scroll-back-to]").removeAttr("data-scroll-back-to");
          }
        });
      },
      get: {
        fixedpageElementsHeight: function () {
          var elementsHeight = 0;
          var $fixedHeader = $('header.fixed, .pageHeader');

          if ($fixedHeader.length) {
            elementsHeight = $fixedHeader.outerHeight();
          }

          var $scrolloThenFix = $('.scrollThenFix');

          if ($scrolloThenFix.length) {
            elementsHeight = $scrolloThenFix.outerHeight();
          }

          var $stickyCoolbar = $('.coolBar.stickybar--sticky');
          var stickyCoolbarHeigh = 0;

          if ($stickyCoolbar.length) {
            stickyCoolbarHeigh = $stickyCoolbar.outerHeight();

            if (stickyCoolbarHeigh == 0) {
              stickyCoolbarHeigh = $stickyCoolbar.find('.stickybar__wrapper').outerHeight();
            }

            elementsHeight += stickyCoolbarHeigh;
          }

          if ($('.fixed-element').length) {
            $.each($('.fixed-element'), function (index, value) {
              if ($(value).outerHeight()) {
                elementsHeight += $(value).outerHeight();
              }
            });
          }

          return elementsHeight;
        }
      }
    };
    UX.scrollo = scrollo; // add to global namespace
  })();

  /*!
   * enquire.js v2.1.2 - Awesome Media Queries in JavaScript
   * Copyright (c) 2014 Nick Williams - http://wicky.nillia.ms/enquire.js
   * License: MIT (http://www.opensource.org/licenses/mit-license.php)
   */

  (function (name, context, factory) {
    var matchMedia = window.matchMedia;
    /*if (typeof module !== 'undefined' && module.exports) {
    	module.exports = factory(matchMedia);
    }
    else if (typeof define === 'function' && define.amd) {
    	define(function() {
    		return (context[name] = factory(matchMedia));
    	});
    }
    else {
    	context[name] = factory(matchMedia);
    }*/

    context[name] = factory(matchMedia);
  })('enquire', window, function (matchMedia) {
    /*jshint unused:false */

    /**
     * Helper function for iterating over a collection
     *
     * @param collection
     * @param fn
     */

    function each(collection, fn) {
      var i = 0,
          length = collection.length,
          cont;

      for (i; i < length; i++) {
        cont = fn(collection[i], i);

        if (cont === false) {
          break; //allow early exit
        }
      }
    }
    /**
     * Helper function for determining whether target object is an array
     *
     * @param target the object under test
     * @return {Boolean} true if array, false otherwise
     */


    function isArray(target) {
      return Object.prototype.toString.apply(target) === '[object Array]';
    }
    /**
     * Helper function for determining whether target object is a function
     *
     * @param target the object under test
     * @return {Boolean} true if function, false otherwise
     */


    function isFunction(target) {
      return typeof target === 'function';
    }
    /**
     * Delegate to handle a media query being matched and unmatched.
     *
     * @param {object} options
     * @param {function} options.match callback for when the media query is matched
     * @param {function} [options.unmatch] callback for when the media query is unmatched
     * @param {function} [options.setup] one-time callback triggered the first time a query is matched
     * @param {boolean} [options.deferSetup=false] should the setup callback be run immediately, rather than first time query is matched?
     * @constructor
     */


    function QueryHandler(options) {
      this.options = options;
      !options.deferSetup && this.setup();
    }

    QueryHandler.prototype = {
      /**
       * coordinates setup of the handler
       *
       * @function
       */
      setup: function () {
        if (this.options.setup) {
          this.options.setup();
        }

        this.initialised = true;
      },

      /**
       * coordinates setup and triggering of the handler
       *
       * @function
       */
      on: function () {
        !this.initialised && this.setup();
        this.options.match && this.options.match();
      },

      /**
       * coordinates the unmatch event for the handler
       *
       * @function
       */
      off: function () {
        this.options.unmatch && this.options.unmatch();
      },

      /**
       * called when a handler is to be destroyed.
       * delegates to the destroy or unmatch callbacks, depending on availability.
       *
       * @function
       */
      destroy: function () {
        this.options.destroy ? this.options.destroy() : this.off();
      },

      /**
       * determines equality by reference.
       * if object is supplied compare options, if function, compare match callback
       *
       * @function
       * @param {object || function} [target] the target for comparison
       */
      equals: function (target) {
        return this.options === target || this.options.match === target;
      }
    };
    /**
     * Represents a single media query, manages it's state and registered handlers for this query
     *
     * @constructor
     * @param {string} query the media query string
     * @param {boolean} [isUnconditional=false] whether the media query should run regardless of whether the conditions are met. Primarily for helping older browsers deal with mobile-first design
     */

    function MediaQuery(query, isUnconditional) {
      this.query = query;
      this.isUnconditional = isUnconditional;
      this.handlers = [];
      this.mql = matchMedia(query);
      var self = this;

      this.listener = function (mql) {
        self.mql = mql;
        self.assess();
      };

      this.mql.addListener(this.listener);
    }

    MediaQuery.prototype = {
      /**
       * add a handler for this query, triggering if already active
       *
       * @param {object} handler
       * @param {function} handler.match callback for when query is activated
       * @param {function} [handler.unmatch] callback for when query is deactivated
       * @param {function} [handler.setup] callback for immediate execution when a query handler is registered
       * @param {boolean} [handler.deferSetup=false] should the setup callback be deferred until the first time the handler is matched?
       */
      addHandler: function (handler) {
        var qh = new QueryHandler(handler);
        this.handlers.push(qh);
        this.matches() && qh.on();
      },

      /**
       * removes the given handler from the collection, and calls it's destroy methods
       * 
       * @param {object || function} handler the handler to remove
       */
      removeHandler: function (handler) {
        var handlers = this.handlers;
        each(handlers, function (h, i) {
          if (h.equals(handler)) {
            h.destroy();
            return !handlers.splice(i, 1); //remove from array and exit each early
          }
        });
      },

      /**
       * Determine whether the media query should be considered a match
       * 
       * @return {Boolean} true if media query can be considered a match, false otherwise
       */
      matches: function () {
        return this.mql.matches || this.isUnconditional;
      },

      /**
       * Clears all handlers and unbinds events
       */
      clear: function () {
        each(this.handlers, function (handler) {
          handler.destroy();
        });
        this.mql.removeListener(this.listener);
        this.handlers.length = 0; //clear array
      },

      /*
       * Assesses the query, turning on all handlers if it matches, turning them off if it doesn't match
       */
      assess: function () {
        var action = this.matches() ? 'on' : 'off';
        each(this.handlers, function (handler) {
          handler[action]();
        });
      }
    };
    /**
     * Allows for registration of query handlers.
     * Manages the query handler's state and is responsible for wiring up browser events
     *
     * @constructor
     */

    function MediaQueryDispatch() {
      if (!matchMedia) {
        throw new Error('matchMedia not present, legacy browsers require a polyfill');
      }

      this.queries = {};
      this.browserIsIncapable = !matchMedia('only all').matches;
    }

    MediaQueryDispatch.prototype = {
      /**
       * Registers a handler for the given media query
       *
       * @param {string} q the media query
       * @param {object || Array || Function} options either a single query handler object, a function, or an array of query handlers
       * @param {function} options.match fired when query matched
       * @param {function} [options.unmatch] fired when a query is no longer matched
       * @param {function} [options.setup] fired when handler first triggered
       * @param {boolean} [options.deferSetup=false] whether setup should be run immediately or deferred until query is first matched
       * @param {boolean} [shouldDegrade=false] whether this particular media query should always run on incapable browsers
       */
      register: function (q, options, shouldDegrade) {
        var queries = this.queries,
            isUnconditional = shouldDegrade && this.browserIsIncapable;

        if (!queries[q]) {
          queries[q] = new MediaQuery(q, isUnconditional);
        } //normalise to object in an array


        if (isFunction(options)) {
          options = {
            match: options
          };
        }

        if (!isArray(options)) {
          options = [options];
        }

        each(options, function (handler) {
          if (isFunction(handler)) {
            handler = {
              match: handler
            };
          }

          queries[q].addHandler(handler);
        });
        return this;
      },

      /**
       * unregisters a query and all it's handlers, or a specific handler for a query
       *
       * @param {string} q the media query to target
       * @param {object || function} [handler] specific handler to unregister
       */
      unregister: function (q, handler) {
        var query = this.queries[q];

        if (query) {
          if (handler) {
            query.removeHandler(handler);
          } else {
            query.clear();
            delete this.queries[q];
          }
        }

        return this;
      }
    };
    return new MediaQueryDispatch();
  });

  (function () {
    var controller = {
      $body: $('body'),
      active: null,
      escape: 27,
      enabled: false,
      $activeComponent: null,
      $container: null,
      $target: null,
      init: function () {
        controller.control();
        controller.extra();
        controller.check();
        controller.extra();
      },
      control: function () {
        $(document).on('keydown', function (e) {
          // hide / close when esc key is pressed
          if ((e.keyCode || e.which) === controller.escape) {
            controller.check(e);
          }
        });
      },
      check: function (e) {
        // check if there is open / active component
        controller.active = controller.$body.attr('data-active');

        if (controller.active != null) {
          controller.disable(e);
        }
      },
      disable: function (e) {
        // hide / close active component
        // return focus to controller if component was closed by check()
        if (typeof UX[controller.active].$controller !== 'undefined') {
          UX[controller.active].$controller.focus();
        }

        UX[controller.active].on.hide(e);
      },
      extra: function () {
        controller.$body.on("click focusout", function (e) {
          // hide / close opened components when click out side it
          // @todo: this can be still improved for nested compoentns, when click is outside of all of them, close all, not only current one - but it is a feature
          // if key was pressed, than we need to operate with related target, not original target
          if (e.type === 'focusout' && e.target !== e.relatedTarget) {
            if (e.relatedTarget !== null) {
              e.target = e.relatedTarget;
            }
          }

          controller.active = controller.$body.attr('data-active');
          controller.$activeComponent = typeof UX[controller.active] !== "undefined" ? UX[controller.active] : "undefined";

          if (typeof controller.$activeComponent !== "undefined" && typeof controller.$activeComponent.$section !== "undefined" && typeof controller.$activeComponent.$controller !== "undefined") {
            controller.$container = controller.$activeComponent.$section;
            controller.$target = controller.$activeComponent.$controller;
            controller.checkToHide(e);
          }
        });
      },
      checkToHide: function (e) {
        if (!controller.$container.is(e.target) // if the target of the click isn't the container...
        && controller.$container.has(e.target).length === 0 && !controller.$target.is(e.target) // if the target of the click isn't the controller...
        && controller.$target.has(e.target).length === 0 // ... nor a descendant of the controller
        && !$(e.target).closest(".ui-autocomplete").length) {
          controller.$activeComponent.on.hide(e);
        }
      }
    };
    UX.controller = controller; // add to global namespace
  })();

  (function () {
    var $window = $(window),
        $body = $('body');
    var autoHideBar = {
      headerSelector: '.header',
      $primaryBar: $('.auto-hide-primary-bar'),
      $stickyBar: $('.auto-hide-secondary-bar'),
      previousTop: 0,
      scrollDelta: 5,
      scrollOffset: 100,
      vPort: "screen-sm",
      isMobile: false,
      previousScroll: "",
      disabled: false,
      changeEvent: null,
      changeEventName: 'change:auto-hide-bar',
      init: function () {
        if (!isIE) {
          this.header = document.querySelector(this.headerSelector);
          this.$primaryBar.addClass('auto-hide-bar fixed-element');
          this.$stickyBar.addClass('secondary-bar--sticky fixed-element');
          this.createEvents();
          setTimeout(() => {
            this.$stickyBar.css('top', this.$primaryBar.height());
          }, 200);
          this.control();
        } else {
          this.$primaryBar.removeClass('fixed');
        }
      },
      control: function () {
        $(document).on(autoHideBar.vPort + '-on', function () {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          autoHideBar.isMobile = true;
        });
        $(document).on(autoHideBar.vPort + '-off', function () {
          // Waiting for custom event that will be triggered by controller.js to deactivate responsive effects
          autoHideBar.isMobile = false;
        });
        $(window).on('resize', function () {
          autoHideBar.previousScroll = '';
        });
        $(window).on('scroll resize', () => {
          if (autoHideBar.$stickyBar.length && autoHideBar.isMobile === false && !autoHideBar.disabled) {
            var currentTop = $(window).scrollTop();
            var secondaryNav_HeaderOffsetTop = autoHideBar.$primaryBar.height() + autoHideBar.scrollOffset;

            if (autoHideBar.previousTop >= currentTop && currentTop < secondaryNav_HeaderOffsetTop) {
              //if scrolling up...
              if (autoHideBar.previousTop - currentTop > autoHideBar.scrollDelta && autoHideBar.previousScroll != 'up') {
                autoHideBar.$primaryBar.addClass('fixed-element');
                this.header.style.removeProperty('transform');
                autoHideBar.previousScroll = 'up';
                setTimeout(() => {
                  document.dispatchEvent(this.changeEvent);
                }, 100);
              }
            } else if (currentTop > secondaryNav_HeaderOffsetTop && autoHideBar.previousScroll != 'down') {
              //if scrolling down...
              autoHideBar.$primaryBar.removeClass('fixed-element');
              this.header.style.setProperty('transform', `translateY(-${autoHideBar.$primaryBar.height()}px)`);
              autoHideBar.hideOpenHeaderMenus();
              autoHideBar.previousScroll = 'down';
              setTimeout(() => {
                document.dispatchEvent(this.changeEvent);
              }, 100);
            }

            autoHideBar.previousTop = currentTop;
          }
        });
        autoHideBar.additionalControls();
      },

      createEvents() {
        this.changeEvent = new CustomEvent(this.changeEventName, {}, false);
      },

      additionalControls: function () {},
      hideOpenHeaderMenus: function () {
        //hide profile menu
        $('.navigation-login-dropdown-container').addClass('hidden'); //hide login menu

        var $openedLoginMenu = $('.loginBar__dropBlock__holder.js--open');
        $openedLoginMenu.removeClass("js--open");
        $('[data-db-target-for=' + $openedLoginMenu.attr("data-db-target-of") + ']').removeClass("js--open"); //hide quick search menu

        var $openedQuickSearchMenu = $('.quick-search__dropBlock.js--open');
        $openedQuickSearchMenu.removeClass("js--open");
        $('[data-db-target-for=' + $openedQuickSearchMenu.attr("data-db-target-of") + ']').removeClass("js--open");
      }
    };
    UX.autoHideBar = autoHideBar; // add to global namespace
  })();

  /*
   * 1. Check if the browser supports `position: sticky` natively or is too old to run the polyfill.
   *    If either of these is the case set `seppuku` flag. It will be checked later to disable key features
   *    of the polyfill, but the API will remain functional to avoid breaking things.
   */

  let seppuku = false;
  const isWindowDefined = typeof window !== 'undefined'; // The polyfill can’t function properly without `window` or `window.getComputedStyle`.

  if (!isWindowDefined || !window.getComputedStyle) seppuku = true; // Dont’t get in a way if the browser supports `position: sticky` natively.
  else {
      const testNode = document.createElement('div');
      if (['', '-webkit-', '-moz-', '-ms-'].some(prefix => {
        try {
          testNode.style.position = prefix + 'sticky';
        } catch (e) {}

        return testNode.style.position != '';
      })) seppuku = true;
    }
  /*
   * 2. “Global” vars used across the polyfill
   */

  let isInitialized = false; // Check if Shadow Root constructor exists to make further checks simpler

  const shadowRootExists = typeof ShadowRoot !== 'undefined'; // Last saved scroll position

  const scroll = {
    top: null,
    left: null
  }; // Array of created Sticky instances

  const stickies = [];
  /*
   * 3. Utility functions
   */

  function extend(targetObj, sourceObject) {
    for (var key in sourceObject) {
      if (sourceObject.hasOwnProperty(key)) {
        targetObj[key] = sourceObject[key];
      }
    }
  }

  function parseNumeric(val) {
    return parseFloat(val) || 0;
  }

  function getDocOffsetTop(node) {
    let docOffsetTop = 0;

    while (node) {
      docOffsetTop += node.offsetTop;
      node = node.offsetParent;
    }

    return docOffsetTop;
  }
  /*
   * 4. Sticky class
   */


  class Sticky {
    constructor(node) {
      if (!(node instanceof HTMLElement)) throw new Error('First argument must be HTMLElement');
      if (stickies.some(sticky => sticky._node === node)) throw new Error('Stickyfill is already applied to this node');
      this._node = node;
      this._stickyMode = null;
      this._active = false;
      stickies.push(this);
      this.refresh();
    }

    refresh() {
      if (seppuku || this._removed) return;
      if (this._active) this._deactivate();
      const node = this._node;
      /*
       * 1. Save node computed props
       */

      const nodeComputedStyle = getComputedStyle(node);
      const nodeComputedProps = {
        position: nodeComputedStyle.position,
        top: nodeComputedStyle.top,
        display: nodeComputedStyle.display,
        marginTop: nodeComputedStyle.marginTop,
        marginBottom: nodeComputedStyle.marginBottom,
        marginLeft: nodeComputedStyle.marginLeft,
        marginRight: nodeComputedStyle.marginRight,
        cssFloat: nodeComputedStyle.cssFloat
      };
      /*
       * 2. Check if the node can be activated
       */

      if (isNaN(parseFloat(nodeComputedProps.top)) || nodeComputedProps.display == 'table-cell' || nodeComputedProps.display == 'none') return;
      this._active = true;
      /*
       * 3. Check if the current node position is `sticky`. If it is, it means that the browser supports sticky positioning,
       *    but the polyfill was force-enabled. We set the node’s position to `static` before continuing, so that the node
       *    is in it’s initial position when we gather its params.
       */

      const originalPosition = node.style.position;
      if (nodeComputedStyle.position == 'sticky' || nodeComputedStyle.position == '-webkit-sticky') node.style.position = 'static';
      /*
       * 4. Get necessary node parameters
       */

      const referenceNode = node.parentNode;
      const parentNode = shadowRootExists && referenceNode instanceof ShadowRoot ? referenceNode.host : referenceNode;
      const nodeWinOffset = node.getBoundingClientRect();
      const parentWinOffset = parentNode.getBoundingClientRect();
      const parentComputedStyle = getComputedStyle(parentNode);
      this._parent = {
        node: parentNode,
        styles: {
          position: parentNode.style.position
        },
        offsetHeight: parentNode.offsetHeight
      };
      this._offsetToWindow = {
        left: nodeWinOffset.left,
        right: document.documentElement.clientWidth - nodeWinOffset.right
      };
      this._offsetToParent = {
        top: nodeWinOffset.top - parentWinOffset.top - parseNumeric(parentComputedStyle.borderTopWidth),
        left: nodeWinOffset.left - parentWinOffset.left - parseNumeric(parentComputedStyle.borderLeftWidth),
        right: -nodeWinOffset.right + parentWinOffset.right - parseNumeric(parentComputedStyle.borderRightWidth)
      };
      this._styles = {
        position: originalPosition,
        top: node.style.top,
        bottom: node.style.bottom,
        left: node.style.left,
        right: node.style.right,
        width: node.style.width,
        marginTop: node.style.marginTop,
        marginLeft: node.style.marginLeft,
        marginRight: node.style.marginRight
      };
      const nodeTopValue = parseNumeric(nodeComputedProps.top);
      this._limits = {
        start: nodeWinOffset.top + window.pageYOffset - nodeTopValue,
        end: parentWinOffset.top + window.pageYOffset + parentNode.offsetHeight - parseNumeric(parentComputedStyle.borderBottomWidth) - node.offsetHeight - nodeTopValue - parseNumeric(nodeComputedProps.marginBottom)
      };
      /*
       * 5. Ensure that the node will be positioned relatively to the parent node
       */

      const parentPosition = parentComputedStyle.position;

      if (parentPosition != 'absolute' && parentPosition != 'relative') {
        parentNode.style.position = 'relative';
      }
      /*
       * 6. Recalc node position.
       *    It’s important to do this before clone injection to avoid scrolling bug in Chrome.
       */


      this._recalcPosition();
      /*
       * 7. Create a clone
       */


      const clone = this._clone = {};
      clone.node = document.createElement('div'); // Apply styles to the clone

      extend(clone.node.style, {
        width: nodeWinOffset.right - nodeWinOffset.left + 'px',
        height: nodeWinOffset.bottom - nodeWinOffset.top + 'px',
        marginTop: nodeComputedProps.marginTop,
        marginBottom: nodeComputedProps.marginBottom,
        marginLeft: nodeComputedProps.marginLeft,
        marginRight: nodeComputedProps.marginRight,
        cssFloat: nodeComputedProps.cssFloat,
        padding: 0,
        border: 0,
        borderSpacing: 0,
        fontSize: '1em',
        position: 'static'
      });
      referenceNode.insertBefore(clone.node, node);
      clone.docOffsetTop = getDocOffsetTop(clone.node);
    }

    _recalcPosition() {
      if (!this._active || this._removed) return;
      const stickyMode = scroll.top <= this._limits.start ? 'start' : scroll.top >= this._limits.end ? 'end' : 'middle';
      if (this._stickyMode == stickyMode) return;

      switch (stickyMode) {
        case 'start':
          extend(this._node.style, {
            position: 'absolute',
            left: this._offsetToParent.left + 'px',
            right: this._offsetToParent.right + 'px',
            top: this._offsetToParent.top + 'px',
            bottom: 'auto',
            width: 'auto',
            marginLeft: 0,
            marginRight: 0,
            marginTop: 0
          });
          break;

        case 'middle':
          extend(this._node.style, {
            position: 'fixed',
            left: this._offsetToWindow.left + 'px',
            right: this._offsetToWindow.right + 'px',
            top: this._styles.top,
            bottom: 'auto',
            width: 'auto',
            marginLeft: 0,
            marginRight: 0,
            marginTop: 0
          });
          break;

        case 'end':
          extend(this._node.style, {
            position: 'absolute',
            left: this._offsetToParent.left + 'px',
            right: this._offsetToParent.right + 'px',
            top: 'auto',
            bottom: 0,
            width: 'auto',
            marginLeft: 0,
            marginRight: 0
          });
          break;
      }

      this._stickyMode = stickyMode;
    }

    _fastCheck() {
      if (!this._active || this._removed) return;
      if (Math.abs(getDocOffsetTop(this._clone.node) - this._clone.docOffsetTop) > 1 || Math.abs(this._parent.node.offsetHeight - this._parent.offsetHeight) > 1) this.refresh();
    }

    _deactivate() {
      if (!this._active || this._removed) return;

      this._clone.node.parentNode.removeChild(this._clone.node);

      delete this._clone;
      extend(this._node.style, this._styles);
      delete this._styles; // Check whether element’s parent node is used by other stickies.
      // If not, restore parent node’s styles.

      if (!stickies.some(sticky => sticky !== this && sticky._parent && sticky._parent.node === this._parent.node)) {
        extend(this._parent.node.style, this._parent.styles);
      }

      delete this._parent;
      this._stickyMode = null;
      this._active = false;
      delete this._offsetToWindow;
      delete this._offsetToParent;
      delete this._limits;
    }

    remove() {
      this._deactivate();

      stickies.some((sticky, index) => {
        if (sticky._node === this._node) {
          stickies.splice(index, 1);
          return true;
        }
      });
      this._removed = true;
    }

  }
  /*
   * 5. Stickyfill API
   */


  const Stickyfill = {
    stickies,
    Sticky,

    forceSticky() {
      seppuku = false;
      init();
      this.refreshAll();
    },

    addOne(node) {
      // Check whether it’s a node
      if (!(node instanceof HTMLElement)) {
        // Maybe it’s a node list of some sort?
        // Take first node from the list then
        if (node.length && node[0]) node = node[0];else return;
      } // Check if Stickyfill is already applied to the node
      // and return existing sticky


      for (var i = 0; i < stickies.length; i++) {
        if (stickies[i]._node === node) return stickies[i];
      } // Create and return new sticky


      return new Sticky(node);
    },

    add(nodeList) {
      // If it’s a node make an array of one node
      if (nodeList instanceof HTMLElement) nodeList = [nodeList]; // Check if the argument is an iterable of some sort

      if (!nodeList.length) return; // Add every element as a sticky and return an array of created Sticky instances

      const addedStickies = [];

      for (let i = 0; i < nodeList.length; i++) {
        const node = nodeList[i]; // If it’s not an HTMLElement – create an empty element to preserve 1-to-1
        // correlation with input list

        if (!(node instanceof HTMLElement)) {
          addedStickies.push(void 0);
          continue;
        } // If Stickyfill is already applied to the node
        // add existing sticky


        if (stickies.some(sticky => {
          if (sticky._node === node) {
            addedStickies.push(sticky);
            return true;
          }
        })) continue; // Create and add new sticky

        addedStickies.push(new Sticky(node));
      }

      return addedStickies;
    },

    refreshAll() {
      stickies.forEach(sticky => sticky.refresh());
    },

    removeOne(node) {
      // Check whether it’s a node
      if (!(node instanceof HTMLElement)) {
        // Maybe it’s a node list of some sort?
        // Take first node from the list then
        if (node.length && node[0]) node = node[0];else return;
      } // Remove the stickies bound to the nodes in the list


      stickies.some(sticky => {
        if (sticky._node === node) {
          sticky.remove();
          return true;
        }
      });
    },

    remove(nodeList) {
      // If it’s a node make an array of one node
      if (nodeList instanceof HTMLElement) nodeList = [nodeList]; // Check if the argument is an iterable of some sort

      if (!nodeList.length) return; // Remove the stickies bound to the nodes in the list

      for (let i = 0; i < nodeList.length; i++) {
        const node = nodeList[i];
        stickies.some(sticky => {
          if (sticky._node === node) {
            sticky.remove();
            return true;
          }
        });
      }
    },

    removeAll() {
      while (stickies.length) stickies[0].remove();
    }

  };
  /*
   * 6. Setup events (unless the polyfill was disabled)
   */

  function init() {
    if (isInitialized) {
      return;
    }

    isInitialized = true; // Watch for scroll position changes and trigger recalc/refresh if needed

    function checkScroll() {
      if (window.pageXOffset != scroll.left) {
        scroll.top = window.pageYOffset;
        scroll.left = window.pageXOffset;
        Stickyfill.refreshAll();
      } else if (window.pageYOffset != scroll.top) {
        scroll.top = window.pageYOffset;
        scroll.left = window.pageXOffset; // recalc position for all stickies

        stickies.forEach(sticky => sticky._recalcPosition());
      }
    }

    checkScroll();
    window.addEventListener('scroll', checkScroll); // Watch for window resizes and device orientation changes and trigger refresh

    window.addEventListener('resize', Stickyfill.refreshAll);
    window.addEventListener('orientationchange', Stickyfill.refreshAll); //Fast dirty check for layout changes every 500ms

    let fastCheckTimer;

    function startFastCheckTimer() {
      fastCheckTimer = setInterval(function () {
        stickies.forEach(sticky => sticky._fastCheck());
      }, 500);
    }

    function stopFastCheckTimer() {
      clearInterval(fastCheckTimer);
    }

    let docHiddenKey;
    let visibilityChangeEventName;

    if ('hidden' in document) {
      docHiddenKey = 'hidden';
      visibilityChangeEventName = 'visibilitychange';
    } else if ('webkitHidden' in document) {
      docHiddenKey = 'webkitHidden';
      visibilityChangeEventName = 'webkitvisibilitychange';
    }

    if (visibilityChangeEventName) {
      if (!document[docHiddenKey]) startFastCheckTimer();
      document.addEventListener(visibilityChangeEventName, () => {
        if (document[docHiddenKey]) {
          stopFastCheckTimer();
        } else {
          startFastCheckTimer();
        }
      });
    } else startFastCheckTimer();
  }

  if (!seppuku) init();

  /**
   * Polyfill to support matches on IE9+
   *
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill}
   */
  if (!Element.prototype.matches) Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

  /**
   * Polyfill for Element.closest()
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill}
   */
  if (!Element.prototype.closest) Element.prototype.closest = function (s) {
    var el = this;
    if (!document.documentElement.contains(el)) return null;

    do {
      if (el.matches(s)) return el;
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1);

    return null;
  };

  (function (UX) {
    /**
     ****************************
     ***** Sticky Elements ******
     ****************************
     *
     * Sticky Elements object is responsible for stickiness in all UX3 sites, it uses CSS3 `position: sticky;`
     * instead of `fixed`, for IE it uses `stickybits` plugin as a polyfill. Covering all sticky cases
     * in UX3 with minimum code. Also. Hooks can be used for extending its functionality. It used
     * to replace old stickiness solutions:(1) Header with position fixed. (2) CoolBar with
     * stickybar.js. (3) sticko.js plugin (4) Scroll them fix header-scroll-fix.js
     *
     */
    UX.stickyElements = {
      /**
       * Different Selectors
       */
      selectors: {
        'header': '.header',
        'scrollThenFix': '.scrollThenFix',
        'stickyElements': ['.fixed-element'],
        // Elements can be in header cause its height to be dynamic
        'dynamicHeader': ['.pb-ad', '.cookiePolicy-popup', '.header__dropzone'],
        'stickoParent': '.sticko__parent'
      },

      /**
       * Holds header object
       * @type {HTMLElement}
       */
      header: null,

      /**
       * Toggle header stickiness
       * @type {boolean}
       */
      isHeaderSticky: true,

      /**
       * Use dynamic header height computed by JS instead of CSS fixed value
       * @type {boolean}
       */
      dynamicHeaderHeight: false,
      // For responsive
      vPort: 'screen-sm',
      isMobile: false,

      init() {
        this.header = document.querySelector(this.selectors['header']);
        if (this.isHeaderSticky) this.selectors['stickyElements'].unshift(this.selectors['header']);

        this._isDynamicHeaderHeight();

        this.start();
        this.responsive();
        this.extra();
      },

      responsive() {
        // TODO: get rid of jQuery
        $(document).on('smartResize', () => this.start());
        $(document).on(`${this.vPort}-on`, () => this.isMobile = true);
        $(document).on(`${this.vPort}-off`, () => this.isMobile = false);
      },

      extra() {},

      start() {
        this.computeHeaderHeight();

        if (this.selectors['stickyElements'].length) {
          /** @type {NodeListOf<HTMLElement>} */
          const matched = document.querySelectorAll(this.selectors['stickyElements'].join(','));
          if (!matched || !matched.length) return;
          matched.forEach(item => {
            const isHeader = item.matches(this.selectors['header']);
            this.makeSticky(item, isHeader);
          });
        }
      },

      /**
       * Make sure stickyElements are stick correctly
       * @param {HTMLElement} item
       * @param {boolean} isHeader
       */
      makeSticky(item, isHeader) {
        this.setTopValue(item, isHeader);
        this.postStickyActions(item, isHeader); // if IE use polyfill

        if (isIE) {
          Stickyfill.addOne(item);
        }
      },

      setTopValue(item, isHeader) {
        if (this._canSetTopValue(item, isHeader)) {
          item.style.top = this.headerHeight + 'px';
        }
      },

      /**
       * This is a magical method to run specific actions after making items sticky based on what is the item.
       * actions are saved in groups in this._actions object and they called dynamically.
       * @param {HTMLElement} item
       * @param {boolean} isHeader
       * @protected
       */
      postStickyActions: function (item, isHeader) {
        if (this._has(item, this.selectors['stickoParent'], true)) {
          this.stickoActions(item);
        }

        if (this._has(item, this.selectors['scrollThenFix'])) {
          this.scrollThenFixActions(item, isHeader);
        }
      },

      /**
       * Set sticko height to fill the viewport excluding the fixed header
       * @param {HTMLElement} item
       * @protected
       */
      stickoActions(item) {
        const stickoParent = item.querySelector(this.selectors['stickoParent']) || item;
        if (this.isHeaderSticky) stickoParent.style.height = `calc(100vh - ${this.headerHeight}px)`;else stickoParent.style.height = '100vh';
        document.addEventListener('change:auto-hide-bar', () => {
          item.style.top = `${fixedHeaderHeight()}px`;
        });
      },

      /**
       * Make it sticky as soon as reach the fixed element inside it
       * @param {HTMLElement} item
       * @param {boolean} isHeader
       */
      scrollThenFixActions(item, isHeader) {
        item.classList.add('fixed-element');
        let scrollThenFixOffset = item.querySelector(this.selectors['scrollThenFix']).offsetTop;
        scrollThenFixOffset -= !isHeader ? this.header.getBoundingClientRect().height : 0;
        item.style.top = `${-1 * scrollThenFixOffset}px`;
      },

      /**
       * Check if to use dynamic header height
       * @return {void}
       * @private
       */
      _isDynamicHeaderHeight() {
        if (!this.dynamicHeaderHeight) {
          for (let i = 0; i < this.selectors['dynamicHeader'].length; i++) {
            this.dynamicHeaderHeight = this._has(this.header, this.selectors['dynamicHeader'][i], true);
            if (this.dynamicHeaderHeight) break;
          }
        }
      },

      computeHeaderHeight() {
        this.headerHeight = fixedHeaderHeight(this.selectors['header']);
      },

      /**
       *
       * @param {HTMLElement} item
       * @param {string} selector
       * @param {boolean} [self]
       * @return {*|boolean}
       * @private
       */
      _has(item, selector, self) {
        return item && (item.querySelector(selector) !== null // if item contains element matches the selector
        || self && item.matches(selector) // or item itself matches the selector
        );
      },

      _canSetTopValue(item, isHeader) {
        return !isHeader && this.dynamicHeaderHeight && item.closest(this.selectors['header']) === null;
      }

    };
  })(UX);

  (function () {
    var $body = $('body'),
        $document = $(document);
    var list = {
      init: function () {
        list.on.build();
        list.control();
      },
      control: function () {
        $body.on('click', '.expandable-list__toggle', function (e) {
          e.preventDefault();
          list.on.toggleList($(this));
        });
      },
      on: {
        build: function () {
          var $wrapper = $('.expandable-list');
          var $toggle = $('.expandable-list__toggle');
          $wrapper.each(function () {
            var $target = $(this).find('.expandable-list__body');
            var $toggle = $(this).find('.expandable-list__toggle');
            $target.hide();
          });
        },
        toggleList: function (elem) {
          var $toggle = elem;
          var $wrapper = $toggle.closest('.expandable-list');
          var $target = $wrapper.find('.expandable-list__body').toggle();
          $wrapper.toggleClass('js--open');
          $toggle.find('i').toggleClass('icon-add_box icon-squared-minus');

          if ($wrapper.hasClass('js--open')) {
            $toggle.attr('aria-expanded', true);
            $target.attr('aria-hidden', false);
          } else {
            $toggle.attr('aria-expanded', false);
            $target.attr('aria-hidden', true);
          }
        },
        closeList: function (elem) {
          var $wrapper = $('.expandable-list');
          $wrapper.removeClass('js--open');
          var $target = $wrapper.find('.expandable-list__body').hide();
          var $toggle = $('.expandable-list__toggle');
          $toggle.attr('aria-expanded', 'false').find('i').addClass('icon-add_box').removeClass('icon-squared-minus');
          $target.attr('aria-hidden', true);
        }
      }
    };
    UX.list = list; // add to global namespace
  })();

  (function () {
    /**
     * @deprecated
     */
    UX.pageBody = {
      init: function () {
        this.extraControls();
      },

      extraControls() {}

    }; // add to global namespace
  })();

  (function () {
    var iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

    if (iOS) {
      $('body').addClass('iOS');
    }
  })();

  // Import components

  function menubar$1(e, t) {
    this.$id = $("#" + e), this.$rootItems = this.$id.children("li"), this.$items = this.$id.find(".menu-item"), this.$parents = this.$id.find(".menu-parent"), this.$allItems = this.$parents.add(this.$items), this.$activeItem = null, this.vmenu = t, this.bChildOpen = !1, this.keys = {
      tab: 9,
      enter: 13,
      esc: 27,
      space: 32,
      left: 37,
      up: 38,
      right: 39,
      down: 40
    }, this.bindHandlers();
  }

  menubar$1.prototype.bindHandlers = function () {
    var e = this;
    this.$allItems.keydown(function (t) {
      return e.handleKeyDown($(this), t);
    }), this.$allItems.keypress(function (t) {
      return e.handleKeyPress($(this), t);
    }), this.$allItems.focus(function (t) {
      return e.handleFocus($(this), t);
    }), $(document).click(function (t) {
      return e.handleDocumentClick(t);
    });
  };

  menubar$1.prototype.handleFocus = function (e, t) {
    if (null == this.$activeItem) this.$activeItem = e;else if (e[0] != this.$activeItem[0]) return !0;
    var i = this.$activeItem.parentsUntil("div").filter("li");
    if (this.$allItems.removeClass("menu-focus menu-focus-checked"), this.$activeItem.is(".checked") ? this.$activeItem.addClass("menu-focus-checked") : this.$activeItem.addClass("menu-focus"), i.addClass("menu-focus"), 1 == this.vmenu) if (1 == this.bChildOpen) {
      var s = e.parent();
      s.is("#menubar") && "true" == e.attr("aria-haspopup") && e.addClass('hover').children("ul").attr("aria-hidden", "false");
    } else this.vmenu = !1;
    return !0;
  };

  menubar$1.prototype.handleKeyDown = function (e, t) {
    if (t.altKey || t.ctrlKey) return !0;

    switch (t.keyCode) {
      case this.keys.tab:
        this.$id.find("ul").attr("aria-hidden", "true"), this.$allItems.removeClass("menu-focus hover"), this.$activeItem = null, 0 == this.bChildOpen;
        break;

      case this.keys.esc:
        if (UX.menu.$toggle.length > 0) {
          //if (e.keyCode  === escKey) {
          //e.preventDefault();
          UX.menu.on.hide();
          UX.menu.$toggle.focus(); //}
        } else {
          var i = e.parent();
          return i.is("#menubar") ? (e.removeClass('hover').children("ul").first().attr("aria-hidden", "true"), e.focus()) : (this.$activeItem = i.parent(), e.removeClass('hover'), this.bChildOpen = !1, this.$activeItem.focus(), i.attr("aria-hidden", "true")), t.stopPropagation(), !1;
        }

      case this.keys.enter:
      case this.keys.space:
        var s = e.parent();
        return s.is("#menubar") ? (e.addClass('hover').children("ul").first().attr("aria-hidden", "false"), this.bChildOpen = !0, this.processMenuChoice(e), e.find("ul > li:first").find("a").focus()) : (this.processMenuChoice(e), this.$allItems.removeClass("menu-hover menu-hover-checked hover"), this.$allItems.removeClass("menu-focus menu-focus-checked hover"), this.$id.find("ul").not("#menubar").attr("aria-hidden", "true"), this.$activeItem = null), t.stopPropagation(), !1;

      case this.keys.left:
        return 1 == this.vmenu && i.is("#menubar") ? this.$activeItem = this.moveUp(e) : this.$activeItem = this.moveToPrevious(e), this.$activeItem.focus(), t.stopPropagation(), !1;

      case this.keys.right:
        return 1 == this.vmenu && i.is("#menubar") ? this.$activeItem = this.moveDown(e) : this.$activeItem = this.moveToNext(e), this.$activeItem.focus(), t.stopPropagation(), !1;

      case this.keys.up:
        return 1 == this.vmenu && i.is("#menubar") ? this.$activeItem = this.moveToPrevious(e) : this.$activeItem = this.moveUp(e), this.$activeItem.focus(), t.stopPropagation(), !1;

      case this.keys.down:
        return 1 == this.vmenu && i.is("#menubar") ? this.$activeItem = this.moveToNext(e) : this.$activeItem = this.moveDown(e), this.$activeItem.focus(), t.stopPropagation(), !1;
    }

    return !0;
  };

  menubar$1.prototype.moveToNext = function (e) {
    var t = e.parent(),
        i = t.children("li"),
        s = i.length,
        r = i.index(e),
        n = null;

    if (t.is("#menubar")) {
      if (n = s - 1 > r ? e.next() : i.first(), "true" == e.attr("aria-haspopup")) {
        e.removeClass('hover');
        var a = e.children("ul").first();
        "false" == a.attr("aria-hidden") && (a.attr("aria-hidden", "true"), this.bChildOpen = !0);
      }

      if (e.removeClass("menu-focus"), "true" == n.attr("aria-haspopup") && 1 == this.bChildOpen) {
        n.addClass('hover');
        var a = n.children("ul").first();
        a.attr("aria-hidden", "false");
      }
    } else if ("true" == e.attr("aria-haspopup")) {
      e.addClass('hover');
      var a = e.children("ul").first();
      n = a.children("li").first(), a.attr("aria-hidden", "false"), this.bChildOpen = !0;
    } else {
      if (1 == this.vmenu) return e;
      var h = null,
          o = null;

      if (h = e.parentsUntil("div").filter("ul").not("#menubar"), h.attr("aria-hidden", "true"), h.find("li").removeClass("menu-focus hover"), h.last().parent().removeClass("menu-focus hover"), o = h.last().parent(), r = this.$rootItems.index(o), n = r < this.$rootItems.length - 1 ? o.next() : this.$rootItems.first(), "true" == n.attr("aria-haspopup") && n.children("ul").length > 0) {
        n.addClass('hover');
        var a = n.children("ul").first();
        n = a.children("li").first(), a.attr("aria-hidden", "false"), this.bChildOpen = !0;
      }
    }

    return n;
  };

  menubar$1.prototype.moveToPrevious = function (e) {
    var t = e.parent(),
        i = t.children("li"),
        s = (i.length, i.index(e)),
        r = null;

    if (t.is("#menubar")) {
      if (r = s > 0 ? e.prev() : i.last(), "true" == e.attr("aria-haspopup")) {
        var n = e.removeClass('hover').children("ul").first();
        "false" == n.attr("aria-hidden") && (n.attr("aria-hidden", "true"), this.bChildOpen = !0);
      }

      if (e.removeClass("menu-focus hover"), "true" == r.attr("aria-haspopup") && 1 == this.bChildOpen) {
        r.addClass('hover');
        var n = r.children("ul").first();
        n.attr("aria-hidden", "false");
      }
    } else {
      var a = t.parent(),
          h = a.parent();

      if (1 != this.vmenu && h.is("#menubar")) {
        if (t.attr("aria-hidden", "true"), e.removeClass("menu-focus hover"), a.removeClass("menu-focus hover"), s = this.$rootItems.index(a), r = s > 0 ? a.prev() : this.$rootItems.last(), r.addClass("menu-focus hover"), "true" == r.attr("aria-haspopup")) {
          var n = null;
          r.children("ul").length > 0 && (n = r.addClass('hover').children("ul").first(), n.attr("aria-hidden", "false"), this.bChildOpen = !0, r = n.children("li").first());
        }
      } else r = t.parent(), t.attr("aria-hidden", "true"), e.removeClass("menu-focus hover"), r.removeClass("hover"), 1 == this.vmenu && (this.bChildOpen = !1);
    }

    return r;
  };

  menubar$1.prototype.moveDown = function (e, t) {
    var i = e.parent(),
        s = i.children("li").not(".separator"),
        r = s.length,
        n = s.index(e),
        a = null,
        h = null;
    if (i.is("#menubar")) return "true" != e.attr("aria-haspopup") ? e : (h = e.addClass('hover').children("ul").first(), a = h.children("li").first(), h.attr("aria-hidden", "false"), this.bChildOpen = !0, a);

    if (t) {
      var o = !1,
          u = n + 1;

      for (u == r && (u = 0); u != n;) {
        var l = s.eq(u).html().charAt(0);

        if (l.toLowerCase() == t) {
          o = !0;
          break;
        }

        u += 1, u == r && (u = 0);
      }

      return 1 == o ? (a = s.eq(u), e.removeClass("menu-focus menu-focus-checked"), a) : e;
    }

    return a = r - 1 > n ? s.eq(n + 1) : s.first(), e.removeClass("menu-focus menu-focus-checked"), a;
  };

  menubar$1.prototype.moveUp = function (e) {
    var t = e.parent(),
        i = t.children("li").not(".separator"),
        s = (i.length, i.index(e)),
        r = null;
    return t.is("#menubar") ? e : (r = s > 0 ? i.eq(s - 1) : i.last(), e.removeClass("menu-focus menu-focus-checked"), r);
  };

  menubar$1.prototype.handleKeyPress = function (e, t) {
    if (t.altKey || t.ctrlKey || t.shiftKey) return !0;

    switch (t.keyCode) {
      case this.keys.tab:
        return !0;

      case this.keys.esc:
      case this.keys.enter:
      case this.keys.space:
      case this.keys.up:
      case this.keys.down:
      case this.keys.left:
      case this.keys.right:
        return t.stopPropagation(), !1;

      default:
        var i = String.fromCharCode(t.which);
        return this.$activeItem = this.moveDown(e, i), this.$activeItem.focus(), t.stopPropagation(), !1;
    }

    return !0;
  };

  menubar$1.prototype.handleDocumentClick = function (e) {
    var t = this.$id.find("ul").not("#menubar");
    return t.attr("aria-hidden", "true"), this.$allItems.removeClass("menu-focus menu-focus-checked hover"), this.$activeItem = null, !0;
  };

  menubar$1.prototype.processMenuChoice = function (e) {
    var t = (e.parent().attr("id"), e.attr("id"), e.data("href"));
    if (null != t) if (t.toLowerCase().indexOf("legacy.") > 0) {
      var i = window.open(t, "_blank");
      i.focus();
    } else window.location.href = t;
    var s = e.find("a");
    null != s && (window.location.href = s[0].href);
  };

  window.menubar = menubar$1;

  (function () {
    //document.activeElement
    var $body = $('body'),
        $window = $(window),
        tabKey = 9,
        escKey = 27,
        nestedMenu;
    var menu = {
      $toggle: $('[data-toggle="nav"]'),
      $target: null,
      revers: false,
      lastItem: null,
      items: null,
      vPort: ["screen-sm"],
      isMobile: false,
      // variable use to determine if responsive mode is on or off
      menuHeaderMainTitle: '',
      redirectPath: false,
      displayedNestedItems: false,
      init: function () {
        var menu1 = new menubar('menubar', false);
        $('.main-nav').each(function (index) {
          menu.$target = $(this);
          const $header = menu.$target.find('.menu-header');
          menu.menuHeaderMainTitle = $header.text();
          menu.redirectPath = $header.data('redirect-to');
          menu.check.viewPort(index);
          menu.responsive(index);
        });
        menu.items = $('.main-nav').find('a, button, input'); //$(".header__nav a, .header__nav button, .header__nav input");

        menu.control();
        menu.additionalControl();
      },
      responsive: function (index) {
        $(document).on(menu.vPort[index] + '-on', function () {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          menu.isMobile = true;
          $('.main-nav').each(function () {
            if ($(this).find('.drawer__nav').data('ctrl-res') == menu.vPort[index]) {
              $(this).addClass("menu--res"); // class will be used in our scss (to replace media queries)

              menu.on.rebuild.responsive(); // rebuild menu to be responsive - drawer
            }
          });
        });
        $(document).on(menu.vPort[index] + '-off', function () {
          // Waiting for custom event that will be triggered by controller.js to deactivate responsive effects
          menu.isMobile = false;
          $('.main-nav').each(function () {
            if ($(this).find('.drawer__nav').data('ctrl-res') == menu.vPort[index]) {
              $(this).removeClass("menu--res"); // class will be used in our scss (to replace media queries)

              menu.on.rebuild.original(); // return menu as default
            }
          });
        });
      },
      control: function () {
        $body.on('click', '[data-toggle="nav"]', function (e) {
          e.preventDefault();
          menu.$toggle = $(this);
          menu.$target = $('#' + menu.$toggle.data('target'));
          menu.items = menu.$target.find('a, button, input'); //$(".header__nav a, .header__nav button, .header__nav input");

          menu.items.each(function (index) {
            if (index === menu.items.length - 1) {
              menu.lastItem = $(this);
            }
          });
          menu.on.show(e);
        });
        $body.on('click', '.js--open[data-toggle="nav"]', function (e) {
          e.preventDefault();
          menu.on.hide(e);
        });
        $body.on('click', function (e) {
          if (!$(e.target).closest('.dropdown__toggle').length) {
            $("a.dropdown__toggle.hover").removeClass("hover");
          }

          if (!$(e.target).hasClass("icon-arrow_r") && !$(e.target).parents('.main-nav.menu--res').length && $('.lock-screen[data-active="menu"]').length) {
            menu.on.hide(e);
          }
        });
        $body.on('click', '.main-nav a', function (e) {
          if ($(this).attr('href') == "#") {
            e.preventDefault();
          }
        });
        $body.on('click', '[data-toggle="dropdown"]', function (e) {
          e.preventDefault();
          nestedMenu = $(this);
          menu.on.nested(e);
        });
        $body.on('click', '.menu-header', function (e) {
          e.preventDefault();

          if (menu.isMobile) {
            menu.on.hideNested(true);
          }

          e.stopPropagation(); // prevent closing menu when getting back from nested menu
        });
        $body.on('keydown', '.drawer__nav, [data-toggle="nav"]', function (e) {
          if (menu.isMobile) {
            if ((e.keyCode || e.which) === tabKey) {
              if (!menu.revers) {
                menu.on.tab();
              } else {
                menu.on.tabRevers();
              }
            }
          }
        });
        $window.on('keyup', function (e) {
          menu.revers = false;

          if (e.shiftKey && e.keyCode === tabKey) {
            menu.revers = true;
          }

          if (!menu.isMobile) {
            if ((e.keyCode || e.which) === tabKey) {
              if (!menu.revers) {
                menu.on.tabDesktop(e);
              } else {
                menu.on.tabReversDesktop(e);
              }
            }

            if ((e.keyCode || e.which) === escKey) {
              menu.on.escDesktop(e);
            }
          }
        });
      },
      additionalControl: function () {},
      on: {
        show: function () {
          if (typeof UX.controller != "undefined") {
            UX.controller.check();
          }

          $body.addClass('lock-screen').attr('data-active', 'menu');
          menu.$toggle.addClass('js--open');
          menu.$target.closest('.main-nav').css('top', $window.scrollTop());
          $('.coolBar--res').removeClass('trans').css('top', $window.scrollTop() + $('header').height());
          $('.loi__banner.loi--res').css('top', $window.scrollTop() + $('header').height());
          menu.$target.attr("style", "display: block !important");
          menu.$toggle.focus();
          menu.on.showAdditional();
        },
        showAdditional: function () {},
        showNested: function () {
          nestedMenu.next('.dropdown__menu').toggleClass('sub-menu__opened');
          nestedMenu.parent().toggleClass('menu-parent__opened');
          nestedMenu.find('i').toggleClass('opposite-arrow');
          nestedMenu.parent().siblings('li').toggleClass('prev-items');
          nestedMenu.toggleClass('prev-items');
          $("[data-toggle='nav']").addClass("js--nested-open"); // replace Close button with back button after nested menu get opened

          var $menuTitle = nestedMenu.html();

          if ($('.menu-header').length) {
            $('.menu-header').html($menuTitle);
          }

          menu.displayedNestedItems = true;
          menu.on.showNestedExtra();
        },
        showNestedExtra: function () {},
        hideNested: function (shouldNavigate = false) {
          var $menuHeader = $('.menu-header');
          var $parenNestedMenu;

          if (typeof nestedMenu != 'undefined') {
            $parenNestedMenu = nestedMenu.parent().parent(); // first parent list

            nestedMenu = $parenNestedMenu.parent().find('.dropdown__toggle'); // first parent dropdown toggle link

            $parenNestedMenu.find('.sub-menu__opened').removeClass('sub-menu__opened');
            $parenNestedMenu.find('.menu-parent__opened').removeClass('menu-parent__opened');
            $parenNestedMenu.find('.prev-items').removeClass('prev-items');
            $("[data-toggle='nav']").removeClass("js--nested-open");

            if ($parenNestedMenu.hasClass('sub-menu__opened')) {
              $menuHeader.find('span').html(nestedMenu.find('span').html());
            } else {
              if (menu.redirectPath && shouldNavigate && !menu.displayedNestedItems) {
                document.location = menu.redirectPath;
              } else {
                $menuHeader.html(menu.menuHeaderMainTitle);
                menu.displayedNestedItems = false;
              }
            }
          } else {
            nestedMenu = $menuHeader;
          }

          menu.on.hideNestedExtra();
        },
        hideNestedExtra: function () {},
        hide: function () {
          if (menu.isMobile) {
            // hide nested menu before closing
            menu.on.hideNested();
          }

          menu.$toggle.removeClass('js--open');
          $('.main-nav, header').css('top', 0);
          $('.coolBar--res').addClass('trans').css('top', $('header').height()); // The magic number contains 1px of border and

          $('.loi__banner.loi--res').css('top', $('header').height());
          $body.removeAttr('data-active').removeClass('lock-screen');
        },
        escape: function () {
          menu.on.hide();
          menu.$toggle.focus();
        },
        tab: function () {
          menu.$toggle.off();
          menu.lastItem.off().on('focusout', function () {
            menu.$toggle.focus();
          });
        },
        tabRevers: function () {
          menu.lastItem.off();
          menu.$toggle.off().on('focusout', function () {
            menu.lastItem.focus();
          });
        },
        tabDesktop: function (e) {
          if ($(e.target).hasClass("dropdown__toggle")) {
            if ($(e.target).closest(".hover").length == 0) {
              $('.dropdown__toggle').removeClass('hover');
              $('.dropdown').removeClass('js--open');
            }

            $(e.target).closest("a").addClass("hover");
          } else {
            $(e.target).closest("ul").find('.hover').each(function () {
              $(this).removeClass('hover');
            });
          }
        },
        tabReversDesktop: function (e) {
          if ($(e.target).hasClass("dropdown__toggle")) {
            if ($(e.target).closest(".hover").length == 0) {
              $('.dropdown__toggle').removeClass('hover');
            }

            $(e.target).closest("a").addClass("hover");
          } else if ($(e.target).closest(".hubpage-menu").length == 0 && $(e.target).closest(".main-nav").length == 0) {
            $('.dropdown__toggle').removeClass('hover');
          }
        },
        escDesktop: function (e) {
          $(e.target).closest(".dropdown__toggle").removeClass("hover");
        },
        rebuild: {
          responsive: function () {
            menu.on.hide();
          },
          original: function () {
            menu.on.hide();
            menu.$target.show();
          }
        },
        nested: function (e) {
          //e.preventDefault();
          if (menu.isMobile) {
            menu.on.showNested();
          }
        }
      },
      check: {
        viewPort: function (index) {
          if (menu.$target.find('.drawer__nav').attr('data-ctrl-res')) {
            menu.vPort[index] = menu.$target.find('.drawer__nav').attr('data-ctrl-res');
          }
        }
      }
    };
    UX.menu = menu; // add to global namespace
  })();

  (function () {
    var coolbar = {
      sections: null,
      holder: $('.coolBar--sections .coolBar__drop'),
      vPort: "screen-sm",
      isMobile: false,
      coolbarElement: null,
      headerHeight: 0,
      isStickyBar: false,
      lock: true,
      // define lock and set default value, this lock will be used to make sure to run certain functionality and to run on every scroll event
      init: function () {
        coolbar.coolbarElement = $(".coolBar");
        coolbar.isStickyBar = coolbar.coolbarElement.hasClass("stickybar");
        coolbar.get.sections();
        coolbar.fill.sections();
        coolbar.control();
        coolbar.addtionalControls();
      },
      control: function () {
        if ($('.journal-home').length) {
          coolbar.vPort = "screen-md";
        }

        $(document).on(coolbar.vPort + '-on', function () {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          $('.coolBar').addClass("coolBar--res"); // class will be used in our scss (to replace media queries)

          coolbar.isMobile = true;

          if ($(".stickybar.coolBar--res,.coolBar.coolBar--res").length > 0) {
            $(".content>article.container").addClass("article--res");
          }
        });
        $(document).on(coolbar.vPort + '-off', function () {
          // Waiting for custom event that will be triggered by controller.js to deactivate responsive effects
          $('.coolBar').removeClass("coolBar--res");
          $(".content article.container").removeClass("article--res");
          $(document).trigger("eventSetContentPadding");
          coolbar.isMobile = false;

          if (typeof UX.controller !== 'undefined') {
            UX.controller.check();
          }
        });
      },
      addtionalControls: function () {},
      get: {
        sections: function () {
          coolbar.sections = $('.article__content .section__title');
        }
      },
      fill: {
        sections: function () {
          if ($('.coolBar--sections').length && coolbar.sections.length > 1) {
            $('.coolBar--sections').removeClass("hidden");
            var ul = $('<ul class="rlist w-slide--list"/>').appendTo(coolbar.holder);
            coolbar.sections.each(function () {
              var $this = $(this);
              var li = $('<li/>').attr('role', 'menuitem').appendTo(ul);
              var link = $('<a class="w-slide__hide"/>').attr('href', "#" + $this.attr('id')).appendTo(li);
              var spaner = $('<span/>').text($(this).text()).appendTo(link);
            });
          } else {
            $('.coolBar--sections').remove();
          }

          if ($('.authorArticleInfoCon').length) {
            $(".coolBar--sections .coolBar__drop").append('<li role="menuitem"><a class="w-slide__hide" href="#_ac_authorArticleInfoCon" target="_self"><span>Author and Article Information</span></a></li>');
          }
        }
      }
    };
    UX.coolbar = coolbar; // add to global namespace
  })();

  // tabs.js calls UX.dropBlock.init(); on line 260
  // profile-menu.js calls UX.dropBlock.init(); on line 53
  (function () {
    var $window = $(window),
        $body = $('body');
    var dropBlock = {
      $controllers: $("[data-db-target-for]"),
      $targets: null,
      // Holds all targets in Dom
      $controller: null,
      // Current drop down controller
      $target: null,
      // Current target down controller element
      $parents: null,
      // Hodls all parents in Dom
      $parent: null,
      // Current parent element
      escape: 27,
      $container: $(".container"),
      switchVal: null,
      $section: $(".dropBlock__holder"),
      vPort: "screen-sm",
      isMobile: false,
      initialized: false,
      direction: 'left',
      // left , right
      pop: 'down',
      // up , down
      init: function () {
        dropBlock.control();
      },
      control: function () {
        if (dropBlock.initialized) {
          return;
        }

        dropBlock.initialized = true;
        $(document).on('click', '[data-db-target-for]', function (e) {
          e.preventDefault();
          e.stopPropagation();
          var isOpen = $(this).hasClass("js--open"),
              isDataSlideTarget = $(this).is('[data-slide-target]'),
              disableOnMobile = $(this).data('db-sm-disable') || false;
          dropBlock.$controller = $(this);
          dropBlock.find.target();

          if (isOpen) {
            dropBlock.on.hide();
          } else {
            if (dropBlock.isMobile && (isDataSlideTarget !== false || disableOnMobile)) {
              return;
            } else {
              dropBlock.on.show(e);
            }
          }
        });
        $(document).on('click', '.coolBar:not(.loi__banner) [data-db-target-of] a:not([data-slide-target])', function (e) {
          dropBlock.on.hide();
        });
        $window.on('resize', function () {
          if (dropBlock.$parent != null) {
            dropBlock.find.dimensions();
          }
        });
        $(document).on(dropBlock.vPort + '-on', function () {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          dropBlock.isMobile = true;
        });
        $(document).on(dropBlock.vPort + '-off', function () {
          // Waiting for custom event that will be triggered by controller.js to deactivate responsive effects
          dropBlock.isMobile = false;
        });
      },
      on: {
        show: function (e) {
          // show  target element
          if (!dropBlock.$controller.closest(".dropBlock__holder").length) {
            if (typeof UX.controller != "undefined") {
              UX.controller.check(e);
            }
          }

          if (dropBlock.$target) {
            dropBlock.$controller.trigger('dropBlock:open', [dropBlock]);
            dropBlock.$target.addClass("js--open");
            dropBlock.$controller.addClass("js--open");
            $body.attr('data-active', 'dropBlock');
            dropBlock.$target.closest("[class*='sticko']").addClass("js--open");
            dropBlock.switch.icon(); // Move focus to active inner component, or leave focus on control

            dropBlock.$target.find('.active :tabbable').first().focus(); // Accessibility

            dropBlock.$controller.attr({
              'aria-expanded': 'true'
            });
            dropBlock.$target.removeAttr('aria-hidden'); // @fixme - this should not be here at all - it should be moved to proper component

            var isLoi = dropBlock.$target.find('.loi').length > 0;

            if (isLoi) {
              dropBlock.$target.find('.loi__list').each(function () {
                UX.loi.on.recalculate($(this));
              });
            }

            dropBlock.$controller.trigger('dropBlock:opened', [dropBlock]);
          }
        },
        hide: function () {
          // hide target element
          if (dropBlock.$target) {
            dropBlock.$controller.trigger('dropBlock:close', [dropBlock]); // Close current target

            dropBlock.$controller.removeClass("js--open");
            dropBlock.$target.removeClass("js--open"); // Play nicely with others ...
            // For plugins which don't use js--open class but uses .hide .show methods instead, reset them ...
            // For example LOA accordion

            if (dropBlock.$target.attr('style')) {
              dropBlock.$target.removeAttr('style');
            } // Explicitly for our accordion working as a drop-block


            dropBlock.$target.closest("[class*='accordion-tabbed__tab']").removeClass("js--open");
            dropBlock.$target.closest("[class*='sticko']").removeClass("js--open");
            dropBlock.switch.back(); // Accessibility - Inform screen readers

            dropBlock.$controller.attr({
              'aria-expanded': 'false'
            });
            dropBlock.$target.attr({
              'aria-hidden': 'true'
            }); // Nested dropBlocks close handling

            if (dropBlock.$parentSection && dropBlock.$parentSection.length) {
              // Nested ones - set parent after closing self - will close parent in second round
              dropBlock.$controller = $('[data-db-target-for="' + dropBlock.$parentSection.attr('data-db-target-of') + '"]');
              dropBlock.find.target();
            } else {
              // If we want to close last drop block, than there is no more active component
              if ($body.attr('data-active') === "dropBlock") {
                $body.removeAttr('data-active');
                $('body, html').removeClass('lock-screen'); // @todo investigate if this is needed for drop Blocks or was copied out of other component
              }
            }

            if (dropBlock.$target) {
              dropBlock.$target.find('input:focus').blur();
            }

            dropBlock.$controller.trigger('dropBlock:closed', [dropBlock]);
          }
        },
        escape: function () {
          // hide target if user clicks escape key
          // @fixme this seems unused and deprecated by controller.js
          if (dropBlock.$target != null) {
            dropBlock.on.hide();
          }
        }
      },
      find: {
        target: function () {
          // get the target element if existed
          if ($("[data-db-target-of]").length) {
            dropBlock.$targets = $("[data-db-target-of]");
            dropBlock.$target = $("[data-db-target-of=" + dropBlock.$controller.attr("data-db-target-for") + "]");
            dropBlock.$section = dropBlock.$target;
            var $nested = dropBlock.$section.parents('.dropBlock__holder');

            if ($nested.length) {
              dropBlock.$parentSection = $nested;
            } else {
              dropBlock.$parentSection = null;
            }

            dropBlock.find.parent();
          }
        },
        parent: function () {
          // get the parent element if existed
          dropBlock.$parent = null;
          dropBlock.$parents = $("[data-db-parent-of]");

          if (dropBlock.$parents.length) {
            dropBlock.$parents.each(function () {
              const current = dropBlock.$controller.attr("data-db-target-for");
              let parentFor = $(this).data("db-parent-of").split(',');

              if (parentFor.indexOf(current) !== -1) {
                dropBlock.$parent = $(this);
                return false;
              }
            });

            if (dropBlock.$parent != null) {
              dropBlock.find.dimensions();
              dropBlock.find.ifContaind();
            }
          }
        },
        ifContaind: function () {
          // check if it parent or target has container element
          if (dropBlock.$parent.find(".container").length && !dropBlock.$target.find(".container").length) {
            dropBlock.$target.wrapInner("<div class='container'></div>");
          }
        },
        dimensions: function () {
          // count the top and left position of the target element based on teh parent element
          var nHeight = dropBlock.$parent.outerHeight(),
              pOffset = dropBlock.$parent.offset(),
              pLeft = pOffset.left,
              nWidth = dropBlock.$parent.innerWidth(),
              styles = {},
              container_offset = pOffset;
          dropBlock.$container = $(".container");

          if (dropBlock.$container.length) {
            container_offset = dropBlock.$container.offset();
          }

          var container_left = container_offset.left,
              container_base = container_left + dropBlock.$container.width(),
              parent_base = nWidth + pLeft;

          if (dropBlock.$parent.find(".scrollThenFix").length) {
            nHeight = dropBlock.$parent.find(".scrollThenFix").outerHeight();
          }

          if (dropBlock.$parent.innerWidth() == dropBlock.$controller.innerWidth()) {
            nWidth = dropBlock.$parent.hasClass('no-auto-width') ? "" : "auto";

            if (dropBlock.isMobile) {
              nWidth = dropBlock.$parent.hasClass('no-auto-width') ? "" : "100%";
            }
          }

          if (parent_base > container_base) {
            styles = {
              top: nHeight,
              right: "0px",
              width: nWidth
            };
          } else {
            styles = {
              top: nHeight,
              width: nWidth
            };
            let direction = dropBlock.$parent.data('db-direction') || dropBlock.direction;

            switch (direction) {
              case 'left':
              case 'right':
                styles[direction] = '0px';
                break;

              case 'center':
                let offset = dropBlock.$target.innerWidth() / 2 - dropBlock.$parent.innerWidth();
                styles['left'] = `calc(-50% - ${offset}px)`;
            }
          }

          dropBlock.$target.css(styles);
        }
      },
      switch: {
        icon: function () {
          dropBlock.switchVal = dropBlock.$controller.attr("data-db-switch");

          switch (dropBlock.switchVal) {
            case "none":
              break;

            case "rotate":
              dropBlock.$controller.find("i").addClass("js--rotated");
              break;

            default:
              dropBlock.$controller.find("i").addClass(dropBlock.switchVal);
          }
        },
        back: function () {
          dropBlock.$controllers.each(function () {
            var temp = $(this).attr("data-db-switch");

            switch (temp) {
              case "none":
                break;

              case "rotate":
                $(this).find("i").removeClass("js--rotated");
                break;

              default:
                if (temp !== undefined) $(this).find("i").removeClass(temp);
            }
          });
        }
      }
    };
    UX.dropBlock = dropBlock; // add to global namespace
  })();

  /* ========================================================================
   * Bootstrap: modal.js v3.3.7
   * http://getbootstrap.com/javascript/#modals
   * ========================================================================
   * Copyright 2011-2016 Twitter, Inc.
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * ======================================================================== */
  +function ($) {
    // ======================

    var Modal = function (element, options) {
      this.options = options;
      this.$body = $(document.body);
      this.$element = $(element);
      this.$dialog = this.$element.find('.modal-dialog');
      this.$backdrop = null;
      this.isShown = null;
      this.originalBodyPad = null;
      this.scrollbarWidth = 0;
      this.ignoreBackdropClick = false;

      if (this.options.remote) {
        this.$element.find('.modal-content').load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal');
        }, this));
      }
    };

    Modal.VERSION = '3.3.7';
    Modal.TRANSITION_DURATION = 300;
    Modal.BACKDROP_TRANSITION_DURATION = 150;
    Modal.DEFAULTS = {
      backdrop: true,
      keyboard: true,
      show: true
    };

    Modal.prototype.toggle = function (_relatedTarget) {
      return this.isShown ? this.hide() : this.show(_relatedTarget);
    };

    Modal.prototype.show = function (_relatedTarget) {
      var that = this;
      var e = $.Event('show.bs.modal', {
        relatedTarget: _relatedTarget
      });
      this.$element.trigger(e);
      if (this.isShown || e.isDefaultPrevented()) return;
      this.isShown = true;
      this.checkScrollbar();
      this.setScrollbar();
      this.$body.addClass('modal-open');
      this.escape();
      this.resize();
      this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this));
      this.$dialog.on('mousedown.dismiss.bs.modal', function () {
        that.$element.one('mouseup.dismiss.bs.modal', function (e) {
          if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true;
        });
      });
      this.backdrop(function () {
        var transition = $.support.transition && that.$element.hasClass('fade');

        if (!that.$element.parent().length) {
          that.$element.appendTo(that.$body); // don't move modals dom position
        }

        that.$element.show().scrollTop(0);
        that.adjustDialog();

        if (transition) {
          that.$element[0].offsetWidth; // force reflow
        }

        that.$element.addClass('in');
        that.enforceFocus();
        var e = $.Event('shown.bs.modal', {
          relatedTarget: _relatedTarget
        });
        transition ? that.$dialog // wait for modal to slide in
        .one('bsTransitionEnd', function () {
          that.$element.trigger('focus').trigger(e);
        }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger('focus').trigger(e);
      });
    };

    Modal.prototype.hide = function (e) {
      if (e) e.preventDefault();
      e = $.Event('hide.bs.modal');
      this.$element.trigger(e);
      if (!this.isShown || e.isDefaultPrevented()) return;
      this.isShown = false;
      this.escape();
      this.resize();
      $(document).off('focusin.bs.modal');
      this.$element.removeClass('in').off('click.dismiss.bs.modal').off('mouseup.dismiss.bs.modal');
      this.$dialog.off('mousedown.dismiss.bs.modal');
      $.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal();
    };

    Modal.prototype.enforceFocus = function () {
      $(document).off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (document !== e.target && this.$element[0] !== e.target && !this.$element.has(e.target).length) {
          this.$element.trigger('focus');
        }
      }, this));
    };

    Modal.prototype.escape = function () {
      if (this.isShown && this.options.keyboard) {
        this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
          e.which == 27 && this.hide();
        }, this));
      } else if (!this.isShown) {
        this.$element.off('keydown.dismiss.bs.modal');
      }
    };

    Modal.prototype.resize = function () {
      if (this.isShown) {
        $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this));
      } else {
        $(window).off('resize.bs.modal');
      }
    };

    Modal.prototype.hideModal = function () {
      var that = this;
      this.$element.hide();
      this.backdrop(function () {
        that.$body.removeClass('modal-open');
        that.resetAdjustments();
        that.resetScrollbar();
        that.$element.trigger('hidden.bs.modal');
      });
    };

    Modal.prototype.removeBackdrop = function () {
      this.$backdrop && this.$backdrop.remove();
      this.$backdrop = null;
    };

    Modal.prototype.backdrop = function (callback) {
      var that = this;
      var animate = this.$element.hasClass('fade') ? 'fade' : '';

      if (this.isShown && this.options.backdrop) {
        var doAnimate = $.support.transition && animate;
        this.$backdrop = $(document.createElement('div')).addClass('modal-backdrop ' + animate).insertAfter(this.$element);
        this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
          if (this.ignoreBackdropClick) {
            this.ignoreBackdropClick = false;
            return;
          }

          if (e.target !== e.currentTarget) return;
          this.options.backdrop == 'static' ? this.$element[0].focus() : this.hide();
        }, this));
        if (doAnimate) this.$backdrop[0].offsetWidth; // force reflow

        this.$backdrop.addClass('in');
        if (!callback) return;
        doAnimate ? this.$backdrop.one('bsTransitionEnd', callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
      } else if (!this.isShown && this.$backdrop) {
        this.$backdrop.removeClass('in');

        var callbackRemove = function () {
          that.removeBackdrop();
          callback && callback();
        };

        $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one('bsTransitionEnd', callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
      } else if (callback) {
        callback();
      }
    }; // these following methods are used to handle overflowing modals


    Modal.prototype.handleUpdate = function () {
      this.adjustDialog();
    };

    Modal.prototype.adjustDialog = function () {
      var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
      this.$element.css({
        paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
        paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
      });
    };

    Modal.prototype.resetAdjustments = function () {
      this.$element.css({
        paddingLeft: '',
        paddingRight: ''
      });
    };

    Modal.prototype.checkScrollbar = function () {
      var fullWindowWidth = window.innerWidth;

      if (!fullWindowWidth) {
        // workaround for missing window.innerWidth in IE8
        var documentElementRect = document.documentElement.getBoundingClientRect();
        fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
      }

      this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
      this.scrollbarWidth = this.measureScrollbar();
    };

    Modal.prototype.setScrollbar = function () {
      var bodyPad = parseInt(this.$body.css('padding-right') || 0, 10);
      this.originalBodyPad = document.body.style.paddingRight || '';
      if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth);
    };

    Modal.prototype.resetScrollbar = function () {
      this.$body.css('padding-right', this.originalBodyPad);
    };

    Modal.prototype.measureScrollbar = function () {
      // thx walsh
      var scrollDiv = document.createElement('div');
      scrollDiv.className = 'modal-scrollbar-measure';
      this.$body.append(scrollDiv);
      var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
      this.$body[0].removeChild(scrollDiv);
      return scrollbarWidth;
    }; // MODAL PLUGIN DEFINITION
    // =======================


    function Plugin(option, _relatedTarget) {
      return this.each(function () {
        var $this = $(this);
        var data = $this.data('bs.modal');
        var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option);
        if (!data) $this.data('bs.modal', data = new Modal(this, options));
        if (typeof option == 'string') data[option](_relatedTarget);else if (options.show) data.show(_relatedTarget);
      });
    }

    var old = $.fn.modal;
    $.fn.modal = Plugin;
    $.fn.modal.Constructor = Modal; // MODAL NO CONFLICT
    // =================

    $.fn.modal.noConflict = function () {
      $.fn.modal = old;
      return this;
    }; // MODAL DATA-API
    // ==============


    $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
      var $this = $(this);
      var href = $this.attr('href');
      var $target = $($this.attr('data-target') || href && href.replace(/.*(?=#[^\s]+$)/, '')); // strip for ie7

      var option = $target.data('bs.modal') ? 'toggle' : $.extend({
        remote: !/#/.test(href) && href
      }, $target.data(), $this.data());
      if ($this.is('a')) e.preventDefault();
      $target.one('show.bs.modal', function (showEvent) {
        if (showEvent.isDefaultPrevented()) return; // only register focus restorer if modal will actually get shown

        $target.one('hidden.bs.modal', function () {
          $this.is(':visible') && $this.trigger('focus');
        });
      });
      Plugin.call($target, option, this);
    });
  }(jQuery);

  (function () {
    var $body = $('body'),
        $window = $(window),
        tabKey = 9,
        shift = 16;
    var modal = {
      $toggle: $('[data-toggle="modal"]'),
      $target: null,
      revers: false,
      lastItem: null,
      items: null,
      $close: null,
      accessibilityEnabled: true,
      init: function () {
        if (this.accessibilityEnabled) modal.accessibility.init();
        modal.$target = $(modal.$toggle.data('target'));
        modal.control();
      },
      accessibility: {
        init: function () {
          // Move every modal outside of content in order to be able hide and show page content for screen readers
          // @note: for some reason, it is not working with tab trap correctly, when we append it to body - after(.content) works fine
          var $content = $('main.content');

          if ($content.length) {
            $content.after($('.ux-modal-container'));
          } // Text for close buttons


          $('[data-dismiss="modal"]').append('<span class="sr-only">Close modal</span>');
        },
        show: function () {
          $('.content, .footer, .header').attr('aria-hidden', true);
        },
        hide: function () {
          $('.content, .footer, .header').removeAttr('aria-hidden');
        }
      },
      control: function () {
        $body.on('click', '[data-toggle="modal"]', function (e) {
          e.preventDefault();
          modal.$toggle = $(this);
          modal.$target = $(modal.$toggle.data('target'));
          modal.$close = modal.$target.find('.close');
          modal.items = modal.$target.find('a, button, input');
          modal.items.each(function (index) {
            if (index === modal.items.length - 1) {
              modal.lastItem = $(this);
            }
          });
          modal.on.show();
        });
        $body.on('click', '.modal', function (e) {
          var target = $(e.target);

          if (!target.is('.modal__dialog') && !target.closest('.modal__dialog').length > 0) {
            //e.preventDefault();
            modal.on.hide();
          }
        });
        $body.on('click', '[data-dismiss="modal"]', function (e) {
          modal.on.hide();
        });
        $('.modal').on('keydown', function (e) {
          if (e.keyCode === shift) {
            modal.revers = true;
          }

          if ((e.keyCode || e.which) === tabKey) {
            if (!modal.revers) {
              modal.on.tab();
            } else {
              modal.on.tabRevers();
            }
          }
        });
        $window.on('keyup', function (e) {
          if (e.keyCode === shift) {
            modal.revers = false;
          }
        });
      },
      on: {
        show: function (e) {
          if (typeof UX.controller !== "undefined") {
            UX.controller.check();
          }

          setTimeout(function () {
            $body.attr('data-active', 'modal');
            modal.accessibility.show();
            var $autofocus = modal.$target.find('[autofocus]');
            if ($autofocus.length) $autofocus.focus();else modal.$close.focus();
          }, 250);
          modal.$target.closest("[class*='sticko']").addClass("js--open");
          $("#externalEmailDialogForm").addClass("pairing-management-modal");
        },
        hide: function () {
          $body.removeAttr('data-active');
          modal.accessibility.hide();
          modal.$target.closest("[class*='sticko']").removeClass("js--open");
        },
        tab: function () {
          modal.$close.off('focusout');
          modal.lastItem.off('focusout');
          modal.lastItem.on('focusout', function () {
            modal.$close.focus();
          });
        },
        tabRevers: function () {
          modal.lastItem.off('focusout');
          modal.$close.off('focusout');
          modal.$close.on('focusout', function () {
            modal.lastItem.focus();
          });
        }
      }
    };
    UX.modal = modal; // add to global namespace
  })();

  /**
   * Owl Carousel v2.3.4
   * Copyright 2013-2018 David Deutsch
   * Licensed under: SEE LICENSE IN https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE
   */
  !function (a, b, c, d) {
    function e(b, c) {
      this.settings = null, this.options = a.extend({}, e.Defaults, c), this.$element = a(b), this._handlers = {}, this._plugins = {}, this._supress = {}, this._current = null, this._speed = null, this._coordinates = [], this._breakpoint = null, this._width = null, this._items = [], this._clones = [], this._mergers = [], this._widths = [], this._invalidated = {}, this._pipe = [], this._drag = {
        time: null,
        target: null,
        pointer: null,
        stage: {
          start: null,
          current: null
        },
        direction: null
      }, this._states = {
        current: {},
        tags: {
          initializing: ["busy"],
          animating: ["busy"],
          dragging: ["interacting"]
        }
      }, a.each(["onResize", "onThrottledResize"], a.proxy(function (b, c) {
        this._handlers[c] = a.proxy(this[c], this);
      }, this)), a.each(e.Plugins, a.proxy(function (a, b) {
        this._plugins[a.charAt(0).toLowerCase() + a.slice(1)] = new b(this);
      }, this)), a.each(e.Workers, a.proxy(function (b, c) {
        this._pipe.push({
          filter: c.filter,
          run: a.proxy(c.run, this)
        });
      }, this)), this.setup(), this.initialize();
    }

    e.Defaults = {
      items: 3,
      loop: !1,
      center: !1,
      rewind: !1,
      checkVisibility: !0,
      mouseDrag: !0,
      touchDrag: !0,
      pullDrag: !0,
      freeDrag: !1,
      margin: 0,
      stagePadding: 0,
      merge: !1,
      mergeFit: !0,
      autoWidth: !1,
      startPosition: 0,
      rtl: !1,
      smartSpeed: 250,
      fluidSpeed: !1,
      dragEndSpeed: !1,
      responsive: {},
      responsiveRefreshRate: 200,
      responsiveBaseElement: b,
      fallbackEasing: "swing",
      slideTransition: "",
      info: !1,
      nestedItemSelector: !1,
      itemElement: "div",
      stageElement: "div",
      refreshClass: "owl-refresh",
      loadedClass: "owl-loaded",
      loadingClass: "owl-loading",
      rtlClass: "owl-rtl",
      responsiveClass: "owl-responsive",
      dragClass: "owl-drag",
      itemClass: "owl-item",
      stageClass: "owl-stage",
      stageOuterClass: "owl-stage-outer",
      grabClass: "owl-grab"
    }, e.Width = {
      Default: "default",
      Inner: "inner",
      Outer: "outer"
    }, e.Type = {
      Event: "event",
      State: "state"
    }, e.Plugins = {}, e.Workers = [{
      filter: ["width", "settings"],
      run: function () {
        this._width = this.$element.width();
      }
    }, {
      filter: ["width", "items", "settings"],
      run: function (a) {
        a.current = this._items && this._items[this.relative(this._current)];
      }
    }, {
      filter: ["items", "settings"],
      run: function () {
        this.$stage.children(".cloned").remove();
      }
    }, {
      filter: ["width", "items", "settings"],
      run: function (a) {
        var b = this.settings.margin || "",
            c = !this.settings.autoWidth,
            d = this.settings.rtl,
            e = {
          width: "auto",
          "margin-left": d ? b : "",
          "margin-right": d ? "" : b
        };
        !c && this.$stage.children().css(e), a.css = e;
      }
    }, {
      filter: ["width", "items", "settings"],
      run: function (a) {
        var b = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,
            c = null,
            d = this._items.length,
            e = !this.settings.autoWidth,
            f = [];

        for (a.items = {
          merge: !1,
          width: b
        }; d--;) c = this._mergers[d], c = this.settings.mergeFit && Math.min(c, this.settings.items) || c, a.items.merge = c > 1 || a.items.merge, f[d] = e ? b * c : this._items[d].width();

        this._widths = f;
      }
    }, {
      filter: ["items", "settings"],
      run: function () {
        var b = [],
            c = this._items,
            d = this.settings,
            e = Math.max(2 * d.items, 4),
            f = 2 * Math.ceil(c.length / 2),
            g = d.loop && c.length ? d.rewind ? e : Math.max(e, f) : 0,
            h = "",
            i = "";

        for (g /= 2; g > 0;) b.push(this.normalize(b.length / 2, !0)), h += c[b[b.length - 1]][0].outerHTML, b.push(this.normalize(c.length - 1 - (b.length - 1) / 2, !0)), i = c[b[b.length - 1]][0].outerHTML + i, g -= 1;

        this._clones = b, a(h).addClass("cloned").appendTo(this.$stage), a(i).addClass("cloned").prependTo(this.$stage);
      }
    }, {
      filter: ["width", "items", "settings"],
      run: function () {
        for (var a = this.settings.rtl ? 1 : -1, b = this._clones.length + this._items.length, c = -1, d = 0, e = 0, f = []; ++c < b;) d = f[c - 1] || 0, e = this._widths[this.relative(c)] + this.settings.margin, f.push(d + e * a);

        this._coordinates = f;
      }
    }, {
      filter: ["width", "items", "settings"],
      run: function () {
        var a = this.settings.stagePadding,
            b = this._coordinates,
            c = {
          width: Math.ceil(Math.abs(b[b.length - 1])) + 2 * a,
          "padding-left": a || "",
          "padding-right": a || ""
        };
        this.$stage.css(c);
      }
    }, {
      filter: ["width", "items", "settings"],
      run: function (a) {
        var b = this._coordinates.length,
            c = !this.settings.autoWidth,
            d = this.$stage.children();
        if (c && a.items.merge) for (; b--;) a.css.width = this._widths[this.relative(b)], d.eq(b).css(a.css);else c && (a.css.width = a.items.width, d.css(a.css));
      }
    }, {
      filter: ["items"],
      run: function () {
        this._coordinates.length < 1 && this.$stage.removeAttr("style");
      }
    }, {
      filter: ["width", "items", "settings"],
      run: function (a) {
        a.current = a.current ? this.$stage.children().index(a.current) : 0, a.current = Math.max(this.minimum(), Math.min(this.maximum(), a.current)), this.reset(a.current);
      }
    }, {
      filter: ["position"],
      run: function () {
        this.animate(this.coordinates(this._current));
      }
    }, {
      filter: ["width", "position", "items", "settings"],
      run: function () {
        var a,
            b,
            c,
            d,
            e = this.settings.rtl ? 1 : -1,
            f = 2 * this.settings.stagePadding,
            g = this.coordinates(this.current()) + f,
            h = g + this.width() * e,
            i = [];

        for (c = 0, d = this._coordinates.length; c < d; c++) a = this._coordinates[c - 1] || 0, b = Math.abs(this._coordinates[c]) + f * e, (this.op(a, "<=", g) && this.op(a, ">", h) || this.op(b, "<", g) && this.op(b, ">", h)) && i.push(c);

        this.$stage.children(".active").removeClass("active"), this.$stage.children(":eq(" + i.join("), :eq(") + ")").addClass("active"), this.$stage.children(".center").removeClass("center"), this.settings.center && this.$stage.children().eq(this.current()).addClass("center");
      }
    }], e.prototype.initializeStage = function () {
      this.$stage = this.$element.find("." + this.settings.stageClass), this.$stage.length || (this.$element.addClass(this.options.loadingClass), this.$stage = a("<" + this.settings.stageElement + ">", {
        class: this.settings.stageClass
      }).wrap(a("<div/>", {
        class: this.settings.stageOuterClass
      })), this.$element.append(this.$stage.parent()));
    }, e.prototype.initializeItems = function () {
      var b = this.$element.find(".owl-item");
      if (b.length) return this._items = b.get().map(function (b) {
        return a(b);
      }), this._mergers = this._items.map(function () {
        return 1;
      }), void this.refresh();
      this.replace(this.$element.children().not(this.$stage.parent())), this.isVisible() ? this.refresh() : this.invalidate("width"), this.$element.removeClass(this.options.loadingClass).addClass(this.options.loadedClass);
    }, e.prototype.initialize = function () {
      if (this.enter("initializing"), this.trigger("initialize"), this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl), this.settings.autoWidth && !this.is("pre-loading")) {
        var a, b, c;
        a = this.$element.find("img"), b = this.settings.nestedItemSelector ? "." + this.settings.nestedItemSelector : d, c = this.$element.children(b).width(), a.length && c <= 0 && this.preloadAutoWidthImages(a);
      }

      this.initializeStage(), this.initializeItems(), this.registerEventHandlers(), this.leave("initializing"), this.trigger("initialized");
    }, e.prototype.isVisible = function () {
      return !this.settings.checkVisibility || this.$element.is(":visible");
    }, e.prototype.setup = function () {
      var b = this.viewport(),
          c = this.options.responsive,
          d = -1,
          e = null;
      c ? (a.each(c, function (a) {
        a <= b && a > d && (d = Number(a));
      }), e = a.extend({}, this.options, c[d]), "function" == typeof e.stagePadding && (e.stagePadding = e.stagePadding()), delete e.responsive, e.responsiveClass && this.$element.attr("class", this.$element.attr("class").replace(new RegExp("(" + this.options.responsiveClass + "-)\\S+\\s", "g"), "$1" + d))) : e = a.extend({}, this.options), this.trigger("change", {
        property: {
          name: "settings",
          value: e
        }
      }), this._breakpoint = d, this.settings = e, this.invalidate("settings"), this.trigger("changed", {
        property: {
          name: "settings",
          value: this.settings
        }
      });
    }, e.prototype.optionsLogic = function () {
      this.settings.autoWidth && (this.settings.stagePadding = !1, this.settings.merge = !1);
    }, e.prototype.prepare = function (b) {
      var c = this.trigger("prepare", {
        content: b
      });
      return c.data || (c.data = a("<" + this.settings.itemElement + "/>").addClass(this.options.itemClass).append(b)), this.trigger("prepared", {
        content: c.data
      }), c.data;
    }, e.prototype.update = function () {
      for (var b = 0, c = this._pipe.length, d = a.proxy(function (a) {
        return this[a];
      }, this._invalidated), e = {}; b < c;) (this._invalidated.all || a.grep(this._pipe[b].filter, d).length > 0) && this._pipe[b].run(e), b++;

      this._invalidated = {}, !this.is("valid") && this.enter("valid");
    }, e.prototype.width = function (a) {
      switch (a = a || e.Width.Default) {
        case e.Width.Inner:
        case e.Width.Outer:
          return this._width;

        default:
          return this._width - 2 * this.settings.stagePadding + this.settings.margin;
      }
    }, e.prototype.refresh = function () {
      this.enter("refreshing"), this.trigger("refresh"), this.setup(), this.optionsLogic(), this.$element.addClass(this.options.refreshClass), this.update(), this.$element.removeClass(this.options.refreshClass), this.leave("refreshing"), this.trigger("refreshed");
    }, e.prototype.onThrottledResize = function () {
      b.clearTimeout(this.resizeTimer), this.resizeTimer = b.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);
    }, e.prototype.onResize = function () {
      return !!this._items.length && this._width !== this.$element.width() && !!this.isVisible() && (this.enter("resizing"), this.trigger("resize").isDefaultPrevented() ? (this.leave("resizing"), !1) : (this.invalidate("width"), this.refresh(), this.leave("resizing"), void this.trigger("resized")));
    }, e.prototype.registerEventHandlers = function () {
      a.support.transition && this.$stage.on(a.support.transition.end + ".owl.core", a.proxy(this.onTransitionEnd, this)), !1 !== this.settings.responsive && this.on(b, "resize", this._handlers.onThrottledResize), this.settings.mouseDrag && (this.$element.addClass(this.options.dragClass), this.$stage.on("mousedown.owl.core", a.proxy(this.onDragStart, this)), this.$stage.on("dragstart.owl.core selectstart.owl.core", function () {
        return !1;
      })), this.settings.touchDrag && (this.$stage.on("touchstart.owl.core", a.proxy(this.onDragStart, this)), this.$stage.on("touchcancel.owl.core", a.proxy(this.onDragEnd, this)));
    }, e.prototype.onDragStart = function (b) {
      var d = null;
      3 !== b.which && (a.support.transform ? (d = this.$stage.css("transform").replace(/.*\(|\)| /g, "").split(","), d = {
        x: d[16 === d.length ? 12 : 4],
        y: d[16 === d.length ? 13 : 5]
      }) : (d = this.$stage.position(), d = {
        x: this.settings.rtl ? d.left + this.$stage.width() - this.width() + this.settings.margin : d.left,
        y: d.top
      }), this.is("animating") && (a.support.transform ? this.animate(d.x) : this.$stage.stop(), this.invalidate("position")), this.$element.toggleClass(this.options.grabClass, "mousedown" === b.type), this.speed(0), this._drag.time = new Date().getTime(), this._drag.target = a(b.target), this._drag.stage.start = d, this._drag.stage.current = d, this._drag.pointer = this.pointer(b), a(c).on("mouseup.owl.core touchend.owl.core", a.proxy(this.onDragEnd, this)), a(c).one("mousemove.owl.core touchmove.owl.core", a.proxy(function (b) {
        var d = this.difference(this._drag.pointer, this.pointer(b));
        a(c).on("mousemove.owl.core touchmove.owl.core", a.proxy(this.onDragMove, this)), Math.abs(d.x) < Math.abs(d.y) && this.is("valid") || (b.preventDefault(), this.enter("dragging"), this.trigger("drag"));
      }, this)));
    }, e.prototype.onDragMove = function (a) {
      var b = null,
          c = null,
          d = null,
          e = this.difference(this._drag.pointer, this.pointer(a)),
          f = this.difference(this._drag.stage.start, e);
      this.is("dragging") && (a.preventDefault(), this.settings.loop ? (b = this.coordinates(this.minimum()), c = this.coordinates(this.maximum() + 1) - b, f.x = ((f.x - b) % c + c) % c + b) : (b = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum()), c = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum()), d = this.settings.pullDrag ? -1 * e.x / 5 : 0, f.x = Math.max(Math.min(f.x, b + d), c + d)), this._drag.stage.current = f, this.animate(f.x));
    }, e.prototype.onDragEnd = function (b) {
      var d = this.difference(this._drag.pointer, this.pointer(b)),
          e = this._drag.stage.current,
          f = d.x > 0 ^ this.settings.rtl ? "left" : "right";
      a(c).off(".owl.core"), this.$element.removeClass(this.options.grabClass), (0 !== d.x && this.is("dragging") || !this.is("valid")) && (this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed), this.current(this.closest(e.x, 0 !== d.x ? f : this._drag.direction)), this.invalidate("position"), this.update(), this._drag.direction = f, (Math.abs(d.x) > 3 || new Date().getTime() - this._drag.time > 300) && this._drag.target.one("click.owl.core", function () {
        return !1;
      })), this.is("dragging") && (this.leave("dragging"), this.trigger("dragged"));
    }, e.prototype.closest = function (b, c) {
      var e = -1,
          f = 30,
          g = this.width(),
          h = this.coordinates();
      return this.settings.freeDrag || a.each(h, a.proxy(function (a, i) {
        return "left" === c && b > i - f && b < i + f ? e = a : "right" === c && b > i - g - f && b < i - g + f ? e = a + 1 : this.op(b, "<", i) && this.op(b, ">", h[a + 1] !== d ? h[a + 1] : i - g) && (e = "left" === c ? a + 1 : a), -1 === e;
      }, this)), this.settings.loop || (this.op(b, ">", h[this.minimum()]) ? e = b = this.minimum() : this.op(b, "<", h[this.maximum()]) && (e = b = this.maximum())), e;
    }, e.prototype.animate = function (b) {
      var c = this.speed() > 0;
      this.is("animating") && this.onTransitionEnd(), c && (this.enter("animating"), this.trigger("translate")), a.support.transform3d && a.support.transition ? this.$stage.css({
        transform: "translate3d(" + b + "px,0px,0px)",
        transition: this.speed() / 1e3 + "s" + (this.settings.slideTransition ? " " + this.settings.slideTransition : "")
      }) : c ? this.$stage.animate({
        left: b + "px"
      }, this.speed(), this.settings.fallbackEasing, a.proxy(this.onTransitionEnd, this)) : this.$stage.css({
        left: b + "px"
      });
    }, e.prototype.is = function (a) {
      return this._states.current[a] && this._states.current[a] > 0;
    }, e.prototype.current = function (a) {
      if (a === d) return this._current;
      if (0 === this._items.length) return d;

      if (a = this.normalize(a), this._current !== a) {
        var b = this.trigger("change", {
          property: {
            name: "position",
            value: a
          }
        });
        b.data !== d && (a = this.normalize(b.data)), this._current = a, this.invalidate("position"), this.trigger("changed", {
          property: {
            name: "position",
            value: this._current
          }
        });
      }

      return this._current;
    }, e.prototype.invalidate = function (b) {
      return "string" === a.type(b) && (this._invalidated[b] = !0, this.is("valid") && this.leave("valid")), a.map(this._invalidated, function (a, b) {
        return b;
      });
    }, e.prototype.reset = function (a) {
      (a = this.normalize(a)) !== d && (this._speed = 0, this._current = a, this.suppress(["translate", "translated"]), this.animate(this.coordinates(a)), this.release(["translate", "translated"]));
    }, e.prototype.normalize = function (a, b) {
      var c = this._items.length,
          e = b ? 0 : this._clones.length;
      return !this.isNumeric(a) || c < 1 ? a = d : (a < 0 || a >= c + e) && (a = ((a - e / 2) % c + c) % c + e / 2), a;
    }, e.prototype.relative = function (a) {
      return a -= this._clones.length / 2, this.normalize(a, !0);
    }, e.prototype.maximum = function (a) {
      var b,
          c,
          d,
          e = this.settings,
          f = this._coordinates.length;
      if (e.loop) f = this._clones.length / 2 + this._items.length - 1;else if (e.autoWidth || e.merge) {
        if (b = this._items.length) for (c = this._items[--b].width(), d = this.$element.width(); b-- && !((c += this._items[b].width() + this.settings.margin) > d););
        f = b + 1;
      } else f = e.center ? this._items.length - 1 : this._items.length - e.items;
      return a && (f -= this._clones.length / 2), Math.max(f, 0);
    }, e.prototype.minimum = function (a) {
      return a ? 0 : this._clones.length / 2;
    }, e.prototype.items = function (a) {
      return a === d ? this._items.slice() : (a = this.normalize(a, !0), this._items[a]);
    }, e.prototype.mergers = function (a) {
      return a === d ? this._mergers.slice() : (a = this.normalize(a, !0), this._mergers[a]);
    }, e.prototype.clones = function (b) {
      var c = this._clones.length / 2,
          e = c + this._items.length,
          f = function (a) {
        return a % 2 == 0 ? e + a / 2 : c - (a + 1) / 2;
      };

      return b === d ? a.map(this._clones, function (a, b) {
        return f(b);
      }) : a.map(this._clones, function (a, c) {
        return a === b ? f(c) : null;
      });
    }, e.prototype.speed = function (a) {
      return a !== d && (this._speed = a), this._speed;
    }, e.prototype.coordinates = function (b) {
      var c,
          e = 1,
          f = b - 1;
      return b === d ? a.map(this._coordinates, a.proxy(function (a, b) {
        return this.coordinates(b);
      }, this)) : (this.settings.center ? (this.settings.rtl && (e = -1, f = b + 1), c = this._coordinates[b], c += (this.width() - c + (this._coordinates[f] || 0)) / 2 * e) : c = this._coordinates[f] || 0, c = Math.ceil(c));
    }, e.prototype.duration = function (a, b, c) {
      return 0 === c ? 0 : Math.min(Math.max(Math.abs(b - a), 1), 6) * Math.abs(c || this.settings.smartSpeed);
    }, e.prototype.to = function (a, b) {
      var c = this.current(),
          d = null,
          e = a - this.relative(c),
          f = (e > 0) - (e < 0),
          g = this._items.length,
          h = this.minimum(),
          i = this.maximum();
      this.settings.loop ? (!this.settings.rewind && Math.abs(e) > g / 2 && (e += -1 * f * g), a = c + e, (d = ((a - h) % g + g) % g + h) !== a && d - e <= i && d - e > 0 && (c = d - e, a = d, this.reset(c))) : this.settings.rewind ? (i += 1, a = (a % i + i) % i) : a = Math.max(h, Math.min(i, a)), this.speed(this.duration(c, a, b)), this.current(a), this.isVisible() && this.update();
    }, e.prototype.next = function (a) {
      a = a || !1, this.to(this.relative(this.current()) + 1, a);
    }, e.prototype.prev = function (a) {
      a = a || !1, this.to(this.relative(this.current()) - 1, a);
    }, e.prototype.onTransitionEnd = function (a) {
      if (a !== d && (a.stopPropagation(), (a.target || a.srcElement || a.originalTarget) !== this.$stage.get(0))) return !1;
      this.leave("animating"), this.trigger("translated");
    }, e.prototype.viewport = function () {
      var d;
      return this.options.responsiveBaseElement !== b ? d = a(this.options.responsiveBaseElement).width() : b.innerWidth ? d = b.innerWidth : c.documentElement && c.documentElement.clientWidth ? d = c.documentElement.clientWidth : console.warn("Can not detect viewport width."), d;
    }, e.prototype.replace = function (b) {
      this.$stage.empty(), this._items = [], b && (b = b instanceof jQuery ? b : a(b)), this.settings.nestedItemSelector && (b = b.find("." + this.settings.nestedItemSelector)), b.filter(function () {
        return 1 === this.nodeType;
      }).each(a.proxy(function (a, b) {
        b = this.prepare(b), this.$stage.append(b), this._items.push(b), this._mergers.push(1 * b.find("[data-merge]").addBack("[data-merge]").attr("data-merge") || 1);
      }, this)), this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0), this.invalidate("items");
    }, e.prototype.add = function (b, c) {
      var e = this.relative(this._current);
      c = c === d ? this._items.length : this.normalize(c, !0), b = b instanceof jQuery ? b : a(b), this.trigger("add", {
        content: b,
        position: c
      }), b = this.prepare(b), 0 === this._items.length || c === this._items.length ? (0 === this._items.length && this.$stage.append(b), 0 !== this._items.length && this._items[c - 1].after(b), this._items.push(b), this._mergers.push(1 * b.find("[data-merge]").addBack("[data-merge]").attr("data-merge") || 1)) : (this._items[c].before(b), this._items.splice(c, 0, b), this._mergers.splice(c, 0, 1 * b.find("[data-merge]").addBack("[data-merge]").attr("data-merge") || 1)), this._items[e] && this.reset(this._items[e].index()), this.invalidate("items"), this.trigger("added", {
        content: b,
        position: c
      });
    }, e.prototype.remove = function (a) {
      (a = this.normalize(a, !0)) !== d && (this.trigger("remove", {
        content: this._items[a],
        position: a
      }), this._items[a].remove(), this._items.splice(a, 1), this._mergers.splice(a, 1), this.invalidate("items"), this.trigger("removed", {
        content: null,
        position: a
      }));
    }, e.prototype.preloadAutoWidthImages = function (b) {
      b.each(a.proxy(function (b, c) {
        this.enter("pre-loading"), c = a(c), a(new Image()).one("load", a.proxy(function (a) {
          c.attr("src", a.target.src), c.css("opacity", 1), this.leave("pre-loading"), !this.is("pre-loading") && !this.is("initializing") && this.refresh();
        }, this)).attr("src", c.attr("src") || c.attr("data-src") || c.attr("data-src-retina"));
      }, this));
    }, e.prototype.destroy = function () {
      this.$element.off(".owl.core"), this.$stage.off(".owl.core"), a(c).off(".owl.core"), !1 !== this.settings.responsive && (b.clearTimeout(this.resizeTimer), this.off(b, "resize", this._handlers.onThrottledResize));

      for (var d in this._plugins) this._plugins[d].destroy();

      this.$stage.children(".cloned").remove(), this.$stage.unwrap(), this.$stage.children().contents().unwrap(), this.$stage.children().unwrap(), this.$stage.remove(), this.$element.removeClass(this.options.refreshClass).removeClass(this.options.loadingClass).removeClass(this.options.loadedClass).removeClass(this.options.rtlClass).removeClass(this.options.dragClass).removeClass(this.options.grabClass).attr("class", this.$element.attr("class").replace(new RegExp(this.options.responsiveClass + "-\\S+\\s", "g"), "")).removeData("owl.carousel");
    }, e.prototype.op = function (a, b, c) {
      var d = this.settings.rtl;

      switch (b) {
        case "<":
          return d ? a > c : a < c;

        case ">":
          return d ? a < c : a > c;

        case ">=":
          return d ? a <= c : a >= c;

        case "<=":
          return d ? a >= c : a <= c;
      }
    }, e.prototype.on = function (a, b, c, d) {
      a.addEventListener ? a.addEventListener(b, c, d) : a.attachEvent && a.attachEvent("on" + b, c);
    }, e.prototype.off = function (a, b, c, d) {
      a.removeEventListener ? a.removeEventListener(b, c, d) : a.detachEvent && a.detachEvent("on" + b, c);
    }, e.prototype.trigger = function (b, c, d, f, g) {
      var h = {
        item: {
          count: this._items.length,
          index: this.current()
        }
      },
          i = a.camelCase(a.grep(["on", b, d], function (a) {
        return a;
      }).join("-").toLowerCase()),
          j = a.Event([b, "owl", d || "carousel"].join(".").toLowerCase(), a.extend({
        relatedTarget: this
      }, h, c));
      return this._supress[b] || (a.each(this._plugins, function (a, b) {
        b.onTrigger && b.onTrigger(j);
      }), this.register({
        type: e.Type.Event,
        name: b
      }), this.$element.trigger(j), this.settings && "function" == typeof this.settings[i] && this.settings[i].call(this, j)), j;
    }, e.prototype.enter = function (b) {
      a.each([b].concat(this._states.tags[b] || []), a.proxy(function (a, b) {
        this._states.current[b] === d && (this._states.current[b] = 0), this._states.current[b]++;
      }, this));
    }, e.prototype.leave = function (b) {
      a.each([b].concat(this._states.tags[b] || []), a.proxy(function (a, b) {
        this._states.current[b]--;
      }, this));
    }, e.prototype.register = function (b) {
      if (b.type === e.Type.Event) {
        if (a.event.special[b.name] || (a.event.special[b.name] = {}), !a.event.special[b.name].owl) {
          var c = a.event.special[b.name]._default;
          a.event.special[b.name]._default = function (a) {
            return !c || !c.apply || a.namespace && -1 !== a.namespace.indexOf("owl") ? a.namespace && a.namespace.indexOf("owl") > -1 : c.apply(this, arguments);
          }, a.event.special[b.name].owl = !0;
        }
      } else b.type === e.Type.State && (this._states.tags[b.name] ? this._states.tags[b.name] = this._states.tags[b.name].concat(b.tags) : this._states.tags[b.name] = b.tags, this._states.tags[b.name] = a.grep(this._states.tags[b.name], a.proxy(function (c, d) {
        return a.inArray(c, this._states.tags[b.name]) === d;
      }, this)));
    }, e.prototype.suppress = function (b) {
      a.each(b, a.proxy(function (a, b) {
        this._supress[b] = !0;
      }, this));
    }, e.prototype.release = function (b) {
      a.each(b, a.proxy(function (a, b) {
        delete this._supress[b];
      }, this));
    }, e.prototype.pointer = function (a) {
      var c = {
        x: null,
        y: null
      };
      return a = a.originalEvent || a || b.event, a = a.touches && a.touches.length ? a.touches[0] : a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : a, a.pageX ? (c.x = a.pageX, c.y = a.pageY) : (c.x = a.clientX, c.y = a.clientY), c;
    }, e.prototype.isNumeric = function (a) {
      return !isNaN(parseFloat(a));
    }, e.prototype.difference = function (a, b) {
      return {
        x: a.x - b.x,
        y: a.y - b.y
      };
    }, a.fn.owlCarousel = function (b) {
      var c = Array.prototype.slice.call(arguments, 1);
      return this.each(function () {
        var d = a(this),
            f = d.data("owl.carousel");
        f || (f = new e(this, "object" == typeof b && b), d.data("owl.carousel", f), a.each(["next", "prev", "to", "destroy", "refresh", "replace", "add", "remove"], function (b, c) {
          f.register({
            type: e.Type.Event,
            name: c
          }), f.$element.on(c + ".owl.carousel.core", a.proxy(function (a) {
            a.namespace && a.relatedTarget !== this && (this.suppress([c]), f[c].apply(this, [].slice.call(arguments, 1)), this.release([c]));
          }, f));
        })), "string" == typeof b && "_" !== b.charAt(0) && f[b].apply(f, c);
      });
    }, a.fn.owlCarousel.Constructor = e;
  }(window.Zepto || window.jQuery, window, document), function (a, b, c, d) {
    var e = function (b) {
      this._core = b, this._interval = null, this._visible = null, this._handlers = {
        "initialized.owl.carousel": a.proxy(function (a) {
          a.namespace && this._core.settings.autoRefresh && this.watch();
        }, this)
      }, this._core.options = a.extend({}, e.Defaults, this._core.options), this._core.$element.on(this._handlers);
    };

    e.Defaults = {
      autoRefresh: !0,
      autoRefreshInterval: 500
    }, e.prototype.watch = function () {
      this._interval || (this._visible = this._core.isVisible(), this._interval = b.setInterval(a.proxy(this.refresh, this), this._core.settings.autoRefreshInterval));
    }, e.prototype.refresh = function () {
      this._core.isVisible() !== this._visible && (this._visible = !this._visible, this._core.$element.toggleClass("owl-hidden", !this._visible), this._visible && this._core.invalidate("width") && this._core.refresh());
    }, e.prototype.destroy = function () {
      var a, c;
      b.clearInterval(this._interval);

      for (a in this._handlers) this._core.$element.off(a, this._handlers[a]);

      for (c in Object.getOwnPropertyNames(this)) "function" != typeof this[c] && (this[c] = null);
    }, a.fn.owlCarousel.Constructor.Plugins.AutoRefresh = e;
  }(window.Zepto || window.jQuery, window, document), function (a, b, c, d) {
    var e = function (b) {
      this._core = b, this._loaded = [], this._handlers = {
        "initialized.owl.carousel change.owl.carousel resized.owl.carousel": a.proxy(function (b) {
          if (b.namespace && this._core.settings && this._core.settings.lazyLoad && (b.property && "position" == b.property.name || "initialized" == b.type)) {
            var c = this._core.settings,
                e = c.center && Math.ceil(c.items / 2) || c.items,
                f = c.center && -1 * e || 0,
                g = (b.property && b.property.value !== d ? b.property.value : this._core.current()) + f,
                h = this._core.clones().length,
                i = a.proxy(function (a, b) {
              this.load(b);
            }, this);

            for (c.lazyLoadEager > 0 && (e += c.lazyLoadEager, c.loop && (g -= c.lazyLoadEager, e++)); f++ < e;) this.load(h / 2 + this._core.relative(g)), h && a.each(this._core.clones(this._core.relative(g)), i), g++;
          }
        }, this)
      }, this._core.options = a.extend({}, e.Defaults, this._core.options), this._core.$element.on(this._handlers);
    };

    e.Defaults = {
      lazyLoad: !1,
      lazyLoadEager: 0
    }, e.prototype.load = function (c) {
      var d = this._core.$stage.children().eq(c),
          e = d && d.find(".owl-lazy");

      !e || a.inArray(d.get(0), this._loaded) > -1 || (e.each(a.proxy(function (c, d) {
        var e,
            f = a(d),
            g = b.devicePixelRatio > 1 && f.attr("data-src-retina") || f.attr("data-src") || f.attr("data-srcset");
        this._core.trigger("load", {
          element: f,
          url: g
        }, "lazy"), f.is("img") ? f.one("load.owl.lazy", a.proxy(function () {
          f.css("opacity", 1), this._core.trigger("loaded", {
            element: f,
            url: g
          }, "lazy");
        }, this)).attr("src", g) : f.is("source") ? f.one("load.owl.lazy", a.proxy(function () {
          this._core.trigger("loaded", {
            element: f,
            url: g
          }, "lazy");
        }, this)).attr("srcset", g) : (e = new Image(), e.onload = a.proxy(function () {
          f.css({
            "background-image": 'url("' + g + '")',
            opacity: "1"
          }), this._core.trigger("loaded", {
            element: f,
            url: g
          }, "lazy");
        }, this), e.src = g);
      }, this)), this._loaded.push(d.get(0)));
    }, e.prototype.destroy = function () {
      var a, b;

      for (a in this.handlers) this._core.$element.off(a, this.handlers[a]);

      for (b in Object.getOwnPropertyNames(this)) "function" != typeof this[b] && (this[b] = null);
    }, a.fn.owlCarousel.Constructor.Plugins.Lazy = e;
  }(window.Zepto || window.jQuery, window, document), function (a, b, c, d) {
    var e = function (c) {
      this._core = c, this._previousHeight = null, this._handlers = {
        "initialized.owl.carousel refreshed.owl.carousel": a.proxy(function (a) {
          a.namespace && this._core.settings.autoHeight && this.update();
        }, this),
        "changed.owl.carousel": a.proxy(function (a) {
          a.namespace && this._core.settings.autoHeight && "position" === a.property.name && this.update();
        }, this),
        "loaded.owl.lazy": a.proxy(function (a) {
          a.namespace && this._core.settings.autoHeight && a.element.closest("." + this._core.settings.itemClass).index() === this._core.current() && this.update();
        }, this)
      }, this._core.options = a.extend({}, e.Defaults, this._core.options), this._core.$element.on(this._handlers), this._intervalId = null;
      var d = this;
      a(b).on("load", function () {
        d._core.settings.autoHeight && d.update();
      }), a(b).resize(function () {
        d._core.settings.autoHeight && (null != d._intervalId && clearTimeout(d._intervalId), d._intervalId = setTimeout(function () {
          d.update();
        }, 250));
      });
    };

    e.Defaults = {
      autoHeight: !1,
      autoHeightClass: "owl-height"
    }, e.prototype.update = function () {
      var b = this._core._current,
          c = b + this._core.settings.items,
          d = this._core.settings.lazyLoad,
          e = this._core.$stage.children().toArray().slice(b, c),
          f = [],
          g = 0;

      a.each(e, function (b, c) {
        f.push(a(c).height());
      }), g = Math.max.apply(null, f), g <= 1 && d && this._previousHeight && (g = this._previousHeight), this._previousHeight = g, this._core.$stage.parent().height(g).addClass(this._core.settings.autoHeightClass);
    }, e.prototype.destroy = function () {
      var a, b;

      for (a in this._handlers) this._core.$element.off(a, this._handlers[a]);

      for (b in Object.getOwnPropertyNames(this)) "function" != typeof this[b] && (this[b] = null);
    }, a.fn.owlCarousel.Constructor.Plugins.AutoHeight = e;
  }(window.Zepto || window.jQuery, window, document), function (a, b, c, d) {
    var e = function (b) {
      this._core = b, this._videos = {}, this._playing = null, this._handlers = {
        "initialized.owl.carousel": a.proxy(function (a) {
          a.namespace && this._core.register({
            type: "state",
            name: "playing",
            tags: ["interacting"]
          });
        }, this),
        "resize.owl.carousel": a.proxy(function (a) {
          a.namespace && this._core.settings.video && this.isInFullScreen() && a.preventDefault();
        }, this),
        "refreshed.owl.carousel": a.proxy(function (a) {
          a.namespace && this._core.is("resizing") && this._core.$stage.find(".cloned .owl-video-frame").remove();
        }, this),
        "changed.owl.carousel": a.proxy(function (a) {
          a.namespace && "position" === a.property.name && this._playing && this.stop();
        }, this),
        "prepared.owl.carousel": a.proxy(function (b) {
          if (b.namespace) {
            var c = a(b.content).find(".owl-video");
            c.length && (c.css("display", "none"), this.fetch(c, a(b.content)));
          }
        }, this)
      }, this._core.options = a.extend({}, e.Defaults, this._core.options), this._core.$element.on(this._handlers), this._core.$element.on("click.owl.video", ".owl-video-play-icon", a.proxy(function (a) {
        this.play(a);
      }, this));
    };

    e.Defaults = {
      video: !1,
      videoHeight: !1,
      videoWidth: !1
    }, e.prototype.fetch = function (a, b) {
      var c = function () {
        return a.attr("data-vimeo-id") ? "vimeo" : a.attr("data-vzaar-id") ? "vzaar" : "youtube";
      }(),
          d = a.attr("data-vimeo-id") || a.attr("data-youtube-id") || a.attr("data-vzaar-id"),
          e = a.attr("data-width") || this._core.settings.videoWidth,
          f = a.attr("data-height") || this._core.settings.videoHeight,
          g = a.attr("href");

      if (!g) throw new Error("Missing video URL.");
      if (d = g.match(/(http:|https:|)\/\/(player.|www.|app.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com|be\-nocookie\.com)|vzaar\.com)\/(video\/|videos\/|embed\/|channels\/.+\/|groups\/.+\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/), d[3].indexOf("youtu") > -1) c = "youtube";else if (d[3].indexOf("vimeo") > -1) c = "vimeo";else {
        if (!(d[3].indexOf("vzaar") > -1)) throw new Error("Video URL not supported.");
        c = "vzaar";
      }
      d = d[6], this._videos[g] = {
        type: c,
        id: d,
        width: e,
        height: f
      }, b.attr("data-video", g), this.thumbnail(a, this._videos[g]);
    }, e.prototype.thumbnail = function (b, c) {
      var d,
          e,
          f,
          g = c.width && c.height ? "width:" + c.width + "px;height:" + c.height + "px;" : "",
          h = b.find("img"),
          i = "src",
          j = "",
          k = this._core.settings,
          l = function (c) {
        e = '<div class="owl-video-play-icon"></div>', d = k.lazyLoad ? a("<div/>", {
          class: "owl-video-tn " + j,
          srcType: c
        }) : a("<div/>", {
          class: "owl-video-tn",
          style: "opacity:1;background-image:url(" + c + ")"
        }), b.after(d), b.after(e);
      };

      if (b.wrap(a("<div/>", {
        class: "owl-video-wrapper",
        style: g
      })), this._core.settings.lazyLoad && (i = "data-src", j = "owl-lazy"), h.length) return l(h.attr(i)), h.remove(), !1;
      "youtube" === c.type ? (f = "//img.youtube.com/vi/" + c.id + "/hqdefault.jpg", l(f)) : "vimeo" === c.type ? a.ajax({
        type: "GET",
        url: "//vimeo.com/api/v2/video/" + c.id + ".json",
        jsonp: "callback",
        dataType: "jsonp",
        success: function (a) {
          f = a[0].thumbnail_large, l(f);
        }
      }) : "vzaar" === c.type && a.ajax({
        type: "GET",
        url: "//vzaar.com/api/videos/" + c.id + ".json",
        jsonp: "callback",
        dataType: "jsonp",
        success: function (a) {
          f = a.framegrab_url, l(f);
        }
      });
    }, e.prototype.stop = function () {
      this._core.trigger("stop", null, "video"), this._playing.find(".owl-video-frame").remove(), this._playing.removeClass("owl-video-playing"), this._playing = null, this._core.leave("playing"), this._core.trigger("stopped", null, "video");
    }, e.prototype.play = function (b) {
      var c,
          d = a(b.target),
          e = d.closest("." + this._core.settings.itemClass),
          f = this._videos[e.attr("data-video")],
          g = f.width || "100%",
          h = f.height || this._core.$stage.height();

      this._playing || (this._core.enter("playing"), this._core.trigger("play", null, "video"), e = this._core.items(this._core.relative(e.index())), this._core.reset(e.index()), c = a('<iframe frameborder="0" allowfullscreen mozallowfullscreen webkitAllowFullScreen ></iframe>'), c.attr("height", h), c.attr("width", g), "youtube" === f.type ? c.attr("src", "//www.youtube.com/embed/" + f.id + "?autoplay=1&rel=0&v=" + f.id) : "vimeo" === f.type ? c.attr("src", "//player.vimeo.com/video/" + f.id + "?autoplay=1") : "vzaar" === f.type && c.attr("src", "//view.vzaar.com/" + f.id + "/player?autoplay=true"), a(c).wrap('<div class="owl-video-frame" />').insertAfter(e.find(".owl-video")), this._playing = e.addClass("owl-video-playing"));
    }, e.prototype.isInFullScreen = function () {
      var b = c.fullscreenElement || c.mozFullScreenElement || c.webkitFullscreenElement;
      return b && a(b).parent().hasClass("owl-video-frame");
    }, e.prototype.destroy = function () {
      var a, b;

      this._core.$element.off("click.owl.video");

      for (a in this._handlers) this._core.$element.off(a, this._handlers[a]);

      for (b in Object.getOwnPropertyNames(this)) "function" != typeof this[b] && (this[b] = null);
    }, a.fn.owlCarousel.Constructor.Plugins.Video = e;
  }(window.Zepto || window.jQuery, window, document), function (a, b, c, d) {
    var e = function (b) {
      this.core = b, this.core.options = a.extend({}, e.Defaults, this.core.options), this.swapping = !0, this.previous = d, this.next = d, this.handlers = {
        "change.owl.carousel": a.proxy(function (a) {
          a.namespace && "position" == a.property.name && (this.previous = this.core.current(), this.next = a.property.value);
        }, this),
        "drag.owl.carousel dragged.owl.carousel translated.owl.carousel": a.proxy(function (a) {
          a.namespace && (this.swapping = "translated" == a.type);
        }, this),
        "translate.owl.carousel": a.proxy(function (a) {
          a.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn) && this.swap();
        }, this)
      }, this.core.$element.on(this.handlers);
    };

    e.Defaults = {
      animateOut: !1,
      animateIn: !1
    }, e.prototype.swap = function () {
      if (1 === this.core.settings.items && a.support.animation && a.support.transition) {
        this.core.speed(0);
        var b,
            c = a.proxy(this.clear, this),
            d = this.core.$stage.children().eq(this.previous),
            e = this.core.$stage.children().eq(this.next),
            f = this.core.settings.animateIn,
            g = this.core.settings.animateOut;
        this.core.current() !== this.previous && (g && (b = this.core.coordinates(this.previous) - this.core.coordinates(this.next), d.one(a.support.animation.end, c).css({
          left: b + "px"
        }).addClass("animated owl-animated-out").addClass(g)), f && e.one(a.support.animation.end, c).addClass("animated owl-animated-in").addClass(f));
      }
    }, e.prototype.clear = function (b) {
      a(b.target).css({
        left: ""
      }).removeClass("animated owl-animated-out owl-animated-in").removeClass(this.core.settings.animateIn).removeClass(this.core.settings.animateOut), this.core.onTransitionEnd();
    }, e.prototype.destroy = function () {
      var a, b;

      for (a in this.handlers) this.core.$element.off(a, this.handlers[a]);

      for (b in Object.getOwnPropertyNames(this)) "function" != typeof this[b] && (this[b] = null);
    }, a.fn.owlCarousel.Constructor.Plugins.Animate = e;
  }(window.Zepto || window.jQuery, window, document), function (a, b, c, d) {
    var e = function (b) {
      this._core = b, this._call = null, this._time = 0, this._timeout = 0, this._paused = !0, this._handlers = {
        "changed.owl.carousel": a.proxy(function (a) {
          a.namespace && "settings" === a.property.name ? this._core.settings.autoplay ? this.play() : this.stop() : a.namespace && "position" === a.property.name && this._paused && (this._time = 0);
        }, this),
        "initialized.owl.carousel": a.proxy(function (a) {
          a.namespace && this._core.settings.autoplay && this.play();
        }, this),
        "play.owl.autoplay": a.proxy(function (a, b, c) {
          a.namespace && this.play(b, c);
        }, this),
        "stop.owl.autoplay": a.proxy(function (a) {
          a.namespace && this.stop();
        }, this),
        "mouseover.owl.autoplay": a.proxy(function () {
          this._core.settings.autoplayHoverPause && this._core.is("rotating") && this.pause();
        }, this),
        "mouseleave.owl.autoplay": a.proxy(function () {
          this._core.settings.autoplayHoverPause && this._core.is("rotating") && this.play();
        }, this),
        "touchstart.owl.core": a.proxy(function () {
          this._core.settings.autoplayHoverPause && this._core.is("rotating") && this.pause();
        }, this),
        "touchend.owl.core": a.proxy(function () {
          this._core.settings.autoplayHoverPause && this.play();
        }, this)
      }, this._core.$element.on(this._handlers), this._core.options = a.extend({}, e.Defaults, this._core.options);
    };

    e.Defaults = {
      autoplay: !1,
      autoplayTimeout: 5e3,
      autoplayHoverPause: !1,
      autoplaySpeed: !1
    }, e.prototype._next = function (d) {
      this._call = b.setTimeout(a.proxy(this._next, this, d), this._timeout * (Math.round(this.read() / this._timeout) + 1) - this.read()), this._core.is("interacting") || c.hidden || this._core.next(d || this._core.settings.autoplaySpeed);
    }, e.prototype.read = function () {
      return new Date().getTime() - this._time;
    }, e.prototype.play = function (c, d) {
      var e;
      this._core.is("rotating") || this._core.enter("rotating"), c = c || this._core.settings.autoplayTimeout, e = Math.min(this._time % (this._timeout || c), c), this._paused ? (this._time = this.read(), this._paused = !1) : b.clearTimeout(this._call), this._time += this.read() % c - e, this._timeout = c, this._call = b.setTimeout(a.proxy(this._next, this, d), c - e);
    }, e.prototype.stop = function () {
      this._core.is("rotating") && (this._time = 0, this._paused = !0, b.clearTimeout(this._call), this._core.leave("rotating"));
    }, e.prototype.pause = function () {
      this._core.is("rotating") && !this._paused && (this._time = this.read(), this._paused = !0, b.clearTimeout(this._call));
    }, e.prototype.destroy = function () {
      var a, b;
      this.stop();

      for (a in this._handlers) this._core.$element.off(a, this._handlers[a]);

      for (b in Object.getOwnPropertyNames(this)) "function" != typeof this[b] && (this[b] = null);
    }, a.fn.owlCarousel.Constructor.Plugins.autoplay = e;
  }(window.Zepto || window.jQuery, window, document), function (a, b, c, d) {

    var e = function (b) {
      this._core = b, this._initialized = !1, this._pages = [], this._controls = {}, this._templates = [], this.$element = this._core.$element, this._overrides = {
        next: this._core.next,
        prev: this._core.prev,
        to: this._core.to
      }, this._handlers = {
        "prepared.owl.carousel": a.proxy(function (b) {
          b.namespace && this._core.settings.dotsData && this._templates.push('<div class="' + this._core.settings.dotClass + '">' + a(b.content).find("[data-dot]").addBack("[data-dot]").attr("data-dot") + "</div>");
        }, this),
        "added.owl.carousel": a.proxy(function (a) {
          a.namespace && this._core.settings.dotsData && this._templates.splice(a.position, 0, this._templates.pop());
        }, this),
        "remove.owl.carousel": a.proxy(function (a) {
          a.namespace && this._core.settings.dotsData && this._templates.splice(a.position, 1);
        }, this),
        "changed.owl.carousel": a.proxy(function (a) {
          a.namespace && "position" == a.property.name && this.draw();
        }, this),
        "initialized.owl.carousel": a.proxy(function (a) {
          a.namespace && !this._initialized && (this._core.trigger("initialize", null, "navigation"), this.initialize(), this.update(), this.draw(), this._initialized = !0, this._core.trigger("initialized", null, "navigation"));
        }, this),
        "refreshed.owl.carousel": a.proxy(function (a) {
          a.namespace && this._initialized && (this._core.trigger("refresh", null, "navigation"), this.update(), this.draw(), this._core.trigger("refreshed", null, "navigation"));
        }, this)
      }, this._core.options = a.extend({}, e.Defaults, this._core.options), this.$element.on(this._handlers);
    };

    e.Defaults = {
      nav: !1,
      navText: ['<span aria-label="Previous">&#x2039;</span>', '<span aria-label="Next">&#x203a;</span>'],
      navSpeed: !1,
      navElement: 'button type="button" role="presentation"',
      navContainer: !1,
      navContainerClass: "owl-nav",
      navClass: ["owl-prev", "owl-next"],
      slideBy: 1,
      dotClass: "owl-dot",
      dotsClass: "owl-dots",
      dots: !0,
      dotsEach: !1,
      dotsData: !1,
      dotsSpeed: !1,
      dotsContainer: !1
    }, e.prototype.initialize = function () {
      var b,
          c = this._core.settings;
      this._controls.$relative = (c.navContainer ? a(c.navContainer) : a("<div>").addClass(c.navContainerClass).appendTo(this.$element)).addClass("disabled"), this._controls.$previous = a("<" + c.navElement + ">").addClass(c.navClass[0]).html(c.navText[0]).prependTo(this._controls.$relative).on("click", a.proxy(function (a) {
        this.prev(c.navSpeed);
      }, this)), this._controls.$next = a("<" + c.navElement + ">").addClass(c.navClass[1]).html(c.navText[1]).appendTo(this._controls.$relative).on("click", a.proxy(function (a) {
        this.next(c.navSpeed);
      }, this)), c.dotsData || (this._templates = [a('<button role="button">').addClass(c.dotClass).append(a("<span>")).prop("outerHTML")]), this._controls.$absolute = (c.dotsContainer ? a(c.dotsContainer) : a("<div>").addClass(c.dotsClass).appendTo(this.$element)).addClass("disabled"), this._controls.$absolute.on("click", "button", a.proxy(function (b) {
        var d = a(b.target).parent().is(this._controls.$absolute) ? a(b.target).index() : a(b.target).parent().index();
        b.preventDefault(), this.to(d, c.dotsSpeed);
      }, this));

      for (b in this._overrides) this._core[b] = a.proxy(this[b], this);
    }, e.prototype.destroy = function () {
      var a, b, c, d, e;
      e = this._core.settings;

      for (a in this._handlers) this.$element.off(a, this._handlers[a]);

      for (b in this._controls) "$relative" === b && e.navContainer ? this._controls[b].html("") : this._controls[b].remove();

      for (d in this.overides) this._core[d] = this._overrides[d];

      for (c in Object.getOwnPropertyNames(this)) "function" != typeof this[c] && (this[c] = null);
    }, e.prototype.update = function () {
      var a,
          b,
          c,
          d = this._core.clones().length / 2,
          e = d + this._core.items().length,
          f = this._core.maximum(!0),
          g = this._core.settings,
          h = g.center || g.autoWidth || g.dotsData ? 1 : g.dotsEach || g.items;

      if ("page" !== g.slideBy && (g.slideBy = Math.min(g.slideBy, g.items)), g.dots || "page" == g.slideBy) for (this._pages = [], a = d, b = 0, c = 0; a < e; a++) {
        if (b >= h || 0 === b) {
          if (this._pages.push({
            start: Math.min(f, a - d),
            end: a - d + h - 1
          }), Math.min(f, a - d) === f) break;
          b = 0, ++c;
        }

        b += this._core.mergers(this._core.relative(a));
      }
    }, e.prototype.draw = function () {
      var b,
          c = this._core.settings,
          d = this._core.items().length <= c.items,
          e = this._core.relative(this._core.current()),
          f = c.loop || c.rewind;

      this._controls.$relative.toggleClass("disabled", !c.nav || d), c.nav && (this._controls.$previous.toggleClass("disabled", !f && e <= this._core.minimum(!0)), this._controls.$next.toggleClass("disabled", !f && e >= this._core.maximum(!0))), this._controls.$absolute.toggleClass("disabled", !c.dots || d), c.dots && (b = this._pages.length - this._controls.$absolute.children().length, c.dotsData && 0 !== b ? this._controls.$absolute.html(this._templates.join("")) : b > 0 ? this._controls.$absolute.append(new Array(b + 1).join(this._templates[0])) : b < 0 && this._controls.$absolute.children().slice(b).remove(), this._controls.$absolute.find(".active").removeClass("active"), this._controls.$absolute.children().eq(a.inArray(this.current(), this._pages)).addClass("active"));
    }, e.prototype.onTrigger = function (b) {
      var c = this._core.settings;
      b.page = {
        index: a.inArray(this.current(), this._pages),
        count: this._pages.length,
        size: c && (c.center || c.autoWidth || c.dotsData ? 1 : c.dotsEach || c.items)
      };
    }, e.prototype.current = function () {
      var b = this._core.relative(this._core.current());

      return a.grep(this._pages, a.proxy(function (a, c) {
        return a.start <= b && a.end >= b;
      }, this)).pop();
    }, e.prototype.getPosition = function (b) {
      var c,
          d,
          e = this._core.settings;
      return "page" == e.slideBy ? (c = a.inArray(this.current(), this._pages), d = this._pages.length, b ? ++c : --c, c = this._pages[(c % d + d) % d].start) : (c = this._core.relative(this._core.current()), d = this._core.items().length, b ? c += e.slideBy : c -= e.slideBy), c;
    }, e.prototype.next = function (b) {
      a.proxy(this._overrides.to, this._core)(this.getPosition(!0), b);
    }, e.prototype.prev = function (b) {
      a.proxy(this._overrides.to, this._core)(this.getPosition(!1), b);
    }, e.prototype.to = function (b, c, d) {
      var e;
      !d && this._pages.length ? (e = this._pages.length, a.proxy(this._overrides.to, this._core)(this._pages[(b % e + e) % e].start, c)) : a.proxy(this._overrides.to, this._core)(b, c);
    }, a.fn.owlCarousel.Constructor.Plugins.Navigation = e;
  }(window.Zepto || window.jQuery, window, document), function (a, b, c, d) {

    var e = function (c) {
      this._core = c, this._hashes = {}, this.$element = this._core.$element, this._handlers = {
        "initialized.owl.carousel": a.proxy(function (c) {
          c.namespace && "URLHash" === this._core.settings.startPosition && a(b).trigger("hashchange.owl.navigation");
        }, this),
        "prepared.owl.carousel": a.proxy(function (b) {
          if (b.namespace) {
            var c = a(b.content).find("[data-hash]").addBack("[data-hash]").attr("data-hash");
            if (!c) return;
            this._hashes[c] = b.content;
          }
        }, this),
        "changed.owl.carousel": a.proxy(function (c) {
          if (c.namespace && "position" === c.property.name) {
            var d = this._core.items(this._core.relative(this._core.current())),
                e = a.map(this._hashes, function (a, b) {
              return a === d ? b : null;
            }).join();

            if (!e || b.location.hash.slice(1) === e) return;
            b.location.hash = e;
          }
        }, this)
      }, this._core.options = a.extend({}, e.Defaults, this._core.options), this.$element.on(this._handlers), a(b).on("hashchange.owl.navigation", a.proxy(function (a) {
        var c = b.location.hash.substring(1),
            e = this._core.$stage.children(),
            f = this._hashes[c] && e.index(this._hashes[c]);

        f !== d && f !== this._core.current() && this._core.to(this._core.relative(f), !1, !0);
      }, this));
    };

    e.Defaults = {
      URLhashListener: !1
    }, e.prototype.destroy = function () {
      var c, d;
      a(b).off("hashchange.owl.navigation");

      for (c in this._handlers) this._core.$element.off(c, this._handlers[c]);

      for (d in Object.getOwnPropertyNames(this)) "function" != typeof this[d] && (this[d] = null);
    }, a.fn.owlCarousel.Constructor.Plugins.Hash = e;
  }(window.Zepto || window.jQuery, window, document), function (a, b, c, d) {
    function e(b, c) {
      var e = !1,
          f = b.charAt(0).toUpperCase() + b.slice(1);
      return a.each((b + " " + h.join(f + " ") + f).split(" "), function (a, b) {
        if (g[b] !== d) return e = !c || b, !1;
      }), e;
    }

    function f(a) {
      return e(a, !0);
    }

    var g = a("<support>").get(0).style,
        h = "Webkit Moz O ms".split(" "),
        i = {
      transition: {
        end: {
          WebkitTransition: "webkitTransitionEnd",
          MozTransition: "transitionend",
          OTransition: "oTransitionEnd",
          transition: "transitionend"
        }
      },
      animation: {
        end: {
          WebkitAnimation: "webkitAnimationEnd",
          MozAnimation: "animationend",
          OAnimation: "oAnimationEnd",
          animation: "animationend"
        }
      }
    },
        j = {
      csstransforms: function () {
        return !!e("transform");
      },
      csstransforms3d: function () {
        return !!e("perspective");
      },
      csstransitions: function () {
        return !!e("transition");
      },
      cssanimations: function () {
        return !!e("animation");
      }
    };
    j.csstransitions() && (a.support.transition = new String(f("transition")), a.support.transition.end = i.transition.end[a.support.transition]), j.cssanimations() && (a.support.animation = new String(f("animation")), a.support.animation.end = i.animation.end[a.support.animation]), j.csstransforms() && (a.support.transform = new String(f("transform")), a.support.transform3d = j.csstransforms3d());
  }(window.Zepto || window.jQuery, window, document);

  (function () {
    var $body = $('body'),
        $window = $(window),
        $document = $(document),
        isMobile = false; // variable use to determine if responsive mode is on or off

    var toggleTable = {
      vPort: "screen-xs",
      init: function () {
        toggleTable.on.build();
        toggleTable.control();
      },
      control: function () {
        $body.on('click', '.expandable .table__control__button', function (e) {
          e.preventDefault();

          if ($(this).closest('tr').hasClass('js--expanded')) {
            toggleTable.on.hide($(this).closest('tr'));
          } else {
            toggleTable.on.show($(this).closest('tr'));
          }
        });
        $window.on('resize', function () {
          toggleTable.on.build();
        });
        $(document).on(toggleTable.vPort + '-on', function () {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          isMobile = true;
        });
        $(document).on(toggleTable.vPort + '-off', function () {
          // Waiting for custom event that will be triggered by controller.js to deactivate responsive effects
          isMobile = false;
        });
      },
      on: {
        build: function () {
          var $toggle = $('.expandable');
          $toggle.each(function () {
            var $target = $(this).find('tr');
            var to_hide = $target.find('.to_hide');
            $target.removeClass('js--expanded');

            if (isMobile) {
              $(to_hide).hide(0);
            } else {
              $(to_hide).show(0);
            }
          });
        },
        show: function (elem) {
          var $target = elem.find('.to_hide');
          $target.slideDown(200);
          elem.addClass('js--expanded');
        },
        hide: function (elem) {
          var $target = elem.find('.to_hide');
          $target.slideUp(200);
          elem.removeClass('js--expanded');
        }
      }
    };
    UX.toggleTable = toggleTable; // add to global namespace
  })();

  (function () {
    var $body = $('body'),
        $document = $(document);
    var toggle = {
      $toggle: $('.facet:not(.displayAll)'),
      init: function () {
        toggle.on.build();
        toggle.control();
        toggle.additionalControls();
      },
      control: function () {
        $body.on('click', '.facet .show-more', function (e) {
          e.preventDefault();
          toggle.on.toggle($(this));
        });
        $body.find('.facet .dropdown__toggle').off();
        $body.on('click', '.facet .dropdown__toggle', function (e) {
          e.preventDefault();
          toggle.on.toggleFacet($(this));
        });
      },
      additionalControls: function () {},
      on: {
        build: function () {
          toggle.$toggle.each(function () {
            var $target = $(this).find('ul.facet__list');
            var $lis = $target.children('li');
            var $select = $(this).find('.facet__select ');
            var $options = $select.children('option');
            var lisNum = $lis.length;
            var optionsNum = $options.length;
            var isToggle = lisNum > 5;
            var moreCount = optionsNum + lisNum - 5;
            if ($target.find('[name=facet-hidden-items]').length) moreCount = $target.find('[name=facet-hidden-items]').val();
            $target.closest('.facet').attr('data-more-count', moreCount);
            if (isToggle) $target.after(toggle.get.showMore(moreCount));
            $select.each(function () {
              var mis = $(this).magicSuggest({
                hideTrigger: 'true',
                allowFreeEntries: 'false',
                expandOnFocus: true,
                maxSelection: 1,
                placeholder: $(this).data('placeholder')
              });
              $(mis).on('selectionchange', function (e, m, selection) {
                if (selection != undefined) {
                  window.location.href = selection[0].id;
                }
              });
            });
          });
        },
        toggle: function (elem) {
          var $toggle = elem.closest('.facet');
          var $target = $toggle.find('ul.facet__list');
          $target.find('.js--toggle').slideToggle();
          $toggle.find('.facet__select--hidden').toggle();
          elem.toggleClass('js--open');

          if (elem.hasClass('js--open')) {
            elem.html('Less <i class="icon-section_arrow_u" aria-hidden="true"></i>');
            elem.closest(".accordion__content").find('li:nth-child(6) a').focus();
            elem.attr('aria-expanded', true);
          } else {
            elem.html('More <span  class="more-count">(' + $toggle.data('more-count') + ')</span> <i class="icon-section_arrow_d" aria-hidden="true"></i>');
            elem.closest(".accordion__content").find('li:first-child a').blur();
            elem.attr('aria-expanded', false);
          }
        },
        toggleFacet: function (elem) {
          var $toggle = elem.closest('li');
          var $target = $toggle.children('ul.facet-dropdown__menu');
          $target.slideToggle();
          elem.toggleClass('js--open');
          elem.find('i').toggleClass('icon-add_box icon-squared-minus');

          if (elem.hasClass('js--open')) {
            $target.attr('aria-hidden', false);
          } else {
            $target.attr('aria-hidden', true);
          }
        }
      },
      get: {
        /**
         * gets the show more/less link.
         * was added to make it easier for engineer to override it's value
         *
         * @param count
         * @returns {string}
         */
        showMore(count) {
          return `<a href="#" class="show-more" aria-expanded="false">More <span class="more-count">${count}</span> <i class="icon-section_arrow_d" aria-hidden="true"></i></a>`;
        }

      }
    };
    UX.toggle = toggle; // add to global namespace
  })();

  (function () {
    var $body = $('body');
    var $document = $(document);
    var facetDate = {
      sliderRanges: [],
      sliderValues: [],
      $rangeStart: $('.range-slider__start'),
      $rangeEnd: $('.range-slider__end'),
      url: location.href,
      init: function () {
        facetDate.$rangeStart = $('.range-slider__start');
        facetDate.$rangeEnd = $('.range-slider__end');
        facetDate.initRange();
        facetDate.control();
      },
      initRange: function () {
        $('.range-slider').each(function () {
          var $sliderRange = $(this).find('.range-slider__range');

          if (!$sliderRange.hasClass("jcf-hidden")) {
            var frequencies = $sliderRange.data('frequencies');
            var nonLinearSliderSteps = [1, 2, 5, 10];
            var allowedTotalYears = nonLinearSliderSteps.reduce(function (prev, cur) {
              return prev + cur;
            }) * 2;
            var maxVal = parseInt($sliderRange.attr('max'), 10);
            var minVal = parseInt($sliderRange.attr('min'), 10);
            var totalYears = maxVal - minVal;
            var linearSlider = $sliderRange.attr('data-slider-type') === 'linear';

            if (totalYears > allowedTotalYears && !linearSlider) {
              // non-linear slider
              var displaySteps = nonLinearSliderSteps.slice().reverse();
              var remaining = totalYears;
              var startYear = minVal;
              var startSlice = 0;
              displaySteps.forEach(function (step, i, all) {
                var oneThird = Math.floor(remaining / 3);
                var twoThirds = Math.floor(2 * oneThird);
                var remainder = twoThirds % step;

                if (remainder > 0) {
                  twoThirds = twoThirds - remainder;
                }

                remaining = remaining - twoThirds;

                if (i == displaySteps.length - 1) {
                  facetDate.sliderRanges.push({
                    'start': startYear,
                    'stop': maxVal,
                    'displayStep': nonLinearSliderSteps[i],
                    'slideStep': step,
                    'freq': frequencies.slice(startSlice, frequencies.length)
                  });
                } else {
                  facetDate.sliderRanges.push({
                    'start': startYear,
                    'stop': startYear + twoThirds,
                    'displayStep': nonLinearSliderSteps[i],
                    'slideStep': step,
                    'freq': frequencies.slice(startSlice, startSlice + twoThirds)
                  });
                }

                startSlice = startSlice + twoThirds;
                startYear = startYear + twoThirds;
              });
              facetDate.sliderRanges.forEach(function (range) {
                var sliderVal = range.start;

                while (sliderVal <= range.stop) {
                  if (facetDate.sliderValues.indexOf(sliderVal) < 0) {
                    facetDate.sliderValues.push(sliderVal);
                  }

                  sliderVal += range.slideStep;
                }
              });
            } else {
              // linear slider
              if (!facetDate.sliderValues.length > 0) {
                for (var i = minVal; i <= maxVal; i++) {
                  facetDate.sliderValues.push(i);
                }
              }
            }

            $sliderRange.attr('min', 0);
            $sliderRange.attr('max', facetDate.sliderValues.length - 1);
            var initialValue = facetDate.getSelectedRange($sliderRange);
            facetDate.$rangeStart.val(initialValue[0]);
            facetDate.$rangeEnd.val(initialValue[1]);
            var initialPosition = facetDate.getSelectedRangePosition(initialValue[0], initialValue[1]);
            $sliderRange.attr('value', initialPosition.join(','));
            jcf.replace($sliderRange); // render frequencies

            if (frequencies) {
              var $rangeWrapper = $(this).find('.jcf-range-wrapper');
              var $rangeFrequencies = $('<span class="jcf-range-frequencies"></span>');

              if (totalYears > allowedTotalYears && !linearSlider) {
                // non-linear slider
                facetDate.sliderRanges.forEach(function (range) {
                  for (var i = 0; i < range.freq.length; i++) {
                    var $rangeSlice = $('<span class="jcf-range-frequencies__slice" style="width: ' + 100 / range.freq.length / facetDate.sliderRanges.length + '%; opacity: ' + range.freq[i] + '"></span>');
                    $rangeFrequencies.append($rangeSlice);
                  }
                });
                $rangeWrapper.prepend($rangeFrequencies);
              } else {
                // linear slider
                var rangeSliceWidth = 100 / frequencies.length;

                for (var i = 0; i < frequencies.length; i++) {
                  var $rangeSlice = $('<span class="jcf-range-frequencies__slice" style="width: ' + rangeSliceWidth + '%; opacity: ' + frequencies[i] + '"></span>');
                  $rangeFrequencies.append($rangeSlice);
                }

                $rangeWrapper.prepend($rangeFrequencies);
              }
            }
          }
        });
      },
      control: function () {
        $body.on('click', '.custom-date', function (e) {
          e.preventDefault();
          facetDate.on.toggle($(this));
        });
        $(document).on("UX-attach", function () {
          facetDate.init();
        });
        $(document).on("UX-detach", function () {
          jcf.destroy($(".range-slider__range"));
        });
        $('.range-slider__range').change(function () {
          facetDate.on.setRange($(this));
        });
        facetDate.$rangeStart.on('change', function () {
          facetDate.on.setStart($(this));
        });
        facetDate.$rangeEnd.on('change', function () {
          facetDate.on.setEnd($(this));
        });
        $('.range-slider__range').on('change change:startend', function () {
          facetDate.updateUrl($(this));
        });
      },
      on: {
        toggle: function (elem) {
          var $toggle = elem.closest('.facet');
          var $target = $toggle.find('.custom-date-form').slideToggle();
          elem.toggleClass('js--open');
        },
        setRange: function (elem) {
          var $toggle = elem.closest('.range-slider');
          var $target = $toggle.find('.jcf-active-handle');
          var tmp = $target.attr("class").match(/jcf-index[\w-]*\b/);
          var tmp2 = tmp.toString().split('-')[2];
          $('input.index-' + tmp2).val(facetDate.getValue(elem));
        },
        setStart: function (elem) {
          var $sliderRange = elem.closest('.range-slider').find('.range-slider__range');
          var minVal = parseInt($sliderRange.attr('min'), 10);
          var thisVal = facetDate.getValueFromInput(elem);
          var sliderInstance = jcf.getInstance($sliderRange);

          if (thisVal >= minVal && thisVal <= sliderInstance.values[1]) {
            sliderInstance.values[0] = thisVal.toString();
            sliderInstance.refresh();
            $sliderRange.trigger('change:startend');
          }
        },
        setEnd: function (elem) {
          var $sliderRange = elem.closest('.range-slider').find('.range-slider__range');
          var maxVal = parseInt($sliderRange.attr('max'), 10);
          var thisVal = facetDate.getValueFromInput(elem);
          var sliderInstance = jcf.getInstance($sliderRange);

          if (thisVal <= maxVal && thisVal >= sliderInstance.values[0]) {
            sliderInstance.values[1] = thisVal.toString();
            sliderInstance.refresh();
            $sliderRange.trigger('change:startend');
          }
        },
        rangeUpdate: function (elem, callbackFn) {
          var $sliderRange = $(elem);
          $sliderRange.on('change change:startend', function () {
            callbackFn(facetDate.$rangeStart.val(), facetDate.$rangeEnd.val());
          });
        }
      },
      getValue: function (elem) {
        var $sliderRange = elem.closest('.range-slider').find('.range-slider__range');
        var thisValIndex = parseInt(elem.val(), 10);
        var thisVal = facetDate.sliderValues[thisValIndex];
        return thisVal;
      },
      getValueFromInput: function (elem) {
        var $sliderRange = elem.closest('.range-slider').find('.range-slider__range');
        var customVal = parseInt(elem.val(), 10);
        var minVal = parseInt($sliderRange.attr('data-min'), 10);
        var maxVal = parseInt($sliderRange.attr('data-max'), 10);
        var thisVal;

        if (customVal <= maxVal && customVal >= minVal) {
          if (facetDate.sliderValues.indexOf(customVal) >= 0) {
            thisVal = facetDate.sliderValues.indexOf(customVal);
          } else {
            var closest = facetDate.sliderValues.reduce(function (prev, curr) {
              return Math.abs(curr - customVal) < Math.abs(prev - customVal) ? curr : prev;
            });
            thisVal = facetDate.sliderValues.indexOf(closest);
          }
        }

        return thisVal;
      },
      removeParam: function (key) {
        var baseUrl = facetDate.url.split('?')[0];
        var queryString = facetDate.url.indexOf('?') !== -1 ? facetDate.url.split('?')[1] : '';
        var queryStringObj = {};

        if (queryString) {
          queryString.split('&').map(function (value) {
            var keyVal = value.split('=');
            queryStringObj[keyVal[0]] = keyVal[1];
          });

          if (queryStringObj[key]) {
            delete queryStringObj[key];
          }

          queryString = Object.keys(queryStringObj).map(function (value) {
            return value + '=' + queryStringObj[value];
          }).join('&');
          facetDate.url = baseUrl + (queryString ? '?' + queryString : '');
        }
      },
      getSelectedRange: function (sliderRange) {
        var baseUrl = facetDate.url.split('?')[0];
        var queryString = facetDate.url.indexOf('?') !== -1 ? facetDate.url.split('?')[1] : '';
        var queryStringObj = {};

        if (queryString) {
          queryString.split('&').map(function (value) {
            var keyVal = value.split('=');
            queryStringObj[keyVal[0]] = keyVal[1];
          });

          if (queryStringObj.AfterYear && queryStringObj.BeforeYear) {
            return [queryStringObj.AfterYear, queryStringObj.BeforeYear];
          }
        }

        return [parseInt(sliderRange.attr('data-min'), 10), parseInt(sliderRange.attr('data-max'), 10)];
      },
      getSelectedRangePosition: function (start, end) {
        var closestStart;
        var closestEnd;

        if (facetDate.sliderValues.indexOf(start) < 0) {
          closestStart = facetDate.sliderValues.reduce(function (prev, curr) {
            return Math.abs(curr - start) < Math.abs(prev - start) ? curr : prev;
          });
        }

        if (facetDate.sliderValues.indexOf(end) < 0) {
          closestEnd = facetDate.sliderValues.reduce(function (prev, curr) {
            return Math.abs(curr - end) < Math.abs(prev - end) ? curr : prev;
          });
        }

        return [facetDate.sliderValues.indexOf(closestStart || start), facetDate.sliderValues.indexOf(closestEnd || end)];
      },
      updateUrl: function (elem) {
        facetDate.removeParam('AfterYear');
        facetDate.removeParam('BeforeYear');
        facetDate.removeParam('queryID');
        facetDate.url += (facetDate.url.indexOf('?') > -1 ? '&' : '?') + 'AfterYear=' + facetDate.$rangeStart.val() + '&BeforeYear=' + facetDate.$rangeEnd.val() + '&queryID=' + $(elem).attr('data-queryID');
        window.location = facetDate.url;
      }
    };
    UX.facetDate = facetDate; // add to global namespace
  })();

  (function () {
    var $body = $('body'),
        isMobile = false;
    var accordion = {
      $elements: $('.accordion'),
      $tabbedElements: $('.accordion-tabbed'),
      $controllers: $('.accordion__control'),
      //@todo: remove ambiguous DOM searches for elements that are unused and move other into init function
      $tabbedControllers: $('.accordion-tabbed__control'),
      isMobile: false,
      isStickyBody: false,
      vPort: "screen-sm",
      $responsiveElements: $('[data-accordion-vport]'),
      accVport: [],
      $responsiveTarget: [],
      collapseTabs: false,
      collapseAccordion: true,
      // collapse accordion on open new accordion
      defaultCollapsed: true,
      // collapse accordion on pageload
      hideAllBoolean: true,
      openedAccordion: 0,
      init: function () {
        accordion.initResponsive();
        accordion.logic($('.accordion-tabbed')); // collapse all accordions on page load

        accordion.control();
        accordion.additionalControls();
      },
      additionalControls: function () {},
      control: function () {
        $body.on('click', '.accordion__control', function (e) {
          e.stopImmediatePropagation();
          var attr = $(this).is('[data-slide-target]'); // Check if its external link or if its slide controll and mobile view port

          if ($(this).hasClass("external") || typeof attr !== typeof undefined && attr !== false && isMobile) {
            return; // do nothing
          } else {
            e.preventDefault();
            var $this = $(this);
            accordion.on.toggle.single($this);
          }

          $(this).trigger('accordion:controlClick');
        });
        $body.on('click', '.accordion-tabbed__control', function (e) {
          var attr = $(this).is('[data-slide-target]'); // Check if its external link or if its slide controll and mobile view port or prevent accordion behavior

          if ($(this).hasClass("external") || typeof attr !== typeof undefined && attr !== false && isMobile || accordion.preventAccordionBehavior($(this))) {
            return; // do nothing
          } else {
            e.preventDefault();
            var $this = $(this);
            accordion.on.toggle.tabbed($this);
          }
        });
        $body.on('click', '.expand-all', function (e) {
          e.preventDefault();
          var $this = $(this);
          accordion.on.toggle.all($this);
        });
        $(document).on(accordion.vPort + '-on', function () {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          isMobile = true;
        });
        $(document).on(accordion.vPort + '-off', function () {
          // Waiting for custom event that will be triggered by controller.js to deactivate responsive effects
          isMobile = false;
        });
      },
      logic: function (elem) {
        if (accordion.hideAllBoolean) {
          accordion.hideAll();
        }

        accordion.$tabbedElements = elem;
        var parentAccordion = accordion.$tabbedElements.closest('.accordion');
        if (parentAccordion.parent('[data-default-collapsed]').length) accordion.defaultCollapsed = parentAccordion.parent().data('default-collapsed');

        if (accordion.defaultCollapsed) {
          accordion.$tabbedElements.each(function () {
            var $this = $(this);
            $this.find(".accordion-tabbed__tab").each(function (index) {
              var $this = $(this);

              if (accordion.preventAccordionBehavior($this)) {
                return;
              }

              if (!accordion.collapseTabsByDefault(this) && index == accordion.openedAccordion && !$this.hasClass('accordion__closed')) {
                $this.addClass('js--open');
                $this.find('.accordion-tabbed__control').attr('aria-expanded', 'true');
                $this.find('.accordion-tabbed__content').show();

                if ($this.find('.accordion-lazy').length) {
                  accordion.getAccordionContent($this.find('.accordion-lazy'));
                }
              } else {
                $this.removeClass('js--open');
                $this.find('.accordion-tabbed__control').attr('aria-expanded', 'false');
                $this.find('.accordion-tabbed__content').hide();
              }
            });
          });
        } else {
          accordion.$tabbedElements.each(function () {
            var $this = $(this);
            $this.find("[class*='accordion-tabbed__tab']").each(function (index) {
              var $this = $(this);
              $this.addClass('js--open');
              $this.find('.accordion-tabbed__control').attr('aria-expanded', 'true');
              $this.find('.accordion-tabbed__content').show();
            });
          });
        }
      },
      collapseTabsByDefault: function () {
        return accordion.collapseTabs;
      },
      additionalAjaxSuccess: function ($elem) {},
      getCustomAjaxUrl: function ($elem) {},
      buildAjaxUrl: function ($elem) {
        var ajaxUrl;
        var hasCustomUrl = typeof $elem.attr('data-custom-url') !== 'undefined' && $elem.attr('data-custom-url') == 'true';

        if (hasCustomUrl) {
          ajaxUrl = accordion.getCustomAjaxUrl($elem);
        } else {
          var widgetId = $elem.attr('data-widgetid');
          var dropzoneId = $elem.attr('data-dropzoneid');
          var pbContext = encodeURIComponent($('meta[name=pbContext]').attr("content"));
          ajaxUrl = '/pb/widgets/accordion/loadTab?pbContext=' + pbContext + '&widgetId=' + widgetId + '&dropZoneId=' + dropzoneId;
        }

        return ajaxUrl;
      },
      getAccordionContent: function ($elem) {
        var ajaxUrl = accordion.buildAjaxUrl($elem);
        var $parentTab = $elem.parent();
        $.ajax({
          url: ajaxUrl,
          success: function (data) {
            $elem.closest('.accordion-tabbed__tab').attr('data-ajaxLoaded', 'true');
            $elem.replaceWith(data);

            if ($parentTab.find('.accordion-tabbed').length) {
              accordion.logic($parentTab.find('.accordion-tabbed'));
            }

            if ($parentTab.find('.creative-work').length) {
              $parentTab.find('.creative-work .delayLoad').removeClass('delayLoad');
              $parentTab.find('.creative-work .lazy-load').remove();
            }

            accordion.additionalAjaxSuccess($parentTab);
          },
          error: function () {}
        });
      },
      on: {
        toggle: {
          single: function ($this) {
            var $accordionContent = $this.next('.accordion__content');

            if (typeof $this.attr('data-content-target') !== 'undefined') {
              var contentTarget = $this.attr('data-content-target');
              $accordionContent = $(contentTarget);
            }

            $accordionContent.slideToggle(200, function () {
              if ($this.parent().hasClass('article-accordion')) {
                $('.article-row-left').height('auto');
                accordion.isStickyBody = state;
              }
            });
            $this.toggleClass('js--open');
            var $wrapper = $this.closest(".expandable-accordion");
            var state = !($this.attr('aria-expanded') == 'true');
            $this.attr('aria-expanded', state);
            if ($wrapper.length) accordion.on.checkExpandAll($this, state, $wrapper);
          },
          tabbed: function ($this) {
            var $parent = $this.closest(".accordion-tabbed__tab");
            var $opened = $this.closest('.accordion-tabbed').children('.js--open');
            var state = !($this.attr('aria-expanded') == 'true');
            $this.attr('aria-expanded', state);
            var $wrapper = $this.closest(".expandable-accordion");
            if ($wrapper.length) accordion.on.checkExpandAll($this, state, $wrapper);

            if (!$parent.hasClass('js--open')) {
              if (accordion.collapseAccordion || accordion.extraCollapseAccordionCheck($parent)) {
                $opened.children('.accordion-tabbed__content').slideUp(200);
              }

              $parent.children('.accordion-tabbed__content').slideDown(200, function () {
                if (accordion.collapseAccordion || accordion.extraCollapseAccordionCheck($parent)) {
                  $opened.removeClass('js--open');
                }

                $parent.addClass('js--open');

                if ($parent.attr('data-ajaxLoaded') != 'true' && $parent.find('.accordion-lazy').length) {
                  accordion.getAccordionContent($parent.find('.accordion-lazy'));
                }

                accordion.on.expanded($this);
              });
            } else {
              $parent.children('.accordion-tabbed__content').slideUp(200, function () {
                $this.removeClass('js--open');
                $parent.removeClass('js--open'); // @fixme: work with aria-expanded is missing here, so it doesn't work correct
              });
            }
          },
          all: function ($this) {
            var $wrapper = $this.closest(".expandable-accordion");
            var state = !($this.attr('aria-expanded') == 'true');
            $this.attr('aria-expanded', state);

            if (state) {
              $wrapper.find('.accordion-tabbed__tab').addClass('js--open');
              $wrapper.find('.accordion__control, .accordion-tabbed__control').addClass('js--open').attr('aria-expanded', state);
              $wrapper.find('.accordion__content, .accordion-tabbed__content').slideDown(200);
              $this.text('Hide All');
              var $lazy = $wrapper.find('[data-ajaxLoaded]');
              $lazy.each(function () {
                if ($lazy.attr('[data-ajaxLoaded]') != 'true' && $lazy.find('.accordion-lazy').length) {
                  accordion.getAccordionContent($lazy.find('.accordion-lazy'));
                }
              });
            } else {
              $wrapper.find('.accordion-tabbed__tab').removeClass('js--open');
              $wrapper.find('.accordion__control, .accordion-tabbed__control').removeClass('js--open').attr('aria-expanded', state);
              $wrapper.find('.accordion__content, .accordion-tabbed__content').slideUp(200);
              $this.text('Expand All');
            }
          }
        },
        expanded: function ($this) {},
        checkExpandAll: function ($this, state, $wrapper) {
          if ($wrapper.length) var $expandElem = $wrapper.find('.expand-all');

          if ($expandElem.length && $expandElem.attr('aria-expanded') == 'true') {
            $expandElem.attr('aria-expanded', state);
            if (state) $expandElem.text('Hide All');else $expandElem.text('Expand All');
          }
        }
      },
      hideAll: function () {
        //Hide accordion content on load (in case of disabled JS, the accordion should be open)
        accordion.$elements.each(function () {
          var $this = $(this);
          $this.find('.accordion__control').attr('aria-expanded', 'false');

          if (!$this.find('.accordion__content').hasClass("js--open")) {
            $this.find('.accordion__content').hide();
          } else if ($this.find('.accordion__content').hasClass("js--open")) {
            $this.find('.accordion__control').attr('aria-expanded', 'true');
          } else {
            $this.find('.accordion__content').removeClass("js--open");
          }
        });
      },
      initResponsive: function () {
        if (accordion.$responsiveElements.length) {
          accordion.$responsiveElements.each(function (index) {
            accordion.$responsiveTarget[index] = $(this);
            accordion.accVport[index] = $(this).data('accordion-vport');
            accordion.setViewports(index);
          });
        }
      },
      preventAccordionBehavior: function ($this) {
        if ($this.parents('[data-accordion-vport]:not(.accordion-vport--res)').length) return true;
        return false;
      },
      extraCollapseAccordionCheck: function ($parent) {
        if (accordion.collapseAccordion) return true;
        return false;
      },
      setViewports: function (index) {
        $(document).on(accordion.accVport[index] + '-on', function () {
          var target = accordion.$responsiveTarget[index];

          if (target.data('accordion-vport') == accordion.accVport[index]) {
            target.addClass("accordion-vport--res");

            if (target.data('accordion-option') == "with-arrow") {
              target.addClass("accordion-with-arrow");
            }

            accordion.logic(accordion.$responsiveTarget[index].find('.accordion-tabbed'));
          }
        });
        $(document).on(accordion.accVport[index] + '-off', function () {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          var target = accordion.$responsiveTarget[index];

          if (target.data('accordion-vport') == accordion.accVport[index]) {
            target.removeClass("accordion-vport--res accordion-with-arrow");
            target.find('.accordion-tabbed__content').show();
          }
        });
      }
    };
    UX.accordion = accordion; // add to global namespace
  })();

  (function () {
    var $body = $('body');
    var refine = {
      $target: null,
      $targets: $('.refineSearch'),
      $showController: $('.quick-search__ctrl__refine'),
      $hideController: $('.quick-search__ctrl__refine--hide'),
      $elements: $('.refineSearch__row'),
      $wrapper: null,
      escape: 27,
      init: function () {
        refine.control();

        if ($('.quick-search').length) {
          refine.on.hide();
        }
      },
      control: function () {
        $body.on('click', '.refineSearch__ctrl__remove', function (e) {
          e.preventDefault();
          var $this = $(this);
          refine.$target = $this.closest('.refineSearch');
          refine.$wrapper = refine.$target.find('.refineSearch__texts');
          refine.on.remove($this);
        });
        $body.on('click', '.refineSearch__ctrl__add', function (e) {
          e.preventDefault();
          var $this = $(this);
          refine.$target = $this.closest('.refineSearch');
          refine.$wrapper = refine.$target.find('.refineSearch__texts');
          refine.on.clone($this);
        });
        $body.on('click', '.quick-search__ctrl__refine', function (e) {
          e.preventDefault();

          if (refine.$targets.length) {
            refine.on.show();
          }
        });
        $body.on('click', '.quick-search__ctrl__refine--hide', function (e) {
          e.preventDefault();
          refine.on.hide();
        });
        $body.on('click', function (e) {
          if (!refine.$targets.is(e.target) // if the target of the click isn't the container...
          && refine.$targets.has(e.target).length === 0 // ... nor a descendant of the container
          && !refine.$showController.is(e.target) // if the target of the click isn't the controller...
          && refine.$showController.has(e.target).length === 0 // ... nor a descendant of the controller
          && !$(e.target).closest('.jcf-select-drop').length && !refine.$targets.closest('.search-result__refine-search').length && !$(e.target).closest('.refineSearch__ctrl__remove').length) {
            refine.on.hide();
          }
        });
        $(document).on('keydown', function (e) {
          if ((e.keyCode || e.which) === refine.escape) {
            refine.on.hide();
          }
        });
      },
      on: {
        clone: function ($this) {
          jcf.destroyAll();
          $this.closest('.refineSearch__row').clone(true, true).find('input').attr("name", "text" + ($(".refineSearch__row").length + 1).toString()).val('').end().appendTo(refine.$wrapper);
          $this.addClass('hidden');
          $this.siblings('.refineSearch__ctrl__remove').removeClass('hidden');
          $('.jcf').each(function () {
            jcf.replace($(this));
          });
        },
        remove: function ($this) {
          $this.closest('.refineSearch__row').remove();
        },
        show: function () {
          refine.$showController.addClass('hidden');
          refine.$hideController.removeClass('hidden');
          refine.$targets.addClass('js--open');
          refine.$targets.show();
        },
        hide: function () {
          refine.$targets.each(function () {
            if ($body.attr('data-active') === 'refine') {
              $body.removeAttr('data-active');
            }

            refine.$hideController.addClass('hidden');
            refine.$showController.removeClass('hidden');
            refine.$targets.removeClass('js--open');
            refine.$targets.hide();
          });
        }
      }
    };
    UX.refine = refine; // add to global namespace
  })();

  (function () {
    var $section = $('.figure-viewer'),
        $window = $(window),
        $document = $(document),
        $body = $('body');
    var figureViewer = {
      options: {
        /*
        * false|classCombination|className|dataRel
        * */
        filter: false,
        filterClass: 'article__tabFigure'
      },
      $topRegHeight: $('.figure-viewer__reg__top').innerHeight(),
      vPort: "screen-md",
      $figures: null,
      $figuresToShow: null,
      $figureWidth: null,
      $currentIndex: null,
      $focusedElementBeforeOpened: null,
      $section: $section,
      $holder: $section.find('.figure-viewer__hold__fig'),
      $holderElement: $section.find('.figure-viewer__hold__fig').find('figure'),
      $captionHolder: $section.find('.figure-viewer__hold__figcap'),
      $lister: $section.find('.figure-viewer__hold__list'),
      $figureRegionContainer: $section.find('.figure-viewer__reg__center'),
      $captionRegion: $section.find('.figure-viewer__cent__right'),
      $contentRegion: $section.find('.figure-viewer__cent__left'),
      $figureNav: $section.find('.figure-viewer__ctrl__next, .figure-viewer__ctrl__prev'),
      $zoominbtn: $section.find('.zoom-in'),
      $zoomoutbtn: $section.find('.zoom-out'),
      $zoomrange: $section.find('.zoom-range'),
      $zoomreset: $section.find('.reset'),
      $image: $section.find('figure'),
      $browsebtn: $('.figure-viewer__ctrl__browse'),
      $returnbtn: $('.figure-viewer__ctrl__return'),
      isMobile: false,
      islocked: false,
      offsetY: window.pageYOffset,
      $hideList: $('.zoomSlider, .figure-viewer__label__zoom'),
      $browseContainer: $('.figure-viewer__hold__list'),
      expand: function () {
        // preserve backward compatibility with previous buggy version - it can be removed if filterContexts would become default behavior
        if (figureViewer.options.filter) {
          figureViewer.$figures = $document.find(':not(.figure-viewer__hold__list) > figure:not(.holder), :not(.figure-viewer__hold__list) > .figure:not(.holder)');
        } else {
          figureViewer.$figures = $document.find('figure:not(.holder), .figure:not(.holder)');
        }

        figureViewer.$figures.each(function (index) {
          var $this = $(this);
          $this.data('index', index);

          if (figureViewer.options.filter) {
            $this.addClass('figure'); // add class to be sure, that correct grid styling will be there

            if (figureViewer.options.filter === 'dataRel') {
              // move data-rel to container from child
              var dataRelElement = $this.find('[data-rel]');

              if (dataRelElement.length > 0 && dataRelElement.data().rel) {
                $this.attr('data-rel', dataRelElement.data().rel);
              }
            }
          } // $this.find('.figure__image, .open-figure-link').on({
          //     click: function (event) {
          //         event.preventDefault();
          //         if (!$this.hasClass('ui-disabled') && !$this.closest('.figure-viewer__hold__fig').length && $('.figure-viewer').length) {
          //             figureViewer.on.show($this, index);
          //         }
          //     }
          // });

        });
      },

      /*
      * Filter grid view and navigation based on item opened and option provided by figureViewer.options.filter
      * */
      filter: function ($this) {
        if (figureViewer.options.filter === 'classCombination') {
          var className = $this.attr('class');
          figureViewer.$figuresToShow = figureViewer.$figures.filter('[class="' + className + '"]');
        } else if (figureViewer.options.filter === 'className') {
          figureViewer.$figuresToShow = figureViewer.$figures.filter('.' + figureViewer.options.filterClass);
        } else if (figureViewer.options.filter === 'dataRel') {
          var dataRel = $this.data('rel');

          if (dataRel) {
            figureViewer.$figuresToShow = figureViewer.$figures.filter('[data-rel="' + dataRel + '"]');
          } else {
            figureViewer.$figuresToShow = figureViewer.$figures;
          }
        } else {
          figureViewer.$figuresToShow = figureViewer.$figures;
        }

        figureViewer.$currentIndex = figureViewer.$figuresToShow.index($this);
      },
      control: function () {
        $(document).on(figureViewer.vPort + '-on', function () {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          figureViewer.isMobile = true;
        });
        $(document).on(figureViewer.vPort + '-off', function () {
          // Waiting for custom event that will be triggered by controller.js to deactivate responsive effects
          figureViewer.isMobile = false;
        });
        figureViewer.clickHandler();
        var $figureViewer = $body.find('.figure-viewer');
        var $controllerElement = $figureViewer.find('a, button');
        $controllerElement.each(function () {
          var $this = $(this);
          $this.on({
            click: function (event) {
              event.preventDefault();
              event.stopPropagation();

              if ($this.hasClass('figure-viewer__ctrl__close')) {
                // close button
                figureViewer.on.hide();
              } else if ($this.hasClass('figure-viewer__ctrl__next')) {
                // Next button
                figureViewer.next();
              } else if ($this.hasClass('figure-viewer__ctrl__prev')) {
                // Prev Button
                figureViewer.prev();
              } else if ($this.hasClass('figure-viewer__ctrl__caption')) {
                // open / close caption Button
                figureViewer.captionToggle($this);
              } else if ($this.hasClass('figure-viewer__ctrl__browse')) {
                // browse all figures
                figureViewer.browse($(this));
              } else if ($this.hasClass('figure-viewer__ctrl__return')) {
                // browse all figures
                figureViewer.return($(this));
              }
            }
          });
        }); // preserve backward compatibility with previous buggy version - it can be removed if filterContexts would become default behavior

        if (figureViewer.options.filter) {
          $(".figure a:not(.open-figure-link)").click(function (e) {
            var $img = $(this).find("img");
            shouldDefault = $(this).hasClass('linkBehavior');

            if (!shouldDefault || $img.length !== 0) {
              e.preventDefault();
              $img.trigger("click");
            }
          });
          $(".figure a:not(.open-figure-link) img").click(function (e) {
            e.stopPropagation();
          });
        } else {
          $(".figure a:not('.ppt-figure-link')").click(function (e) {
            var $img = $(this).find("img");
            shouldDefault = $(this).hasClass('linkBehavior');

            if (!shouldDefault || $img.length !== 0) {
              //e.preventDefault();
              $img.trigger("click");
            }
          });
        }

        $('body').keydown(function (event) {
          // is figureviewer open? no? than we don't do anything
          if ($body.attr('data-active') !== 'figureViewer') {
            return;
          }

          if (event.keyCode === 37) {
            // left
            figureViewer.prev();
          } else if (event.keyCode === 39) {
            // right
            figureViewer.next();
          }
        });
        figureViewer.supplementary.control();
        figureViewer.hideOnClickOutside();
        figureViewer.resize();
        $(window).on('resized', function () {
          figureViewer.resize();
        });

        if (figureViewer.$figures.length == 1) {
          figureViewer.$figureNav.hide();
        } // @FIXME this is not working focus trap... - cannot work in most cases and for shift tab


        $(".figure-viewer__ctrl__caption").focusout(function () {
          $('.figure-viewer__ctrl__close').focus();
        });
      },
      hideOnClickOutside: function () {
        figureViewer.$image.on('click', function (e) {
          var img_clicked = $(e.target).is('img');

          if (!img_clicked) {
            figureViewer.on.hide();
          }
        });
      },
      clickHandler: function () {
        $(document).on('click', '.figure__image, .open-figure-link', function (event) {
          event.preventDefault();
          const $self = $(this);

          if ($self.parent().hasClass('figure-viewer__thumbnail-item')) {
            return;
          }

          var $this = $self.closest('figure, .figure, .imageTable');

          if (!$this.hasClass('ui-disabled') && !$this.closest('.figure-viewer__hold__fig').length) {
            // check if explicitly disabled or the figure is already in the viewer so the event is useless at this state. It also gets in the way of drag and drop functionality in the figure viewer.
            figureViewer.on.show($this, $this.data('index'));
          }
        });
      },
      captionToggle: function ($elem) {
        figureViewer.toggle($elem.closest('.figure-viewer__cent__right'));
        figureViewer.toggle($('.figure-viewer__cent__left'));
        $elem.toggleClass('js-open');
      },
      next: function () {
        // preserve backward compatibility with previous buggy version - it can be removed if filterContexts would become default behavior
        if (!figureViewer.options.filter) {
          figureViewer.$figuresToShow = figureViewer.$figures;
        }

        if (figureViewer.$currentIndex < figureViewer.$figuresToShow.length - 1) {
          if (!figureViewer.$figuresToShow.eq(figureViewer.$currentIndex + 1).closest('.figure-viewer').length) {
            figureViewer.$currentIndex++;
            var $next = figureViewer.$figuresToShow.eq(figureViewer.$currentIndex);
            figureViewer.replace($next);
            figureViewer.zoom.reset();
          }
        } else {
          figureViewer.$currentIndex = 0;
          var $next = figureViewer.$figuresToShow.eq(figureViewer.$currentIndex);
          figureViewer.replace($next);
          figureViewer.zoom.reset();
        }
      },
      prev: function () {
        // preserve backward compatibility with previous buggy version - it can be removed if filterContexts would become default behavior
        if (!figureViewer.options.filter) {
          figureViewer.$figuresToShow = figureViewer.$figures;
        }

        if (figureViewer.$currentIndex >= 1) {
          if (!figureViewer.$figuresToShow.eq(figureViewer.$currentIndex - 1).closest('.figure-viewer').length) {
            figureViewer.$currentIndex--;
            var $prev = figureViewer.$figuresToShow.eq(figureViewer.$currentIndex);
            figureViewer.replace($prev);
            figureViewer.zoom.reset();
          }
        } else {
          figureViewer.$currentIndex = figureViewer.$figuresToShow.length - 1;
          var $prev = figureViewer.$figuresToShow.eq(figureViewer.$currentIndex);
          figureViewer.replace($prev);
          figureViewer.zoom.reset();
        }
      },
      replace: function (element) {
        var $figure = element.find('.figure__image').clone();
        $figure.each(function () {
          var $this = $(this);
          $this.attr('src', $this.attr('data-lg-src'));
        }); // handle multiple images in one figure

        if ($figure.length > 1) {
          // return one to image viewer and create navigation
          $figure = figureViewer.supplementary.show(element, $figure);
        } else {
          figureViewer.supplementary.hide();
        }

        var $caption = element.find('figcaption, .figcaption').clone();
        var $title = $caption.find('strong').remove();
        $('.figure-viewer__title__text').text($title.text());
        figureViewer.$holder.find('img').remove();
        figureViewer.$holder.find('figure').append($figure.get(0).outerHTML);
        figureViewer.$captionHolder.empty();
        $caption = figureViewer.additionalBehaviorOnShow(element);
        figureViewer.$captionHolder.append($caption);
        figureViewer.$captionHolder.find('.figure__title').remove();
        figureViewer.$figureWidth = figureViewer.$holder.find('img').width();
        figureViewer.zoom.check();
      },
      supplementary: {
        nav: null,

        /**
         *
         * @param element
         * @param $figure
         * @public
         * @returns {jQuery} current image
         */
        show: function (element, $figure) {
          // get current index
          var index = this.check(element);
          var $thumbnails = $figure.clone();
          var self = this; // create supplementary navigation

          if (!this.nav) {
            this.nav = $('<ul class="figure-viewer__hold__supplementary-nav"></ul>');
            this.nav.appendTo(figureViewer.$section);
          } // create navigation items


          this.nav.empty();
          $thumbnails.each(function (index) {
            var $thumb = $('<li><a href="#" title="Go to figure image ' + (index + 1) + '. of current figure." class="figure-viewer__thumbnail-item"></a></li>');
            $thumb.find('a').append(this);
            $thumb.find('a').on('click', function (event) {
              event.preventDefault();
              self.toIndex(element, index);
            }); // add to nav

            self.nav.append($thumb);
          }); // set initial active class

          this.nav.find('li').eq(index).addClass('active'); // return current into view

          return $figure.eq(index);
        },

        /**
         *
         * @public
         */
        hide: function () {
          if (this.nav) {
            this.nav.empty();
          }
        },
        save: function (element, index) {
          element.data('figure-viewer-display', index);
        },
        check: function (element) {
          return element.data('figure-viewer-display') || 0;
        },
        toIndex: function (element, index) {
          var $images = element.find('img');

          if ($images.length === 1) {
            // don't do anything for one image
            return;
          } // loop on edges


          if (index >= $images.length) {
            index = 0;
          }

          if (index < 0) {
            index = $images.length - 1;
          } // append index image


          figureViewer.$holder.find('img').remove();
          figureViewer.$holderElement.append($images.eq(index).clone()); // toggle active class

          this.nav.find('li').removeClass('active');
          this.nav.find('li').eq(index).addClass('active'); // save state

          this.save(element, index);
        },
        next: function (element) {
          var index = this.check(element) + 1;
          this.toIndex(element, index);
        },
        prev: function (element) {
          var index = this.check(element) - 1;
          this.toIndex(element, index);
        },

        /**
         *
         * @public
         */
        control: function () {
          $('body').keydown(function (event) {
            // is figureviewer open? no? than we don't do anything
            if ($body.attr('data-active') !== 'figureViewer') {
              return;
            } // preserve backward compatibility with previous buggy version - it can be removed if filterContexts would become default behavior


            if (!figureViewer.options.filter) {
              figureViewer.$figuresToShow = figureViewer.$figures;
            } // is there any figure to show?


            if (figureViewer.$figuresToShow && figureViewer.$figuresToShow.length < 1) {
              return;
            }

            var element = figureViewer.$figuresToShow.eq(figureViewer.$currentIndex);

            if (event.keyCode === 38) {
              // up
              figureViewer.supplementary.prev(element);
            } else if (event.keyCode === 40) {
              // down
              figureViewer.supplementary.next(element);
            }
          });
        }
      },
      browse: function (element) {
        figureViewer.$holder.addClass('is-hidden');
        figureViewer.$figureNav.addClass('is-hidden');
        figureViewer.$browsebtn.addClass('is-hidden');
        figureViewer.$returnbtn.removeClass('is-hidden');
        figureViewer.$captionRegion.removeClass('js-open');
        figureViewer.$contentRegion.removeClass('js-open');
        figureViewer.$figureRegionContainer.addClass('scrollable');
        figureViewer.$captionRegion.addClass('is-hidden');
        figureViewer.$hideList.each(function () {
          $(this).addClass('is-hidden');
        });
        figureViewer.$lister.removeClass('is-hidden');
        figureViewer.supplementary.hide();
        figureViewer.$browseContainer.empty(); // preserve backward compatibility with previous buggy version - it can be removed if filter would become default behavior

        if (figureViewer.options.filter) {
          figureViewer.$figuresToShow.each(function () {
            var $fig = $(this).clone(true);
            var $figureExtra = $fig.find(".figure-extra");

            if ($figureExtra.length) {
              $figureExtra.remove();
            }

            figureViewer.$browseContainer.append($fig);
          });
        } else {
          figureViewer.$figures.each(function () {
            if ($(this).hasClass('article__tabFigure')) {
              var $fig = $(this).clone(true);
              var $figureLinks = $fig.find(".figure-links");

              if ($figureLinks.length) {
                $figureLinks.remove();
              }

              figureViewer.$browseContainer.append($fig);
            }
          });
        }

        figureViewer.additionalBrowse();
      },
      additionalBrowse: function () {},
      return: function () {
        figureViewer.$holder.removeClass('is-hidden');
        figureViewer.$figureNav.removeClass('is-hidden');
        figureViewer.$browsebtn.removeClass('is-hidden');
        figureViewer.$returnbtn.addClass('is-hidden'); //figureViewer.$contentRegion.addClass('js-open');

        figureViewer.$captionRegion.removeClass('is-hidden');
        figureViewer.$hideList.each(function () {
          $(this).removeClass('is-hidden');
        });
        figureViewer.$lister.addClass('is-hidden');
        const $figureViewText = $('.figure-viewer__title__text');
        $figureViewText.removeClass('figure-viewer__title__text__allfigures');
        $figureViewText.parent('.figure-viewer__ctrl').removeClass('allfigures__is__displayed');
        $('.figure-viewer__ctrl__caption').parent(".figure-viewer__ctrl").show();
        figureViewer.$browseContainer.empty();
        figureViewer.additionalReturn();
      },
      additionalReturn: function () {},
      height: function (element) {
        var $windowsHeight = $(window).innerHeight();
        figureViewer.$topRegHeight = $('.figure-viewer__reg__top').innerHeight();
        var $height = $windowsHeight - figureViewer.$topRegHeight - $('.figure-viewer__caption__label').innerHeight();
        $('.figure-viewer__cent__left').find('figure').height($height);
      },
      toggle: function (element) {
        element.toggleClass('js-open');
        figureViewer.figcaptionSize(); //LIT-161818
      },
      displayViewer: function () {
        $('.figure-viewer').show();
      },
      additionalShow: function () {},
      on: {
        show: function ($this, index) {
          figureViewer.offsetY = $body.data('yoffset') || window.pageYOffset;
          $body.data('yoffset', figureViewer.offsetY);

          if (typeof UX.controller !== 'undefined') {
            if ($body.attr('data-active') !== 'slide') {
              // keep drop block open in publication content widget
              UX.controller.check();
            }
          }

          $body.attr('data-active', 'figureViewer');
          figureViewer.islocked = true;
          figureViewer.$currentIndex = index;
          figureViewer.replace($this);
          figureViewer.$focusedElementBeforeOpened = document.activeElement;
          figureViewer.displayViewer();
          $body.css('overflow', 'hidden'); // LIT-152707

          figureViewer.height();
          figureViewer.zoom.check();
          figureViewer.resize();
          figureViewer.$holder.removeClass('is-hidden');
          figureViewer.$captionRegion.removeClass('is-hidden');
          figureViewer.$browsebtn.removeClass('is-hidden');
          figureViewer.$returnbtn.addClass('is-hidden');
          figureViewer.$figureNav.removeClass('is-hidden');
          figureViewer.$hideList.each(function () {
            $(this).removeClass('is-hidden');
          });
          figureViewer.$lister.addClass('is-hidden');
          figureViewer.$figureRegionContainer.removeClass('scrollable');
          $('.figure-viewer__ctrl__close').focus();

          if (figureViewer.options.filter) {
            figureViewer.filter($this);
          }

          figureViewer.additionalShow();
        },
        hide: function () {
          if (figureViewer.islocked) {
            $body.removeAttr('data-active');
          } else {
            $body.removeClass('lock-screen').removeAttr('data-active');
          }

          figureViewer.zoom.reset();
          $('.figure-viewer').hide();
          figureViewer.$focusedElementBeforeOpened.focus();
          $body.css('overflow', ''); // LIT-152707

          $(window).scrollTop(figureViewer.offsetY);
          $body.removeData('yoffset');
        }
      },
      additionalBehaviorOnShow: function ($el) {
        return $el.find('figcaption, .figcaption').clone();
      },
      zoom: {
        /*init: function (element) {
         var figureViewer.$section = $('.figure-viewer');
         },*/
        reset: function () {
          $elem = $('.figure-viewer').find('figure');
          $elem.panzoom('reset');
        },
        check: function () {
          figureViewer.zoom.panzoom.init();

          if ($window.width() < 992) {
            figureViewer.zoom.swap();
          }
        },
        panzoom: {
          // zoom in functionality
          init: function () {
            if (typeof $.fn.panzoom != 'undefined') {
              figureViewer.$image.panzoom({
                $zoomIn: figureViewer.$zoominbtn,
                $zoomOut: figureViewer.$zoomoutbtn,
                $zoomRange: figureViewer.$zoomrange,
                $reset: figureViewer.$zoomreset,
                panOnlyWhenZoomed: true,
                minScale: 1
              });
              figureViewer.$image.on('panzoomchange', function (e) {
                if (figureViewer.$zoomrange.val() === '1') {
                  figureViewer.$image.css('transform', 'matrix(1, 0, 0, 1, 0, 0)');
                  $(this).removeClass('zoomed');
                } else {
                  $(this).addClass('zoomed');
                }
              });
            }
          }
        },
        swap: function () {
          // swap functionality for mobile devices
          figureViewer.$section.find('img').swipe({
            //Generic swipe handler for all directions
            swipe: function (event, direction, distance, duration, fingerCount, fingerData) {
              if (direction === 'left' && !figureViewer.$section.find('figure').hasClass('zoomed')) {
                figureViewer.next();
              } else if (direction === 'right' && !figureViewer.$section.find('figure').hasClass('zoomed')) {
                figureViewer.prev();
              }
            }
          });
        }
      },
      slide: function () {
        var $target = $body.find('div.ux3-in-slide');
        $body.removeAttr('data-ux3-show');
        setTimeout(function () {
          $target.append($slide.children('div'));
          $target.removeClass('ux3-in-slide');
        }, 250);
      },
      resize: function () {
        var wHeight = $window.innerHeight();
        const topHeight = figureViewer.$topRegHeight || 56;

        if (figureViewer.isMobile) {
          figureViewer.$figureRegionContainer.css('height', wHeight - topHeight);
        } else {
          figureViewer.$figureRegionContainer.css('height', `calc(100vh - ${topHeight}px)`);
        }
      },
      figcaptionSize: function () {
        var $figcaption = $('.figure-viewer__hold__figcap').find('figcaption'),
            figure_area_height = figureViewer.$figureRegionContainer.height(),
            figure_title_height = $('.figure-viewer__title').height() + 30,
            padding = 30;
        $figcaption.css('max-height', figure_area_height - 2 * padding - figure_title_height);
      },
      doubleTap: function () {
        // disable double tap zooming functionality on mobile devices
        (function ($) {
          $.fn.nodoubletapzoom = function () {
            $(this).bind('touchstart', function preventZoom(e) {
              var t2 = e.timeStamp;
              var t1 = $(this).data('lastTouch') || t2;
              var dt = t2 - t1;
              var fingers = e.originalEvent.touches.length;
              $(this).data('lastTouch', t2);

              if (!dt || dt > 500 || fingers > 1) {
                return; // not double-tap
              }

              e.preventDefault(); // double tap - prevent the zoom
              // also synthesize click events we just swallowed up

              $(e.target).trigger('click');
            });
          };
        })(jQuery);
      },
      init: function () {
        figureViewer.expand();
        figureViewer.control();
        figureViewer.doubleTap();
        $('body').nodoubletapzoom();
      }
    };
    UX.figureViewer = figureViewer; // add to global namespace
  })();

  /*!
   * Lazy Load - jQuery plugin for lazy loading images
   *
   * Copyright (c) 2007-2015 Mika Tuupola
   *
   * Licensed under the MIT license:
   *   http://www.opensource.org/licenses/mit-license.php
   *
   * Project home:
   *   http://www.appelsiini.net/projects/lazyload
   *
   * Version:  1.9.7
   *
   */
  (function ($, window, document, undefined) {
    var $window = $(window);

    $.fn.lazyload = function (options) {
      var elements = this;
      var $container;
      var settings = {
        threshold: 0,
        failure_limit: 0,
        event: "scroll",
        effect: "show",
        container: window,
        data_attribute: "original",
        skip_invisible: false,
        appear: null,
        load: null,
        placeholder: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC"
      };

      function update() {
        var counter = 0;
        elements.each(function () {
          var $this = $(this);

          if (settings.skip_invisible && !$this.is(":visible")) {
            return;
          }

          if ($.abovethetop(this, settings) || $.leftofbegin(this, settings)) ; else if (!$.belowthefold(this, settings) && !$.rightoffold(this, settings)) {
            $this.trigger("appear");
            /* if we found an image we'll load, reset the counter */

            counter = 0;
          } else {
            if (++counter > settings.failure_limit) {
              return false;
            }
          }
        });
      }

      if (options) {
        /* Maintain BC for a couple of versions. */
        if (undefined !== options.failurelimit) {
          options.failure_limit = options.failurelimit;
          delete options.failurelimit;
        }

        if (undefined !== options.effectspeed) {
          options.effect_speed = options.effectspeed;
          delete options.effectspeed;
        }

        $.extend(settings, options);
      }
      /* Cache container as jQuery as object. */


      $container = settings.container === undefined || settings.container === window ? $window : $(settings.container);
      /* Fire one scroll event per scroll. Not one scroll event per image. */

      if (0 === settings.event.indexOf("scroll")) {
        $container.bind(settings.event, function () {
          return update();
        });
      }

      this.each(function () {
        var self = this;
        var $self = $(self);
        self.loaded = false;
        /* If no src attribute given use data:uri. */

        if ($self.attr("src") === undefined || $self.attr("src") === false) {
          if ($self.is("img")) {
            $self.attr("src", settings.placeholder);
          }
        }
        /* When appear is triggered load original image. */


        $self.one("appear", function () {
          if (!this.loaded) {
            if (settings.appear) {
              var elements_left = elements.length;
              settings.appear.call(self, elements_left, settings);
            }

            $("<img />").bind("load", function () {
              var original = $self.attr("data-" + settings.data_attribute);
              $self.hide();

              if ($self.is("img")) {
                $self.attr("src", original);
              } else {
                $self.css("background-image", "url('" + original + "')");
              }

              $self[settings.effect](settings.effect_speed);
              self.loaded = true;
              /* Remove image from array so it is not looped next time. */

              var temp = $.grep(elements, function (element) {
                return !element.loaded;
              });
              elements = $(temp);

              if (settings.load) {
                var elements_left = elements.length;
                settings.load.call(self, elements_left, settings);
              }
            }).attr("src", $self.attr("data-" + settings.data_attribute));
          }
        });
        /* When wanted event is triggered load original image */

        /* by triggering appear.                              */

        if (0 !== settings.event.indexOf("scroll")) {
          $self.bind(settings.event, function () {
            if (!self.loaded) {
              $self.trigger("appear");
            }
          });
        }
      });
      /* Check if something appears when window is resized. */

      $window.bind("resize", function () {
        update();
      });
      /* With IOS5 force loading images when navigating with back button. */

      /* Non optimal workaround. */

      if (/(?:iphone|ipod|ipad).*os 5/gi.test(navigator.appVersion)) {
        $window.bind("pageshow", function (event) {
          if (event.originalEvent && event.originalEvent.persisted) {
            elements.each(function () {
              $(this).trigger("appear");
            });
          }
        });
      }
      /* Force initial check if images should appear. */


      $(document).ready(function () {
        update();
      });
      return this;
    };
    /* Convenience methods in jQuery namespace.           */

    /* Use as  $.belowthefold(element, {threshold : 100, container : window}) */


    $.belowthefold = function (element, settings) {
      var fold;

      if (settings.container === undefined || settings.container === window) {
        fold = (window.innerHeight ? window.innerHeight : $window.height()) + $window.scrollTop();
      } else {
        fold = $(settings.container).offset().top + $(settings.container).height();
      }

      return fold <= $(element).offset().top - settings.threshold;
    };

    $.rightoffold = function (element, settings) {
      var fold;

      if (settings.container === undefined || settings.container === window) {
        fold = $window.width() + $window.scrollLeft();
      } else {
        fold = $(settings.container).offset().left + $(settings.container).width();
      }

      return fold <= $(element).offset().left - settings.threshold;
    };

    $.abovethetop = function (element, settings) {
      var fold;

      if (settings.container === undefined || settings.container === window) {
        fold = $window.scrollTop();
      } else {
        fold = $(settings.container).offset().top;
      }

      return fold >= $(element).offset().top + settings.threshold + $(element).height();
    };

    $.leftofbegin = function (element, settings) {
      var fold;

      if (settings.container === undefined || settings.container === window) {
        fold = $window.scrollLeft();
      } else {
        fold = $(settings.container).offset().left;
      }

      return fold >= $(element).offset().left + settings.threshold + $(element).width();
    };

    $.inviewport = function (element, settings) {
      return !$.rightoffold(element, settings) && !$.leftofbegin(element, settings) && !$.belowthefold(element, settings) && !$.abovethetop(element, settings);
    };
    /* Custom selectors for your convenience.   */

    /* Use as $("img:below-the-fold").something() or */

    /* $("img").filter(":below-the-fold").something() which is faster */


    $.extend($.expr[":"], {
      "below-the-fold": function (a) {
        return $.belowthefold(a, {
          threshold: 0
        });
      },
      "above-the-top": function (a) {
        return !$.belowthefold(a, {
          threshold: 0
        });
      },
      "right-of-screen": function (a) {
        return $.rightoffold(a, {
          threshold: 0
        });
      },
      "left-of-screen": function (a) {
        return !$.rightoffold(a, {
          threshold: 0
        });
      },
      "in-viewport": function (a) {
        return $.inviewport(a, {
          threshold: 0
        });
      },

      /* Maintain BC for couple of versions. */
      "above-the-fold": function (a) {
        return !$.belowthefold(a, {
          threshold: 0
        });
      },
      "right-of-fold": function (a) {
        return $.rightoffold(a, {
          threshold: 0
        });
      },
      "left-of-fold": function (a) {
        return !$.rightoffold(a, {
          threshold: 0
        });
      }
    });
  })(jQuery, window, document);

  (function ($) {
    var methods;

    function truncateText() {
      var that = this;
      var $this = $(this);
      var height = $this.height();
      var maxHeight = this.settings.lines * parseFloat($this.css('line-height'));
      var visible = !$this.closest(':not(:visible)').length;

      if (visible && height === 0) {
        setTimeout(function () {
          truncateText.call(that);
        }, 30);
        return;
      }

      if (height > maxHeight) {
        removeElements.call(this, $this);
      } else {
        setTimeout(function () {
          $this.addClass(that.settings.addClass);
        }, 0);
        $this.data('truncationDone', true);
        that.settings.onComplete();
      }
    }

    function removeElements(containerEl) {
      var that = this;
      var $this = $(this);
      var height = $this.height();
      var maxHeight = this.settings.lines * Math.ceil(parseFloat($this.css('line-height')));
      var $lastRemoved;
      var $parent;
      var $seeMore;

      if (this.settings.seeMoreLink) {
        $seeMore = seeMoreLink.call(this);
      } else {
        $seeMore = ellipsis.call(this);
      }

      if (containerEl.get(0).nodeType === Node.ELEMENT_NODE) {
        while (height > maxHeight && containerEl.contents().length) {
          $lastRemoved = containerEl.contents().last().remove();
          height = $this.height();
        }

        if (height <= maxHeight && $lastRemoved) {
          containerEl.append($lastRemoved);
          height = $this.height();

          if (height > maxHeight) {
            removeElements.call(this, $lastRemoved);
          }
        } else if ($.trim(containerEl.text()) === '') {
          $parent = containerEl.parent();
          containerEl.remove();
          height = $this.height();

          if ($.trim($parent.text()) === '') {
            removeElements.call(this, $parent);
          } else if (height <= maxHeight) {
            if ($this.children().length) {
              var $lastChild = $this.children().last();

              if ($lastChild.is('br')) {
                $lastChild.after($seeMore);
              } else {
                $lastChild.parent().append($seeMore);
              }
            } else {
              $this.append($seeMore);
            }

            if (this.settings.addClass && !$this.hasClass(this.settings.addClass)) {
              setTimeout(function () {
                $this.addClass(that.settings.addClass);
              }, 0);
            }

            $this.data('truncationDone', true);
            that.settings.onComplete();
          }
        }
      } else {
        var textContent = containerEl.text();
        var min = 0;
        var max = textContent.length - 1;
        var mid = Math.floor((min + max) / 2);
        $parent = containerEl.parent();

        while (min < max) {
          if (height > maxHeight) {
            //max = mid - 1;
            max = mid + parseInt((max - mid) * maxHeight / height, 10);
          } else {
            min = mid + 1;
          }

          $seeMore.remove();
          mid = Math.floor((min + max) / 2);
          containerEl.get(0).textContent = textContent.substr(0, this.settings.midWordEnabled ? mid : Math.min(mid, textContent.lastIndexOf(' ', mid)));

          if ($.trim($parent.text()) === '') {
            removeElements.call(this, $parent);
            return;
          }

          containerEl.parent().append($seeMore);
          height = $this.height();
        }

        while (height > maxHeight && mid > 0) {
          $seeMore.remove();
          mid = mid - 1;
          containerEl.get(0).textContent = textContent.substr(0, this.settings.midWordEnabled ? mid : Math.min(mid, textContent.lastIndexOf(' ', mid)));

          if ($.trim($parent.text()) === '') {
            removeElements.call(this, $parent);
            return;
          }

          containerEl.parent().append($seeMore);
          height = $this.height();
        }

        if (mid === 0) {
          $seeMore.remove();

          if ($.trim($parent.text()) === '') {
            removeElements.call(this, $parent);
          }
        }

        if (height <= maxHeight) {
          if (this.settings.addClass && !$this.hasClass(this.settings.addClass)) {
            setTimeout(function () {
              $this.addClass(that.settings.addClass);
            }, 0);
          }

          $this.data('truncationDone', true);
          that.settings.onComplete();
        }
      }
    }

    function truncateList() {
      var that = this;
      var $this = $(this);
      var height = $this.height();
      var lineHeight = Math.ceil(Math.max($this.children().height(), parseFloat($this.css('line-height'))));
      var maxHeight = this.settings.lines * lineHeight;
      var visible = !$this.closest(':not(:visible)').length;

      if ($this.children().length === 0) {
        $this.addClass(that.settings.addClass);
        $this.data('truncationDone', true);
        that.settings.onComplete();
        return;
      }

      if (visible && (height === 0 || maxHeight === 0)) {
        setTimeout(function () {
          truncateList.call(that);
        }, 30);
        return;
      }

      switch (this.settings.position) {
        case 'middle':
          if (height > maxHeight) {
            removeListItemsMiddle.call(this, $this);
          } else {
            if (this.settings.addClass && !$this.hasClass(this.settings.addClass)) {
              setTimeout(function () {
                $this.addClass(that.settings.addClass);
              }, 0);
            }

            $this.data('truncationDone', true);
            that.settings.onComplete();
          }

          break;

        case 'end':
          if (height > maxHeight) {
            removeListItemsEnd.call(this, $this);
          } else {
            if (this.settings.addClass && !$this.hasClass(this.settings.addClass)) {
              setTimeout(function () {
                $this.addClass(that.settings.addClass);
              }, 0);
            }

            $this.data('truncationDone', true);
            that.settings.onComplete();
          }

          break;

        case 'betweenFirstAndLast':
          removeListItemsBetweenFirstAndLast.call(this, $this);
          break;

        case 'beforeLast':
          if (height > maxHeight) {
            removeListItemsBeforeLast.call(this, $this);
          } else {
            if (this.settings.addClass && !$this.hasClass(this.settings.addClass)) {
              setTimeout(function () {
                $this.addClass(that.settings.addClass);
              }, 0);
            }

            $this.data('truncationDone', true);
            that.settings.onComplete();
          }

          break;
      }
    }

    function removeListItemsMiddle() {
      var that = this;
      var $this = $(this);
      var height;
      var lineHeight = Math.ceil(Math.max($this.children().height(), parseFloat($this.css('line-height'))));
      var maxHeight = this.settings.lines * lineHeight;
      var $seeMore;
      var removedCount = 0;
      var $removedItems;
      var $lastRemoved;
      var visible = !$this.closest(':not(:visible)').length;

      if (this.settings.seeMoreLink) {
        $seeMore = seeMoreMiddleLink.call(this);
      } else {
        $seeMore = ellipsis.call(this, true);
      }

      var removeItems = function () {
        height = $this.height();
        if (!visible) return;

        if (height > maxHeight) {
          while (height > maxHeight && $this.contents().length > 2) {
            $seeMore.remove();

            if ($removedItems && $this.find($removedItems).length) {
              $removedItems.remove();
            }

            var indexToRemove = Math.floor($this.contents().length / 2);
            $lastRemoved = $($this.contents().get(indexToRemove)).remove();

            if ($lastRemoved && $lastRemoved.get(0).nodeType === Node.ELEMENT_NODE) {
              removedCount += 1;
            }

            indexToRemove -= 1;
            height = $this.height();

            if (height > maxHeight && $this.contents().length > 2) {
              $lastRemoved = $($this.contents().get(indexToRemove)).remove();

              if ($lastRemoved && $lastRemoved.get(0).nodeType === Node.ELEMENT_NODE) {
                removedCount += 1;
              }

              indexToRemove -= 1;
            }

            if (that.settings.showRemovedCount && removedCount > 0) {
              $removedItems = removedCountMarkup(removedCount);
              $removedItems.insertAfter($($this.contents().get(indexToRemove)));
            } else {
              $seeMore.insertAfter($($this.contents().get(indexToRemove)));
            }

            height = $this.height();
          }

          setTimeout(removeItems, 500);
        } else {
          if (that.settings.addClass && !$this.hasClass(that.settings.addClass)) {
            setTimeout(function () {
              $this.addClass(that.settings.addClass);
            }, 0);
          }

          $this.data('truncationDone', true);
          that.settings.onComplete();
        }
      };

      removeItems();
    }

    function removeListItemsEnd() {
      var that = this;
      var $this = $(this);
      var height;
      var lineHeight = Math.ceil(Math.max($this.children().height(), parseFloat($this.css('line-height'))));
      var maxHeight = this.settings.lines * lineHeight;
      var $seeMore;
      var removedCount = 0;
      var $removedItems;
      var $lastRemoved;
      var visible = !$this.closest(':not(:visible)').length;

      if (this.settings.seeMoreLink) {
        $seeMore = seeMoreLink.call(this);
      } else {
        $seeMore = ellipsis.call(this);
      }

      var removeItems = function () {
        height = $this.height();
        if (!visible) return;

        if (height > maxHeight) {
          while (height > maxHeight && $this.contents().length > 1) {
            if ($removedItems && $this.find($removedItems).length) {
              $removedItems.remove();
            }

            if ($this.find($seeMore).length) {
              $lastRemoved = $($this.contents().get($this.contents().length - 2)).remove();
            } else {
              $lastRemoved = $this.contents().last().remove();

              if (!that.settings.showRemovedCount) {
                $this.append($seeMore);
              }
            }

            if ($lastRemoved && $lastRemoved.get(0).nodeType === Node.ELEMENT_NODE) {
              removedCount += 1;
            }

            if (that.settings.showRemovedCount && removedCount > 0) {
              $removedItems = removedCountMarkup(removedCount);
              $this.append($removedItems);
            }

            height = $this.height();
          }

          setTimeout(removeItems, 500);
        } else {
          if (that.settings.addClass && !$this.hasClass(that.settings.addClass)) {
            setTimeout(function () {
              $this.addClass(that.settings.addClass);
            }, 0);
          }

          $this.data('truncationDone', true);
          that.settings.onComplete();
        }
      };

      removeItems();
    }

    function removeListItemsBeforeLast() {
      var that = this;
      var $this = $(this);
      var height = $this.height();
      var lineHeight = Math.ceil(Math.max($this.children().height(), parseFloat($this.css('line-height'))));
      var maxHeight = this.settings.lines * lineHeight;
      var $seeMoreLink = seeMoreMiddleLink.call(this);
      var removedCount = 0;
      var $removedItems;
      var $lastRemoved;
      var visible = !$this.closest(':not(:visible)').length;

      var removeItems = function () {
        height = $this.height();
        if (!visible) return;

        if (height > maxHeight) {
          var $lastXItems = $('<div></div>');

          while ($this.children().length > 1 && $lastXItems.children().length < that.settings.lastItemsCount || $this.contents().last().get(0).nodeType === Node.TEXT_NODE) {
            $lastXItems.prepend($this.contents().last().remove());
          }

          var $lastXItemsContent = $lastXItems.contents();

          while (height > maxHeight && $this.children().length > 2) {
            if ($removedItems && $this.find($removedItems).length) {
              $removedItems.remove();
            }

            $seeMoreLink.remove();
            $lastXItemsContent.remove();
            $lastRemoved = $this.contents().last().remove();

            if ($lastRemoved && $lastRemoved.get(0).nodeType === Node.ELEMENT_NODE) {
              removedCount += 1;
            }

            if (that.settings.showRemovedCount && removedCount > 0) {
              $removedItems = removedCountMarkup(removedCount);
              $this.append($removedItems);
            } else {
              $this.append($seeMoreLink);
            }

            $this.append($lastXItemsContent);
            height = $this.height();
          }

          setTimeout(removeItems, 500);
        } else {
          if (that.settings.addClass && !$this.hasClass(that.settings.addClass)) {
            setTimeout(function () {
              $this.addClass(that.settings.addClass);
            }, 0);
          }

          $this.data('truncationDone', true);
          that.settings.onComplete();
        }
      };

      removeItems();
    }

    function removeListItemsBetweenFirstAndLast() {
      var that = this;
      var $this = $(this);
      var $items = $this.children();
      var $seeMore;
      var removedCount = $items.length - 2;
      var $removedItems;

      if ($items.length > 2) {
        if (this.settings.seeMoreLink) {
          $seeMore = seeMoreMiddleLink.call(this);
        } else {
          $seeMore = ellipsis.call(this, true);
        }

        if (that.settings.showRemovedCount) {
          $removedItems = removedCountMarkup(removedCount);
        }

        $this.html('');
        $this.append($items.first());

        if (that.settings.showRemovedCount && removedCount > 0) {
          $this.append($removedItems);
        } else {
          $this.append($seeMore);
        }

        $this.append($items.last());
      }

      $this.data('truncationDone', true);
      that.settings.onComplete();
    }

    function removedCountMarkup(count) {
      return $('<a href="#" class="removed-items-count"> + ' + count + ' </a>');
    }

    function ellipsis(isLink) {
      return $('<' + (isLink ? 'a href="#"' : 'span') + ' class="ellipsis"> ' + this.settings.ellipsisChar + ' </' + (isLink ? 'a' : 'span') + '>');
    }

    function seeMoreLink() {
      var seeMore = ' <span class="ellipsis">' + this.settings.ellipsisChar + '</span> ' + this.settings.seeMoreText + ' <i class=" ' + this.settings.seeMoreIcon + ' "></i>',
          link;

      if (this.settings.seeMoreHtml) {
        seeMore = this.settings.seeMoreHtml;
      } else if (this.settings.isMobile) {
        seeMore = ' <span class="ellipsis">' + this.settings.ellipsisChar + '</span> ' + this.settings.seeMoreText + ' <i class=" ' + this.settings.seeMoreIconMobile + ' "></i>';
      }

      if (this.settings.isMobile && this.isSliding) {
        link = '<a href="#" class="read-more w-slide__btn slide-active" data-slide-target="' + this.settings.mobileTarget + '" aria-expanded="false">' + seeMore + '</a>';
      } else {
        link = '<a href="#" class="read-more" aria-expanded="false">' + seeMore + '</a>';
      }

      if (this.parentTagName === 'UL') {
        link = '<li>' + link + '</li>';
      }

      return $(link);
    }

    function seeMoreMiddleLink() {
      var seeMore = ' <span class="ellipsis">' + this.settings.ellipsisChar + '</span> ' + this.settings.seeMoreText + ' <i class=" ' + this.settings.seeMoreIcon + ' "></i> <span class="ellipsis">' + this.settings.ellipsisChar + '</span> ',
          link;

      if (this.settings.seeMoreHtml) {
        seeMore = this.settings.seeMoreHtml;
      } else if (this.settings.isMobile) {
        seeMore = ' <span class="ellipsis">' + this.settings.ellipsisChar + '</span> ' + this.settings.seeMoreText + ' <i class="' + this.settings.seeMoreIconMobile + '"></i> <span class="ellipsis">' + this.settings.ellipsisChar + '</span> ';
      }

      if (this.settings.isMobile) {
        link = '<a href="#" class="read-more w-slide__btn slide-active " data-slide-target="' + this.settings.mobileTarget + '" aria-expanded="false">' + seeMore + '</a>';
      } else {
        link = '<a href="#" class="read-more" aria-expanded="false">' + seeMore + '</a>';
      }

      if (this.parentTagName === 'UL') {
        link = '<li>' + link + '</li>';
      }

      return $(link);
    }

    function seeLessLink() {
      var seeLess = (this.settings.lessLinkEllipsis ? ' <span class="ellipsis">' + this.settings.ellipsisChar + '</span> ' : ' ') + this.settings.seeLessText + ' <i class="' + this.settings.seeLessIcon + '"></i>',
          link;

      if (this.settings.seeLessHtml) {
        seeLess = this.settings.seeLessHtml;
      }

      link = '<a href="#" class="read-less" aria-expanded="true">' + seeLess + '</a>';

      if (this.parentTagName === 'UL') {
        link = '<li>' + link + '</li>';
      }

      return $(link);
    }

    function addEventHandlers() {
      var that = this;
      var $this = $(this);
      $this.on('touchend mousedown keydown', function (evt) {
        if ($this.data('truncationDone')) {
          var $evtTarget = $(evt.target);

          if ($evtTarget.hasClass('ellipsis') && $evtTarget.is('a')) {
            // ellipsis clicked
            readMore();
          }

          if ($evtTarget.hasClass('read-more') && !$evtTarget.hasClass('w-slide__btn') || $evtTarget.parent().hasClass('read-more') && !$evtTarget.parent().hasClass('w-slide__btn') || $evtTarget.hasClass('removed-items-count')) {
            // "Read more" link clicked
            readMore();
          }

          if ($evtTarget.hasClass('read-less') || $evtTarget.parent().hasClass('read-less')) {
            // "Read less" link clicked
            readLess();
          }
        }

        function readMore() {
          evt.preventDefault();
          $this.data('truncatedContent', $this.html());
          $this.html($this.data('originalContent'));
          var lessLink = seeLessLink.call(that);
          $this.append(lessLink);

          if (evt.keyCode === 13) {
            //Only focus when using keyboard, focus on desktop cause jump issu when the content is large
            if (this.parentTagName === 'UL') {
              lessLink.find('a').focus();
            } else {
              lessLink.focus();
            }
          }
        }

        function readLess() {
          evt.preventDefault();
          $this.html($this.data('truncatedContent'));
          $this.find('.read-more').focus(); //var moreLink = seeMoreLink.call(that);
          //$(evt.target).replaceWith(moreLink);
        }
      });

      if (!$(document).data('activeTabHandlerAdded')) {
        $(document).data('activeTabHandlerAdded', 'yes');
        $(document).on('tabs:changeActiveTab', function (evt, data) {
          setTimeout(function () {
            $('.truncate-delayed', data.tabId).truncate();
          }, 10);
        });
      }
    }

    function addResponsiveHandlers() {
      var that = this;

      function targetViewportOn() {
        that.settings.isMobile = true;
        truncateStart.call(that);
      }

      function targetViewportOff() {
        that.settings.isMobile = false;
        truncateStart.call(that);
      }

      if (this.prevVPort) {
        // remove previous responsive handlers
        $(document).off(this.prevVPort + '-on', targetViewportOn);
        $(document).off(this.prevVPort + '-off', targetViewportOff);
      }

      $(document).on(this.settings.vPort + '-on', targetViewportOn); // Waiting for custom event that will be triggered by controller.js to activate responsive effects

      $(document).on(this.settings.vPort + '-off', targetViewportOff); // Waiting for custom event that will be triggered by controller.js to deactivate responsive effects

      this.prevVPort = this.settings.vPort;
    }

    function truncateStart() {
      var $this = $(this);

      if (this.settings.showRemovedCount) {
        $this.truncate('destroy'); // destroy in case showRemovedCount to get a correct number
      }

      if (this.settings.isMobile && this.settings.targetViewport === 'desktop' || !this.settings.isMobile && this.settings.targetViewport === 'mobile') {
        restoreContent.call(this);
        return;
      }

      if ($this.closest('.tab__pane').length && !$this.closest('.tab__pane').hasClass('active')) {
        $this.addClass('truncate-delayed');
        return;
      } else {
        $this.removeClass('truncate-delayed');
      }

      if (this.settings && this.settings.type === 'text') {
        truncateText.call(this);
      } else if (this.settings && this.settings.type === 'list') {
        this.parentTagName = $this.get(0).tagName;
        truncateList.call(this);
      }
    }

    function restoreContent() {
      var $this = $(this);

      if ($this.data('originalContent')) {
        $this.html($this.data('originalContent'));

        if (this.settings && this.settings.addClass) {
          $this.removeClass(this.settings.addClass);
        }
      }
    }

    methods = {
      init: function (options) {
        return this.each(function () {
          var $this = $(this);
          var firstInit = true;

          if ($this.data('originalContent')) {
            if ($this.data('settings')) {
              this.settings = $this.data('settings');
            }

            restoreContent.call(this);
            firstInit = false;
          } else {
            $this.data('originalContent', $this.html());
          } // read configuration from data attributes


          var dataAttrOptions = {};

          if ($this.data('truncate-lines')) {
            dataAttrOptions.lines = parseInt($this.data('truncate-lines'), 10);
          }

          if ($this.data('truncate-type')) {
            dataAttrOptions.type = $this.data('truncate-type');
          }

          if ($this.data('truncate-position')) {
            dataAttrOptions.position = $this.data('truncate-position');
          }

          if (typeof $this.data('truncate-show-removed-count') !== 'undefined') {
            dataAttrOptions.showRemovedCount = $this.data('truncate-show-removed-count');
          }

          if (typeof $this.data('truncate-see-more-link') !== 'undefined') {
            dataAttrOptions.seeMoreLink = $this.data('truncate-see-more-link');
          }

          if ($this.data('truncate-see-more-text')) {
            dataAttrOptions.seeMoreText = $this.data('truncate-see-more-text');
          }

          if ($this.data('truncate-see-less-text')) {
            dataAttrOptions.seeLessText = $this.data('truncate-see-less-text');
          }

          if ($this.data('truncate-see-more-html')) {
            dataAttrOptions.seeMoreHtml = $this.data('truncate-see-more-html');
          }

          if ($this.data('truncate-see-less-html')) {
            dataAttrOptions.seeLessHtml = $this.data('truncate-see-less-html');
          }

          if ($this.data('truncate-ellipsis-char')) {
            dataAttrOptions.ellipsisChar = $this.data('truncate-ellipsis-char');
          }

          if ($this.data('truncate-last-items-count')) {
            dataAttrOptions.lastItemsCount = parseInt($this.data('truncate-last-items-count'), 10);
          }

          if ($this.data('truncate-mobile-target')) {
            dataAttrOptions.mobileTarget = $this.data('truncate-mobile-target');
          }

          if ($this.data('truncate-add-class')) {
            dataAttrOptions.addClass = $this.data('truncate-add-class');
          }

          if ($this.data('truncate-vport')) {
            dataAttrOptions.vPort = $this.data('truncate-vport');
          }

          if ($this.data('truncate-target-viewport')) {
            dataAttrOptions.targetViewport = $this.data('truncate-target-viewport');
          }

          if (typeof $this.data('truncate-mid-word-enabled') !== 'undefined') {
            dataAttrOptions.midWordEnabled = $this.data('truncate-mid-word-enabled');
          }

          if (typeof $this.data('truncate-less-link-ellipsis') !== 'undefined') {
            dataAttrOptions.lessLinkEllipsis = $this.data('truncate-less-link-ellipsis');
          }

          this.settings = $.extend({}, this.settings || $.fn.truncate.defaults, dataAttrOptions, options || {});
          $this.data('settings', this.settings);
          $this.data('truncationDone', false);
          truncateStart.call(this);

          if (firstInit) {
            addEventHandlers.call(this);
          }

          addResponsiveHandlers.call(this);
        });
      },
      destroy: function () {
        return this.each(function () {
          restoreContent.call(this);
        });
      }
    };

    $.fn.truncate = function (method) {
      if (methods[method]) {
        return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
      } else if (typeof method === 'object' || !method) {
        return methods.init.apply(this, arguments);
      } else {
        $.error('Method ' + method + ' does not exist on jQuery.truncate');
      }
    };
    /* Default truncate settings. */


    $.fn.truncate.defaults = {
      type: 'text',
      // text, list
      position: 'end',
      // end, middle, beforeLast, betweenFirstAndLast
      showRemovedCount: false,
      lines: 1,
      seeMoreLink: false,
      seeMoreText: 'See More',
      seeLessText: 'See Less',
      seeMoreIcon: "icon-section_arrow_d",
      seeLessIcon: "icon-section_arrow_u",
      seeMoreIconMobile: "icon-arrow_r",
      seeMoreHtml: '',
      seeLessHtml: '',
      ellipsisChar: '&hellip;',
      lessLinkEllipsis: false,
      lastItemsCount: 1,
      isMobile: false,
      isSliding: true,
      mobileTarget: '',
      targetViewport: 'all',
      // all, desktop, mobile
      addClass: '',
      vPort: 'screen-sm',
      midWordEnabled: false,
      onComplete: function () {}
    };
  })(jQuery);

  (function () {
    $(document).ready(function () {
      function lazyLoad() {
        $('.lazy-load').remove();
        $('.delayLoad').removeClass('delayLoad').addClass('delayedLoad');
      }

      $('.creative-work__title').not("[data-truncate='none']").truncate({
        lines: 3,
        addClass: 'min-height'
      });
      $('.creative-work .loa').not("[data-truncate='none']").truncate({
        lines: 2,
        type: 'list',
        addClass: 'loa-height'
      });
      $('.featured .grid-item:first-child .creative-work__title').not("[data-truncate='none']").truncate({
        lines: 2,
        addClass: 'min-height'
      });
      $('.card .creative-work__title').not("[data-truncate='none']").truncate({
        lines: 2,
        addClass: 'min-height'
      });
      $('.card .creative-work .loa').not("[data-truncate='none']").truncate({
        lines: 1,
        type: 'list',
        addClass: 'loa-height'
      });
      setTimeout(lazyLoad, 10);
    });
    $(window).on('resized orientationchange', function () {
      $('.creative-work__title, .creative-work .loa').not("[data-truncate='none']").truncate();
    });
  })();

  /* ========================================================================
   * Bootstrap: tab.js v3.3.7
   * http://getbootstrap.com/javascript/#tabs
   * ========================================================================
   * Copyright 2011-2016 Twitter, Inc.
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * ======================================================================== */
  +function ($) {
    // ====================

    var Tab = function (element) {
      // jscs:disable requireDollarBeforejQueryAssignment
      this.element = $(element); // jscs:enable requireDollarBeforejQueryAssignment
    };

    Tab.VERSION = '3.3.7';
    Tab.TRANSITION_DURATION = 150;

    Tab.prototype.show = function () {
      var $this = this.element;
      var $ul = $this.closest('ul:not(.dropdown-menu)');
      var selector = $this.data('target');

      if (!selector) {
        selector = $this.attr('href');
        selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
      }

      if ($this.parent('li').hasClass('active')) return;
      var $previous = $ul.find('.active:last a');
      var hideEvent = $.Event('hide.bs.tab', {
        relatedTarget: $this[0]
      });
      var showEvent = $.Event('show.bs.tab', {
        relatedTarget: $previous[0]
      });
      $previous.trigger(hideEvent);
      $this.trigger(showEvent);
      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return;
      var $target = $(selector);
      this.activate($this.closest('li'), $ul);
      this.activate($target, $target.parent(), function () {
        $previous.trigger({
          type: 'hidden.bs.tab',
          relatedTarget: $this[0]
        });
        $this.trigger({
          type: 'shown.bs.tab',
          relatedTarget: $previous[0]
        });
      });
    };

    Tab.prototype.activate = function (element, container, callback) {
      var $active = container.find('> .active');
      var transition = callback && $.support.transition && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length);

      function next() {
        $active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', false);
        element.addClass('active').find('[data-toggle="tab"]').attr('aria-expanded', true);

        if (transition) {
          element[0].offsetWidth; // reflow for transition

          element.addClass('in');
        } else {
          element.removeClass('fade');
        }

        if (element.parent('.dropdown-menu').length) {
          element.closest('li.dropdown').addClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', true);
        }

        callback && callback();
      }

      $active.length && transition ? $active.one('bsTransitionEnd', next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next();
      $active.removeClass('in');
    }; // TAB PLUGIN DEFINITION
    // =====================


    function Plugin(option) {
      return this.each(function () {
        var $this = $(this);
        var data = $this.data('bs.tab');
        if (!data) $this.data('bs.tab', data = new Tab(this));
        if (typeof option == 'string') data[option]();
      });
    }

    var old = $.fn.tab;
    $.fn.tab = Plugin;
    $.fn.tab.Constructor = Tab; // TAB NO CONFLICT
    // ===============

    $.fn.tab.noConflict = function () {
      $.fn.tab = old;
      return this;
    }; // TAB DATA-API
    // ============


    var clickHandler = function (e) {
      e.preventDefault();
      Plugin.call($(this), 'show');
    };

    $(document).on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler).on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler);
  }(jQuery);

  /**
   * Accessibility plugin for Tabs
   *
   * based over:
   * Bootstrap: tab.js v3.3.7
   * http://getbootstrap.com/javascript/#tabs
   */
  +function ($) {

    var _BS_original_Tab_prototype_activate = $.fn.tab.Constructor.prototype.activate;

    $.fn.tab.Constructor.prototype.activate = function (element, container, callback) {
      // save active now - what was active, same as BS plugin
      var $active = container.find('> .active');
      var transition = callback && $.support.transition && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length); // call original

      _BS_original_Tab_prototype_activate.apply(this, arguments);

      function next() {
        $active.find('[data-toggle="tab"]').attr({
          "aria-selected": false,
          "tabindex": "-1"
        }).removeAttr('aria-expanded');
        element.filter(':not([role="tabpanel"])').find('[data-toggle="tab"]').attr({
          "aria-selected": true,
          "tabindex": "0"
        }).removeAttr('aria-expanded');
        $active.filter('[role="tabpanel"]').removeAttr('tabindex').attr('aria-hidden', true);
        element.filter('[role="tabpanel"]').attr({
          'tabindex': '0',
          'aria-hidden': false
        }) // nested tabs
        .find('.active [data-toggle="tab"]').attr({
          "aria-selected": true,
          "tabindex": "0"
        }).end().find('[data-toggle="tab"]').removeAttr('aria-expanded');
      }

      $active.length && transition ? $active.one('bsTransitionEnd', next) : next();
    };
    /**
     * Key handler for tabs
     * @param {Event} event
     * @return boolean
     */


    var _handleKeyPress = function (event) {
      var keyCodes,
          currentIndex = null;
      keyCodes = {
        DOWN: 40,
        END: 35,
        HOME: 36,
        LEFT: 37,
        RIGHT: 39,
        UP: 38
      }; // do nothing for not allowed keys

      if (!(Object.values(keyCodes).indexOf(event.keyCode) > -1)) return;
      var $this = $(this);
      var $ul = $this.closest('ul:not(.dropdown-menu)');
      var $li = $this.parent('li');
      var $list = $ul.find('li');
      currentIndex = $li.index();
      var prevIndex = currentIndex;
      var tabCount = $list.length;
      var reverse = false; // reverse order

      if ($li.css('direction') === 'rtl') {
        reverse = true;
      }

      function prev() {
        currentIndex--;

        if (currentIndex < 0) {
          currentIndex = tabCount - 1;
        }
      }

      function next() {
        currentIndex++;

        if (currentIndex >= tabCount) {
          currentIndex = 0;
        }
      }

      function end() {
        currentIndex = tabCount - 1;
      }

      function home() {
        currentIndex = 0;
      }

      switch (event.keyCode) {
        case keyCodes.LEFT:
        case keyCodes.UP:
          if (reverse) {
            next();
          } else {
            prev();
          }

          break;

        case keyCodes.END:
          if (reverse) {
            home();
          } else {
            end();
          }

          break;

        case keyCodes.HOME:
          if (reverse) {
            end();
          } else {
            home();
          }

          break;

        case keyCodes.RIGHT:
        case keyCodes.DOWN:
          if (reverse) {
            prev();
          } else {
            next();
          }

          break;

        default:
          currentIndex = null;
      }

      if (currentIndex !== null && prevIndex !== currentIndex) {
        $list.eq(currentIndex).find('[data-toggle="tab"], [data-toggle="pill"]').focus().tab('show');
      } // stop page from scrolling, while we handle navigation in tabs


      return false;
    };

    var _prepareTabAccessibility = function () {
      $('[data-toggle="tab"]').attr({
        "tabindex": "-1",
        "aria-selected": "false"
      }).removeAttr('aria-expanded').parents('.active').find('[data-toggle="tab"]').attr({
        "aria-selected": true,
        "tabindex": "0"
      }).removeAttr('aria-expanded');
      $('[role="tabpanel"]').attr('aria-hidden', true).filter('.active').attr('aria-hidden', false);
    };

    $(document).on('keydown.bs.tab.data-api', '[data-toggle="tab"]', _handleKeyPress).on('keydown.bs.tab.data-api', '[data-toggle="pill"]', _handleKeyPress); // prepare accessibility state

    $(document).ready(_prepareTabAccessibility);
    $(document).on('init.bs.tab', _prepareTabAccessibility);
  }(jQuery);

  (function () {
    var $window = $(window),
        $body = $('body');
    var tab = {
      $target: null,
      $toggle: null,
      $li: null,
      $ul: $('.tab__nav'),
      $previous: null,
      $content: null,
      isTouched: false,
      extraMargin: 25,
      elementvPort: null,
      $controls: null,
      pointerPosition: 0.0,
      cumulativeShift: 0.0,
      vPort: 'screen-sm',
      // default responsive break point
      isSlide: false,
      isMobile: [],
      // variable use to determine if responsive mode is on or off
      backToAccessibility: true,
      // variable use to determine if we want to add back btn to navigate between content and aside
      swipeDisableClass: 'arrows-slide__single--disabled',
      init: function () {
        tab.preselectTab();
        tab.elementvPort = tab.vPort;
        tab.vPort = [];
        var tabElm = $('.tab:not(.tab .tab)'); // in case hierarchical tabs, which is looping inside nested tabs that have the same main tab behavior ex: loi

        tabElm.each(function (index) {
          var _this = $(this);

          tab.check.viewPort(index, _this); // get current view port activator break point

          tab.responsive(index, _this);
        });
        tab.$controls = '<li class=\'arrows-slide\'><i class=\'icon-arrow_l arrows-slide__single prev\'></i> <i class=\'icon-arrow_r arrows-slide__single next\'></i></li>';
        tab.on.build();
        tab.control();
        tab.check.empty();
      },
      preselectTab: function () {
        // The preselectTab function should be cleanup
        // Its better to use query string in url instead session storage for select active tab
        // We should depend on data-target always instead of href because href may contain url not tab-pane selector
        // selection of active tab should tested on nested tabs and multi tabs on page
        $(".tab").each(function () {
          //the rest of this code doesnt seem to support multiple tabs on the page.. but this does
          var _this = $(this);

          if (_this.data('js-preselect') == false) //If you don't need js to select the active tab
            return true;

          var $activeTab = _this.find('.tab__nav').find('li.active a');

          var activeTab = tab.getPaneTarget($activeTab);
          var sessionActiveTab = null;

          if (!activeTab && sessionStorage.activeTab) {
            // check "sessionStorage.activeTab" is solution for LIT-189292
            activeTab = sessionStorage.getItem('activeTab');
            sessionActiveTab = activeTab;
          } // Checking if activeTab contains hash, if not it is not 'tab'


          var hash = activeTab ? activeTab.match(/#/) : null;
          if (activeTab && (!hash || hash.index != 0)) return;

          if (_this.find(activeTab).length == 0) {
            activeTab = null;
          } else if (sessionActiveTab) {
            sessionStorage.setItem('activeTab', '');
          }

          let $firstItem = _this.find('.tab__nav').find('li:first-of-type a');

          if (!activeTab) activeTab = tab.getPaneTarget($firstItem);
          if (activeTab && activeTab.split('#').length < 2 || activeTab == '') return true;
          var triggerTarget = $('[data-target=\'' + activeTab + '\'], [href=\'' + activeTab + '\']');

          if (!triggerTarget.closest('.w-slide__btn').length) {
            // @TODO add condition to apply on while on mobile only, think: is the closest() method really best for the job?
            triggerTarget.click();

            _this.find(activeTab).addClass('active'); // in some cases to display tab content the .active class has to tiggered. Known case: alerts management in profile, when directed to a specific tab.

          }
        });
      },
      control: function () {
        $body.on('click', '.tab-link', function (e) {
          e.preventDefault();
          $(this).attr('data-scroll-back-to', $(document).scrollTop());
          tab.on.select.external($(this));
        });
        $body.on('click', '[data-mobile-toggle="dropdown"] a, .dropblock--tab a', function (e) {
          tab.on.select.dropdown($(this));
          if ($('.js--open[data-db-target-for]').length) UX.dropBlock.on.hide();
        });
        $body.on('click', '.tab__nav a', function () {
          var _this = $(this);

          var tabId = tab.getPaneTarget(_this);
          $(document).trigger('tabs:changeActiveTab', {
            tabId: tabId
          });

          var $parent = _this.parents('.tab');

          if ($parent.hasClass('tab--lazy-load')) {
            if ($(tabId).attr('data-ajaxloaded') != 'true') {
              tab.getContent($(tabId).find('.tab-lazy'));
            }
          }
        });
        $body.on('click touchend', '.arrows-slide .next', function (e) {
          e.preventDefault();
          $activeNav = $(this).closest('.tab__nav').find('.active');
          $activeNavLi = $(this).closest('.tab').find(".tab__content li.active");

          if ($activeNav.next().not('.arrows-slide').length > 0) {
            $activeNav.removeClass('active').next().not('.arrows-slide').addClass('active').show();
            $activeNavLi.removeClass('active').next().addClass('active');

            if (!$activeNav.next().not('.arrows-slide').next().not('.arrows-slide').length) {
              $(this).addClass(tab.swipeDisableClass);
            }

            $(this).closest('.arrows-slide').find('.prev').removeClass(tab.swipeDisableClass);
          }
        });
        $body.on('click touchend', '.arrows-slide .prev', function (e) {
          e.preventDefault();
          $activeNav = $(this).closest('.tab__nav').find('.active');
          $activeNavLi = $(this).closest('.tab').find(".tab__content li.active");

          if ($activeNav.prev().not('.arrows-slide').length > 0) {
            $activeNav.removeClass('active').prev().addClass('active').show();
            $activeNavLi.removeClass('active').prev().addClass('active');

            if (!$activeNav.prev().not('.arrows-slide').prev().not('.arrows-slide').length) {
              $(this).addClass(tab.swipeDisableClass);
            }

            $(this).closest('.arrows-slide').find('.next').removeClass(tab.swipeDisableClass);
          }
        }); // Get postback active tab

        tab.setPostbackActiveTab(tab.getPostbackActiveTab());
        tab.additionalControl();
      },
      additionalControl: function () {},
      responsive: function (index, tabElem) {
        $(document).on(tab.vPort[index] + '-on', function () {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          tab.isMobile[index] = true; //$('[data-slide-target]').addClass('w-slide__btn');
          // $('.tab').each(function () {

          if (tabElem.data('ctrl-res') == tab.vPort[index]) {
            tabElem.addClass('tab--res'); // class will be used in our scss (to replace media queries)

            tab.additionalControl();
            tab.on.rebuild.responsive(tabElem); // rebuild tabs to be responsive
          } // });
          // withArrows.each(function (i, o) {


          if (tabElem.closest('.swipe-with-arrows').length) {
            var tabNav = tabElem.find('.tab__nav');

            if (tabNav.children('li').length > 1) {
              var posIndex = tabNav.children('li.active').index(),
                  length = tabNav.children('li').length,
                  controls = $(tab.$controls);
              tabNav.children('li:not(.active)').hide();

              if (posIndex + 1 == length) {
                // decide which arrow to disable
                controls.find('.next').addClass(tab.swipeDisableClass);
              }

              if (posIndex == 0) {
                controls.find('.prev').addClass(tab.swipeDisableClass);
              }

              tabNav.append(controls);
            }
          } // });

        });
        $(document).on(tab.vPort[index] + '-off', function () {
          // Waiting for custom event that will be triggered by controller.js to deactivate responsive effects
          tab.isMobile[index] = false; // $('.tab').each(function () {

          if (tabElem.data('ctrl-res') == tab.vPort[index]) {
            tabElem.removeClass("tab--res"); // class will be used in our scss (to replace media queries)

            tab.on.rebuild.original($(this)); // return tabs as default
          } // });


          var withArrows = $('.swipe-with-arrows').find('.tab__nav');
          withArrows.children('li').show();
          withArrows.find('.arrows-slide').remove();
        });
      },
      animate: {
        scroll: function ($content, $target) {
          if (!$target.length) return;
          $content.animate({
            scrollTop: $content.scrollTop() + $target.position().top - 40
          }, 600);
        }
      },
      set: {
        target: function ($content, target, temp) {
          if (!$content.find(target).length) {
            tab.$target = $content.find('[data-figure-id=\'' + temp + '\']');
          } else {
            tab.$target = $content.find(target);
          }
        }
      },
      accessibility: {
        /**
         * Accessibility - navigate between content and aside
         * @param elem
         * @param tab
         */
        externalLink: function (elem, tab) {
          // create focusable option for target
          var tabindex = tab.$target.attr('tabindex');
          tab.$target.attr('tabindex', typeof tabindex === 'undefined' ? -1 : tabindex); // create and append back button to content

          var backLink = $('<button class="btn btn--keyboard-accessible">Go back to content</button>');

          if (tab.backToAccessibility) {
            if (tab.$target.is('a, ul, ol, img, table') || tab.$target.is(':input')) {
              tab.$target.after(backLink);
            } else {
              tab.$target.append(backLink);
            } // go back to original element if backbutton is activated


            backLink.on('click', function () {
              elem.focus();
            }).on('focusout', function () {
              $(this).remove();
            });
          } // revert original state on focus out


          tab.$target.on('focusout.tablink', function (event) {
            const $this = $(this); // revert tabindex to original value

            if (typeof tabindex === 'undefined') {
              $this.removeAttr('tabindex');
            } // remove backbutton if user tabbed out of target by some other means than tabbing to backlink


            if (!$(event.relatedTarget).is(backLink) && !$(event.relatedTarget).parents().filter(tab.$target).length) {
              if (backLink.length) backLink.remove();
              $this.off('focusout.tablink');
            }
          }) // provide ESC support for return to content
          .on('keydown.tablink', function (event) {
            const $this = $(this); // on escape, return to control

            if (event.which === 27) {
              $this.off('keydown.tablink');
              elem.focus();
              if (backLink.length) backLink.remove();
            }
          }); // set focus to target

          tab.$target.focus();
        }
      },
      on: {
        select: {
          external: function ($elem) {
            var target = $elem.attr('href'); // get target id

            target = target.split(" ")[0]; //LIT-162636

            tab.$toggle = '#' + $elem.data('tab'); //get target pane

            tab.$li = $('.tab__nav [href="' + tab.$toggle + '"]'); // get target tabs nav

            var temp = target.split("#")[1];
            var parentTab = $(tab.$toggle).closest('.tab');

            var animateScroll = function () {
              tab.$content = $(tab.$toggle).parents(".tab__content");
              if (!tab.$content.length && $elem.is('[data-slide-target]') && $elem.hasClass('slide-active')) tab.$content = $('.w-slide__content');

              if (parentTab.hasClass('tab--res')) {
                tab.isSlide = parentTab.hasClass("tab--slide");

                if (tab.isSlide) {
                  tab.set.target($('.w-slide__content'), target, temp);

                  if (tab.$target.length) {
                    tab.animate.scroll($(".w-slide__content"), tab.$target);
                    tab.$target.attr("tab-index", "1");
                    tab.$target.focus();
                  }
                }
              } else {
                tab.set.target(tab.$content, target, temp);
                tab.animate.scroll(tab.$content, tab.$target);
                tab.accessibility.externalLink($elem, tab);
              }
            };

            if ($(tab.$toggle).is(':visible')) {
              tab.$li.click(); // open target tab

              animateScroll();
            } else {
              if ($(tab.$toggle).hasClass('empty')) {
                $(tab.$toggle).on('content-loaded', function () {
                  animateScroll();
                });
                tab.$li.click(); // open target tab
              } else {
                tab.$li.click(); // open target tab

                animateScroll();
              }
            }
          },
          dropdown: function (elem) {
            var dataAttr = elem.closest('ul').data('mobile-toggle');

            if (dataAttr === 'dropdown' || elem.closest('ul').hasClass('dropblock--tab')) {
              var dropdownContainer = elem.closest('.dropBlock');
              dropdownContainer.children('a').find('span').text(elem.text());
            }
          }
        },
        build: function () {
          //setTimeout(function() {
          tab.$ul.each(function (index) {
            if ($(this).is('.swipe__list')) {
              tab.on.swipeBuild($(this));
            }

            if ($(this).is('.dropblock--tab')) {
              tab.on.dropdownBuild($(this), index);
            }
          }); //}, 200);

          $('.tab--lazy-load').each(function () {
            tab.getContent($(this).find('.tab__pane.active').find('.tab-lazy'));
          });
        },
        calculate: function (elem) {
          var elemParent = elem.parent();
          var tabNavWidth = tab.extraMargin;
          elem.find('li').each(function (index) {
            tabNavWidth += $(this).innerWidth();
          });
          var elemParentWidth = elemParent.width();

          if (elemParentWidth < tabNavWidth) {
            if (!elem.parent().is('.scroll')) {
              tab.on.swipeBuild(elem, tabNavWidth);
            }
          } else {
            tab.on.swipeDestroy(elem);
          }
        },
        swipeBuild: function (elem, tabNavWidth) {
          // rebuild tabs to swipe
          elem.wrap('<div class="swipe__wrapper"><div class="scroll"></div></div>');

          if (!tabNavWidth) {
            var tabNavWidth = tab.extraMargin;
            elem.closest(".tab__pane").css("display", "block");
            elem.find('li').each(function (index) {
              tabNavWidth += $(this).innerWidth();
            });
            elem.closest(".tab__pane").css("display", "");
          }

          elem.width(tabNavWidth);
        },
        swipeDestroy: function (elem) {
          // return tabs to default
          elem.removeAttr('style');
          elem.unwrap('.scroll').unwrap('.swipe__wrapper');
        },
        dropdownBuild: function (elem, index) {
          // rebuild tabs to be as drop down
          if (UX.dropBlock) {
            UX.dropBlock.init();
          }

          elem.wrap('<div class="dropBlock" data-db-parent-of="dbTab-' + index + '"></div>');
          var $dropdownContainer = elem.closest('.dropBlock');
          var $activeTab = elem.find('.active a');
          $dropdownContainer.prepend('<a href="#"class="dropBlock__link" data-db-target-for="dbTab-' + index + '"><span>' + $activeTab.text() + '</span><i class="icon-arrow_d_n" aria-hidden="true"></i></a>');
          elem.attr('data-db-target-of', 'dbTab-' + index);
        },
        dropdownDestroy: function (elem) {
          // return tabs to default
          var dropdownContainer = elem.closest('.dropBlock');
          dropdownContainer.children('a').remove();
          elem.removeAttr('data-db-target-of').removeClass('js--open').removeAttr('style').unwrap('.dropBlock');
        },
        accordionBuild: function (elem) {
          // rebuild tabs to be as accordion
          var $accourdionElem = elem.next('.tab__content');
          $accourdionElem.addClass('accordion-tabbed').wrap('<div class="accordion"></div>');
          elem.find('a').each(function (index) {
            var $lidiv = $(this);
            var liController = tab.getPaneTarget($lidiv);
            $(liController).addClass('accordion-tabbed__tab') // transform tabs structure to accordion structure
            .removeClass('tab__pane').wrapInner('<div class="accordion-tabbed__content"></div>');
            var accordionContrl = $lidiv.clone().prependTo(liController).addClass('accordion-tabbed__control'); // clone tabs controller as accordion controller
          });
          elem.hide();
          UX.accordion.init();
          $('.tab__content.accordion-tabbed .accordion-tabbed__tab').removeClass('js--open').find('.accordion-tabbed__content').hide();
          $('.tab__content.accordion-tabbed .accordion-tabbed__tab.active').addClass('js--open').find('.accordion-tabbed__content').show();
        },
        accordionDestroy: function (elem) {
          // return tabs to default
          elem.next('.accordion').find('.tab__content').removeClass('accordion-tabbed').unwrap('.accordion').find('.accordion-tabbed__tab').each(function (index) {
            var $liDiv = $(this);
            $liDiv.addClass('tab__pane').removeClass('accordion-tabbed__tab js--open');
            var content = $liDiv.find('.accordion-tabbed__content').text();
            $liDiv.html(content);
            elem.show();
          });
          var activeTap = elem.next('.tab__content').find('.active').attr('id');
          elem.find('.active').removeClass('active');
          $('[href="#' + activeTap + '"]').closest('li').addClass('active');
        },
        slideDestroy: function (elem) {
          elem.find('[data-slide-target]').removeClass('w-slide__btn slide-active');
        },
        rebuild: {
          original: function ($elem) {
            // return tabs to be as default
            //$('[data-slide-target]').removeClass('w-slide__btn slide-active');
            tab.$ul = $elem.find('.tab__nav');
            tab.$ul.each(function (index) {
              switch ($(this).data('mobile-toggle') || $(this).closest('[data-mobile-toggle]').data('mobile-toggle')) {
                case 'swipe':
                  tab.on.swipeDestroy($(this));
                  break;

                case 'dropdown':
                  tab.on.dropdownDestroy($(this));
                  break;

                case 'accordion':
                  tab.on.accordionDestroy($(this));
                  break;

                case 'slide':
                  tab.on.slideDestroy($(this));
                  break;

                default:
                /*if ( $(this).closest('.tab').hasClass('tab--flex') ||  $(this).closest('.tab').hasClass('loi') ||  $(this).hasClass('dropblock--tab') || $(this).closest(".advancedSearch__tabs").length ) {
                    return;
                }else {
                    tab.on.calculate($(this));
                }
                */

              }
            });
            $(document).trigger('init.bs.tab');
          },
          responsive: function ($elem) {
            // rebuild tabs to be in selected responsive mode
            tab.$ul = $elem.find('.tab__nav');
            $('.tab__nav').find('[data-slide-target]').addClass('w-slide__btn slide-active');
            tab.$ul.each(function (index) {
              switch ($(this).data('mobile-toggle') || $(this).closest('[data-mobile-toggle]').data('mobile-toggle')) {
                case 'swipe':
                  // rebuild tabs to swipe
                  if (!$(this).parent().is('.scroll')) {
                    tab.on.swipeBuild($(this));
                  }

                  break;

                case 'dropdown':
                  // rebuild tabs be as dropdown
                  if (!$(this).parent().is('.dropBlock')) {
                    tab.on.dropdownBuild($(this), index);
                  }

                  break;

                case 'accordion':
                  // rebuild tabs be as accordion
                  if (!$(this).next().hasClass('accordion')) {
                    tab.on.accordionBuild($(this));
                  }

                  break;

                case 'slide':
                  // rebuild tabs be as accordion
                  break;

                default: // rebuild tabs to flex

                /*if ( $(this).closest('.tab').hasClass('tab--flex') ||  $(this).closest('.tab').hasClass('loi') ||  $(this).hasClass('dropblock--tab') || $(this).closest(".advancedSearch__tabs").length  ) {
                    return;
                }else {
                    tab.on.calculate($(this));
                }*/

              }
            });
            $(document).trigger('init.bs.tab');
          }
        }
      },
      check: {
        empty: function () {
          // check if tab pane is empty and hide it
          $('.tab__nav a').each(function () {
            // go through all tab nav items
            var pane = tab.getPaneTarget($(this)); // get it's related pane

            if ($(this).is('a:not([href^="#"])') || $(this).hasClass('external')) // it is link and has no pane
              return;

            if ($(pane).length && $(pane).is(':empty')) {
              // if tab nav item is not an external link and check if pane is empty
              $(pane).addClass('empty'); // add class to empty pane

              $(this).addClass('empty'); // add class to empty nav item
            }

            if (!$(pane).length) {
              $(this).addClass("empty"); // disable tab nav because it has no pane
            }
          });
        },
        viewPort: function (index, $el) {
          if (typeof $el.data('ctrl-res') != 'undefined' || $el.data('ctrl-res') == '') {
            tab.vPort[index] = $el.data('ctrl-res');
          } else {
            $el.data('ctrl-res', tab.elementvPort);
            tab.vPort[index] = tab.elementvPort;
          }
        }
      },
      getPaneTarget: function ($elem) {
        return $elem.data('target') || $elem.attr('href');
      },
      getPostbackActiveTab: function () {
        var param = 'tabActivePane';
        param = param.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
        var regex = new RegExp("[\\?&]" + param + "=([^&#]*)");
        var results = regex.exec(location.search);
        return results == null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
      },
      setPostbackActiveTab: function (tabID) {
        if (tabID != '') {
          var $activeTabs = $('a[data-simple-tab-id=\'' + tabID + '\']');

          if ($activeTabs.length > 0) {
            $activeTabs.each(function () {
              $activeTabs.trigger('click');
            });
          }
        }
      },
      additionalAjaxSuccess: function () {},
      getContent: function ($elem) {
        var tabId = $elem.attr('data-tabId');
        var widgetId = $elem.attr('data-widgetId');
        var pbContext = encodeURIComponent($('meta[name=pbContext]').attr('content'));
        var $tabBody = $elem.parents('.tab__pane');
        $.ajax({
          url: '/pb/widgets/ux3/lazyTabs/loadTab?pbContext=' + pbContext + '&tabId=' + tabId + '&widgetId=' + widgetId,
          success: function (data) {
            $tabBody.attr('data-ajaxLoaded', 'true');
            $elem.replaceWith(data);

            if ($tabBody.find('.tab__pane.active').find('.tab-lazy').length) {
              tab.getContent($tabBody.find('.tab__pane.active').find('.tab-lazy'));
            }

            tab.additionalAjaxSuccess();
          },
          error: function () {}
        });
      }
    };
    UX.tab = tab; // add to global namespace
  })();

  (function () {
    var $window = $(window),
        $body = $('body');
    var slide = {
      $slide: null,
      $target: null,
      $contents: null,
      $slideinfo: null,
      $toggle: null,
      prev: null,
      isMobile: false,
      vPort: "screen-sm",
      elementvPort: null,
      back: false,
      nested: false,
      multi: false,
      activeSlide: 0,
      oldInfo: [],
      off: null,
      clone: null,
      wait: false,
      backLabel: 'back',
      $elements: null,
      isQueue: false,
      init: function () {
        slide.$slide = '<div class="w-slide"><div class="w-slide_head"><a href="#" class="w-slide__back"><i class=" icon-arrow_l" aria-hidden="true"></i>' + slide.backLabel + '</a><span class="w-slide__title"></span></span></div><div class="w-slide__content"></div></div>';
        slide.$elements = $(slide.$slide);
        var $main = $("main");
        if ($main.length > 0) $main.append(slide.$elements);else $('body').append(slide.$elements);
        slide.$contents = slide.$elements.find('.w-slide__content');
        slide.$slideinfo = slide.$elements.find('.w-slide__title');
        slide.$back = slide.$elements.find('.w-slide__back');
        slide.$toggle = $('.w-slide__btn');
        slide.elementvPort = slide.vPort;
        slide.vPort = [];
        slide.customViewPorts();
        slide.$toggle.each(function (index) {
          slide.check.viewPort($(this), index);
          slide.responsive(index);
        });
        slide.additionalInitialization();
        slide.control();
        slide.additionalControls();

        if (typeof facetDateChart != "undefined") {
          facetDateChart.control();
        }
      },
      additionalInitialization: function () {},
      responsive: function (index) {
        $(document).on(slide.vPort[index] + '-on', function () {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          slide.off = false;
          $('.w-slide__btn').each(function () {
            if ($(this).data('ctrl-res') === slide.vPort[index]) {
              $(this).addClass('slide-active');
            }
          });
        });
        $(document).on(slide.vPort[index] + '-off', function (e) {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          slide.off = true;
          slide.on.off(e);
          $('.w-slide__btn').each(function () {
            if ($(this).data('ctrl-res') === slide.vPort[index]) {
              $(this).removeClass('slide-active');
            }
          });
        });
        $(document).on(slide.elementvPort + '-on', function (e) {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          slide.isMobile = true;
          slide.$elements.css('margin-top', 0);

          if ($('.w-slide.js--open').length) {
            slide.back = true;
            slide.on.hide(e);
          }
        });
        $(document).on(slide.elementvPort + '-off', function (e) {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          slide.isMobile = false;

          if ($('.w-slide.js--open').length) {
            slide.back = true;
            slide.on.hide(e);
          }
        });
        slide.additionalResponsive();
      },
      additionalResponsive: function () {},
      control: function () {
        $body.on('click', '.w-slide__btn', function (e) {
          if (slide.isQueue && slide.isMobile) {
            e.stopImmediatePropagation();
            $(this).off('click');
            return false;
          }

          slide.isQueue = true;

          if ($(this).hasClass('disable')) {
            e.stopPropagation();
            e.preventDefault();
            return;
          }

          if ($(this).hasClass('slide-active')) {
            e.stopPropagation();
            e.preventDefault();
            slide.addTransition();
            slide.$toggle = $(this);
            slide.$target = $(slide.$toggle.data('slide-target'));
            slide.back = false;

            if ($(this).is('[id*=pane-pcw]') && UX.loader.check.empty()) {
              setTimeout(function () {
                slide.on.show(e);
              }, 3000);
            } else {
              slide.on.show(e);
            }
          }
        });
        $body.on('click', '.w-slide__back, .w-slide__hide', function (e) {
          if ($(this).hasClass("w-slide__back")) {
            e.preventDefault();
          }

          slide.back = true;
          slide.on.hide(e);
        });
      },
      additionalControls: function () {},
      addTransition: function () {
        $(".w-slide, .w-slide__content").css('transition', 'all 250ms');
      },
      removeTransition: function () {
        $(".w-slide, .w-slide__content").css('transition', '');
      },
      customViewPorts: function () {
        if ($('.journal-home').length) {
          slide.elementvPort = "screen-md";
        }
      },
      setBackLabel: function () {
        slide.$back.html('<i class=" icon-arrow_l" aria-hidden="true"></i>' + slide.backLabel);
      },
      on: {
        show: function (e) {
          $(document).trigger("UX-detach");

          if (typeof jcf != "undefined") {
            jcf.destroy($(".range-slider__range"));
          }
          /**
           * Fire "open" event
           * this event is Cancelable: which means if e.preventDefault() is called then the slide will not open.
           */


          var openingEvent = $.Event("slide:open");
          $(document).trigger(openingEvent, [slide]);

          if (openingEvent.isDefaultPrevented()) {
            return;
          }

          if ($body.attr('data-active') !== 'undefined') {
            UX.controller.check(e);
          }

          if (slide.$toggle.is('[data-full-screen]') && !slide.$toggle.data('[full-screen]') && !slide.isMobile) $body.addClass('w-slide__not-fullWidth');else $body.removeClass('w-slide__not-fullWidth');
          slide.nested = slide.$toggle.parents(".w-slide__content").length > 0;
          slide.multi = slide.$toggle.closest('.pill-list').length > 0 || slide.$toggle.is('[data-slide-target*=#pill]');

          if (slide.$toggle.closest('.w-slide__pill').length > 0) {
            slide.nested = false;
            slide.multi = true;
          }

          slide.on.additionalShow();
          slide.$slideinfo.hide().removeClass('js--open');
          slide.backLabel = 'back';
          slide.setBackLabel();

          if (slide.nested) {
            slide.activeSlide++;
            slide.$contents.append('<div class="w-slide__content nested--' + slide.activeSlide + '"></div>');
            slide.$contents = $('.nested--' + slide.activeSlide);
          }

          if (slide.multi) {
            if (slide.activeSlide !== 0) {
              slide.back = true;
              slide.on.hide(e);
            }

            slide.activeSlide++;
            slide.$elements.addClass('w-slide__pill').find('.w-slide__content').append('<div class="w-slide__content nested--' + slide.activeSlide + '"></div>');
            slide.$contents = $('.nested--' + slide.activeSlide);
          }

          slide.$contents.attr('original-target', slide.$toggle.data('slide-target'));

          if (slide.$target.hasClass('tab__pane')) {
            slide.$target.closest('.tab__content').find('.tab__pane').removeClass('active');
            slide.$target.addClass('active');
          }

          var label = slide.$toggle.text();

          if (slide.$toggle.is('[data-label]')) {
            label = slide.$toggle.data('label');
          } //LIT-163835


          if (slide.$toggle.hasClass('loa') || slide.$toggle.parents('.loa.mobile-authors').length > 0) {
            label = "AUTHORS";
          }

          var clonedDiv = slide.$target.children();
          slide.on.destroyJcf(clonedDiv);

          if (slide.$toggle.is('[data-slide-clone]')) {
            slide.clone = slide.$toggle.data('slide-clone');

            if (slide.clone === 'self') {
              clonedDiv = slide.$target;
            }
          } else {
            slide.clone = "";
          }

          slide.oldInfo.push(label);
          slide.$slideinfo.html(label);
          var isLoi = slide.$target.find('.loi').length > 0;

          if (isLoi) {
            slide.$contents.append(clonedDiv.html());
            $('.dropBlock-loi__holder .loi').remove();
            slide.$contents.find('.loi__list').each(function () {
              UX.loi.on.recalculate($(this));
            });
          } else {
            if (slide.clone === 'self') {
              if (slide.nested || slide.multi) {
                slide.$target.after('<div class="returnNestedDataSlideHere"></div>');
              } else {
                slide.$target.after('<div class="returnDataSlideHere"></div>');
              }
            } else {
              if (slide.nested || slide.multi) {
                slide.$target.append('<div class="returnNestedDataSlideHere"></div>');
              } else {
                slide.$target.append('<div class="returnDataSlideHere"></div>');
              }
            }

            slide.$contents.append(clonedDiv.clone());

            if ((clonedDiv.hasClass('addthis_toolbox') || clonedDiv.find('.addthis_toolbox').length > 0) && addthis) {
              // re-init social links on mobile
              addthis.toolbox('.addthis_toolbox');
            }

            slide.on.rebuildJcf(slide.$contents);
            clonedDiv.remove();
          } // This is needed for refreshing the google ads iframe
          // because we are cloning it into element
          // for more info:  https://stackoverflow.com/questions/435391/refresh-a-div-that-has-a-google-ad-inside-it/12083756#12083756


          if (typeof googletag !== 'undefined' && typeof googletag.pubads !== 'undefined') {
            googletag.pubads().refresh();
          }

          $body.addClass('lock-screen slide-is-active').attr('data-active', 'slide');
          slide.$back.focus();
          var $coolBar = $('.coolBar');

          if ($coolBar.length) {
            $coolBar.addClass('slide');
          }
          /*
          $('.w-slide__title').truncate({
              lines: 1
          });
          */
          // "opened" event


          var openEvent = $.Event("slide:opened");

          if (slide.wait) {
            setTimeout(function () {
              slide.on._showSlide();

              slide.on.slidePill();
              $(document).trigger(openEvent, [slide]);
            }, 150);
            slide.wait = false;
          } else {
            slide.on._showSlide();

            $(document).trigger(openEvent, [slide]);
          }

          $(document).trigger("UX-attach");
        },
        _showSlide: function () {
          var slideWidth = '100%';
          var $slidedDiv = slide.$elements;

          if (slide.nested || slide.multi) {
            $slidedDiv = slide.$contents;
          }

          if (!slide.$elements.hasClass('js--open') && slide.multi) {
            $slidedDiv = $('[class*=nested--], .w-slide');
          }

          $slidedDiv.css('transform', 'translateX(-' + slideWidth + ')').off().one('transitionend webkitTransitionEnd oTransitionEnd', function (e) {
            e.stopPropagation();
            slide.isQueue = false;
            slide.removeTransition();
          });
          slide.$slideinfo.show().addClass('js--open');
          slide.$elements.addClass('js--open');
          slide.on.additionalShowSlide();
        },
        additionalShow: function () {},
        additionalShowSlide: function () {},
        slidePill: function () {},
        hide: function (e) {
          /**
           * Fire "close" event
           * this event is Cancelable: which means if e.preventDefault() is called then the slide will not close.
           */
          var closingEvent = $.Event("slide:close");
          $(document).trigger(closingEvent, [slide]);

          if (closingEvent.isDefaultPrevented()) {
            return;
          }

          if (typeof e !== "undefined" && $('.w-slide').hasClass('js--open')) {
            var isInsideSlide = $(e.target).closest('.w-slide').length;

            if (!isInsideSlide) {
              slide.back = true;
            }
          }

          if (slide.back) {
            slide.addTransition();
            slide.$slideinfo.hide().removeClass('js--open');
            slide.nested = true;

            if (slide.activeSlide === 0) {
              slide.nested = false;
              slide.$contents = slide.$elements.children('.w-slide__content');
            } else {
              slide.$contents = $('.nested--' + slide.activeSlide);
            }

            slide.on.destroyJcf(slide.$contents);
            var originalTarget = $(slide.$contents.attr('original-target'));

            if (!originalTarget) {
              originalTarget = $body;
            }

            var isLoi = slide.$elements.find('.loi').length > 0;
            slide.on.beforeReturnSlideContent();

            if (isLoi) {
              var $dropBlockHolder = $('.dropBlock-loi__holder');
              $dropBlockHolder.append(slide.$contents.html());
              $dropBlockHolder.find('.loi__list').each(function () {
                UX.loi.on.recalculate($(this));
              });
            } else {
              if (slide.$contents.find('[class*=nested--]').length) {
                slide.$contents.find('[class*=nested--]').remove();
              }

              if (slide.clone === 'self') {
                if (slide.nested || slide.multi) {
                  var $returnNestedDataSlideHere = $('.returnNestedDataSlideHere');
                  $returnNestedDataSlideHere.after(slide.$contents.html());
                  $returnNestedDataSlideHere.remove();
                } else {
                  var $returnDataSlideHere = $('.returnDataSlideHere');
                  $returnDataSlideHere.after(slide.$contents.html());
                  $returnDataSlideHere.remove();
                }
              } else {
                if (slide.nested || slide.multi) {
                  $('.returnNestedDataSlideHere', originalTarget).after(slide.$contents.html());
                  $('.returnNestedDataSlideHere', originalTarget).remove();
                } else {
                  $('.returnDataSlideHere', originalTarget).after(slide.$contents.html());
                  $('.returnDataSlideHere', originalTarget).remove();
                }
              }

              slide.on.rebuildJcf(originalTarget);
            }

            slide.oldInfo.splice(slide.activeSlide, 1);
            slide.$slideinfo.html(slide.oldInfo[slide.activeSlide - 1]);

            if (slide.$toggle) {
              slide.$toggle.focus();
            }

            if (slide.nested) {
              slide.activeSlide--;

              slide.on._hideSlide();

              if (slide.multi) {
                slide.$contents.remove();
              }

              slide.$contents = $('.nested--' + slide.activeSlide);

              if (slide.activeSlide === 0) {
                slide.$contents = slide.$elements.children('.w-slide__content');
              }
            } else {
              slide.activeSlide = 0;
              $('body, html').removeClass('lock-screen');
              $body.removeClass('lock-screen slide-is-active').removeAttr('data-active');
              var $coolBar = $('.coolBar');

              if ($coolBar.length) {
                $coolBar.removeClass('slide');
              }

              slide.on._hideSlide();

              slide.$elements.removeClass('js--open');
            }

            slide.$slideinfo.show().addClass('js--open');
            slide.backLabel = 'back';
            slide.setBackLabel();
            slide.on.additionalHide(e);

            if (slide.$elements.hasClass('w-slide__pill')) {
              while (slide.activeSlide > 0) {
                slide.activeSlide--;
                slide.on.hide(e);
              }

              if (typeof e !== "undefined" && ($(e.target).hasClass('w-slide__back') || $(e.currentTarget).hasClass('w-slide__back')) && slide.activeSlide === 0) {
                slide.on.off(e);
              }
            }

            if (!isInsideSlide && !(typeof e !== "undefined" && $(e.target).closest('.pill-list').length)) {
              slide.on.off(e);
            }

            slide.removeTransition();
          } // This is needed for refreshing the google ads iframe
          // because we are cloning it into element
          // for more info:  https://stackoverflow.com/questions/435391/refresh-a-div-that-has-a-google-ad-inside-it/12083756#12083756


          if (typeof googletag !== 'undefined' && typeof googletag.pubads !== 'undefined') {
            googletag.pubads().refresh();
          } // "closed" event


          var closeEvent = $.Event("slide:closed");
          $(document).trigger(closeEvent, [slide]);
        },
        _hideSlide: function () {
          var updateTarget = slide.$elements;
          if (slide.nested) updateTarget = slide.$contents;
          updateTarget.css('transform', 'translateX(0vw)').off().one('transitionend webkitTransitionEnd oTransitionEnd', function (e) {
            e.stopPropagation();
            if (slide.back) if (!slide.nested) slide.$contents.empty();else $(this).remove();
          });
        },
        additionalHide: function (e) {},
        beforeReturnSlideContent: function () {},
        off: function (e) {
          slide.$slideinfo.hide().removeClass('js--open');
          $('.pill-section').removeClass('js--open');
          $('.pill-list li').removeClass('pill-active');
          var isLoi = slide.$elements.find('.loi').length > 0;

          if (isLoi) {
            slide.$contents = $('.loi').closest('.w-slide__content');
            var $dropBlockHolder = $('.dropBlock-loi__holder');
            $dropBlockHolder.append(slide.$contents.html());
            $dropBlockHolder.find('.loi__list').each(function () {
              UX.loi.on.recalculate($(this));
            });
          }

          $('body, html').removeClass('lock-screen');
          $body.removeClass('lock-screen slide-is-active').removeAttr('data-active');
          $('.coolBar').removeClass('slide');
          slide.$contents = slide.$elements.children('.w-slide__content');
          slide.$elements.css('transform', 'translateX(0vw)').off().one('transitionend webkitTransitionEnd oTransitionEnd', function (e) {
            e.stopPropagation();
            slide.$elements.removeClass('js--open');

            if (slide.off) {
              $('.w-slide').removeClass('w-slide__pill');
              slide.$contents.empty();
            }
          });
          slide.off = false;
          slide.on.additionalOff(e);
        },
        additionalOff: function (e) {},
        destroyJcf: function ($el) {
          if (typeof jcf != "undefined") {
            jcf.destroy($el.find('.jcf'));
          }
        },
        rebuildJcf: function ($el) {
          if (typeof jcf != "undefined") {
            jcf.replace($el.find('.jcf'));
          }
        }
      },
      check: {
        viewPort: function ($el, index) {
          if (typeof $el.data('ctrl-res') !== 'undefined') {
            slide.vPort[index] = $el.data('ctrl-res');
          } else {
            $el.data('ctrl-res', slide.elementvPort);
            slide.vPort[index] = slide.elementvPort;
          }
        }
      }
    };
    UX.slide = slide; // add to global namespace
  })();

  (function () {
    var datepicker = {
      dateFormat: "yy-mm-dd",
      $datepicker: $(".datepicker"),
      $body: $('body'),
      lastModfied: '',
      vPort: '',
      init: function () {
        // IF native support is not present, use jQuery datepicker on every type=date input
        if (!UX.test.inputDate()) {
          datepicker.$datepicker = datepicker.$datepicker.add($('[type=date]'));
        }

        datepicker.$datepicker.each(function () {
          var $element = $(this);
          var data = $element.data();

          if (typeof $element.datepicker !== 'undefined') {
            $element.datepicker({
              dateFormat: data.dateFormat ? data.dateFormat : datepicker.dateFormat // custom date format from data-attr or default one

            }); //set the alt field & the alt format if exist

            if (data.altFieldName) {
              $element.datepicker("option", "altField", '[name="' + data.altFieldName + '"]');
              $element.datepicker("option", "altFormat", datepicker.dateFormat);
            }
          }
        });
      }
    };
    UX.datepicker = datepicker; // add to global namespace
  })();

  (function () {
    var editInPlace = {
      $editables: null,
      editable: null,
      editableInput: null,
      editableText: null,
      target: null,
      targetInput: null,
      targetText: null,
      CLASS_HIDDEN: "__hidden",
      vPort: 'all',
      // the view port to make the edit in place work above
      isMobile: null,
      emptyPlaceholder: "Click to edit",
      init: function () {
        this.editable = ".js-editable";
        this.editableInput = ".js-editable__input";
        this.editableText = ".js-editable__text";
        this.$editables = $(this.editable);
        $.each(this.$editables, function (i, item) {
          if ($(item).find(editInPlace.editableText).text() == "") {
            $(item).find(editInPlace.editableText).text(editInPlace.emptyPlaceholder);
          }
        });
        editInPlace.controller();
        editInPlace.responsive();
      },
      responsive: function () {
        if (editInPlace.vPort !== "all") {
          $(document).on(editInPlace.vPort + '-off', function () {
            // Waiting for custom event that will be triggered by controller.js to deactivate responsive effects
            if (editInPlace.isMobile === null || editInPlace.isMobile === true) {
              editInPlace.controller();
            }

            editInPlace.isMobile = false;
          });
          $(document).on(editInPlace.vPort + '-on', function () {
            // Waiting for custom event that will be triggered by controller.js to activate responsive effects
            if (editInPlace.isMobile === null || editInPlace.isMobile === false) {
              editInPlace.disable();
            }

            editInPlace.isMobile = true;
          });
        }
      },
      controller: function () {
        editInPlace.$editables.on('click', editInPlace.editableText, editInPlace.on.show);
      },
      disable: function () {
        editInPlace.$editables.off('click', editInPlace.editableText, editInPlace.on.show);
      },
      on: {
        show: function (event) {
          event.stopPropagation();
          editInPlace.on.hideAll();
          editInPlace.target = $(event.currentTarget).closest(editInPlace.editable);
          editInPlace.targetText = editInPlace.target.find(editInPlace.editableText);
          editInPlace.targetInputContainer = editInPlace.target.find(editInPlace.editableInput);
          editInPlace.targetInput = editInPlace.targetInputContainer.is("input, textarea") ? editInPlace.targetInputContainer : editInPlace.targetInputContainer.find("input, textarea");
          editInPlace.targetText.addClass(editInPlace.CLASS_HIDDEN);
          editInPlace.target.addClass('js--open'); // auto height for text area

          if (editInPlace.targetInput.is("textarea")) {
            editInPlace.targetInput.height(5);
            editInPlace.targetInput.height(editInPlace.targetInput[0].scrollHeight);
          }

          editInPlace.targetInput.focus(); // hack to have cursor at the end of text in input

          /**
           * WHY THIS HACK! I don't know
           var tmpStr = editInPlace.targetInput.val();
           editInPlace.targetInput.val('');
           editInPlace.targetInput.val(tmpStr);
           **/
          // end of hack

          editInPlace.targetInput.on('keyup', function (event) {
            event.stopPropagation();
            var keycode = event.keyCode;

            switch (keycode) {
              case 9:
              case 13:
                editInPlace.on.save();
                break;

              case 27:
                editInPlace.on.cancel();
                break;

              default:
                // auto height for text area
                if (editInPlace.targetInput.is("textarea")) {
                  editInPlace.targetInput.height(5);
                  editInPlace.targetInput.height(editInPlace.targetInput[0].scrollHeight);
                }

                return;
            }
          }); //editInPlace.targetInput.on('blur', editInPlace.on.save);

          editInPlace.targetInputContainer.on('click', ".btn-save", function (e) {
            e.preventDefault();
            editInPlace.on.save();
          });
          $(document).on('click', editInPlace.on.clickOutside);
        },
        cancel: function () {
          editInPlace.targetInput.val(editInPlace.targetText.text());
          editInPlace.on.hide();
        },
        save: function () {
          var evt = $.Event('editInPlace:onSave');
          editInPlace.target.trigger(evt);
          if (evt.isDefaultPrevented()) return false;
          editInPlace.targetText.text(editInPlace.targetInput.val());
          editInPlace.targetText.attr("title", editInPlace.targetInput.val());
          editInPlace.on.hide();
        },
        hide: function () {
          editInPlace.target.removeClass('js--open');
          editInPlace.targetText.removeClass(editInPlace.CLASS_HIDDEN);
          editInPlace.targetInput.off('blur', editInPlace.on.blur);
          editInPlace.targetInputContainer.off('click');
          $(document).off('click', editInPlace.on.clickOutside);
        },
        clickOutside: function (e) {
          if (!$(e.target).closest(editInPlace.editable + ".js--open").length) editInPlace.on.hideAll();
        },
        hideAll: function () {
          editInPlace.$editables.filter('.js--open').each(function () {
            editInPlace.target = $(this).closest(editInPlace.editable);
            editInPlace.targetText = $(editInPlace.target).find(editInPlace.editableText);
            editInPlace.targetInputContainer = $(editInPlace.target).find(editInPlace.editableInput);
            editInPlace.targetInput = editInPlace.targetInputContainer.is("input, textarea") ? editInPlace.targetInputContainer : editInPlace.targetInputContainer.find("input, textarea");
            editInPlace.on.save();
          });
        }
      }
    };
    UX.editInPlace = editInPlace; // add to global namespace
  })();

  (function () {
    var charCounter = {
      $counters: null,
      counter: null,
      counterInput: null,
      counterOutput: null,
      $target: null,
      $targetInput: null,
      $argetOutput: null,
      maxlength: null,
      init: function () {
        this.counter = ".js-counter";
        this.counterInput = ".js-counter__input";
        this.counterOutput = ".js-counter__output";
        this.$counters = $(this.counterInput);
        charCounter.controller();
      },
      controller: function () {
        $.each(this.$counters, function (i, item) {
          $(item).closest(charCounter.counter).find(charCounter.counterOutput).html($(item).attr("data-maxchars") - $(item).val().length);
        });
        charCounter.$counters.on('focus', charCounter.on.focus);
      },
      on: {
        focus: function (event) {
          charCounter.$targetInput = $(event.currentTarget);
          charCounter.$targetOutput = charCounter.$targetInput.closest(charCounter.counter).find(charCounter.counterOutput);
          charCounter.$targetInput.on('keyup change', charCounter.on.count);
          charCounter.$targetInput.on('blur', charCounter.on.blur);
          charCounter.maxlength = charCounter.$targetInput.attr("data-maxchars");
          charCounter.on.count();
        },
        blur: function () {
          charCounter.$targetInput.off('keyup', charCounter.on.count);
        },
        count: function () {
          var inputVal = charCounter.$targetInput.val();
          var inputLength = inputVal.length;
          var left = charCounter.maxlength - inputLength;

          if (inputLength > charCounter.maxlength) {
            charCounter.$targetInput.val(inputVal.substr(0, charCounter.maxlength));
            left = 0;
          }

          charCounter.$targetOutput.text(left);
        }
      }
    };
    UX.charCounter = charCounter; // add to global namespace
  })();

  (function () {
    var sortableTableRow = {
      $tableBody: $(".sortable-table tbody"),
      init: function () {
        if (typeof sortableTableRow.$tableBody.sortable !== 'undefined') {
          sortableTableRow.$tableBody.sortable({
            handle: '.btn--handle',
            items: 'tr.sortable-row',
            stop: sortableTableRow.afterStopSortRow,
            axis: 'y'
          });
        }
      },
      controller: function () {},
      afterStopSortRow: function (event, ui) {
        if ($(".submission-authors").length > 0) {
          var $authorsRows = ui.item.closest(".authors__table").find(".author__row");
          $authorsRows.each(function (index) {
            $(this).find("input.author__order").val(index);
          });
        }
      }
    };
    UX.sortableTableRow = sortableTableRow; // add to global namespace
  })();

  /**
   * Polyfill to support matches on IE9+
   *
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill}
   */
  if (!Element.prototype.matches) Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

  /**
   * Polyfill for Element.closest()
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill}
   */
  if (!Element.prototype.closest) Element.prototype.closest = function (s) {
    var el = this;
    if (!document.documentElement.contains(el)) return null;

    do {
      if (el.matches(s)) return el;
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1);

    return null;
  };

  /**
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove#Polyfill}
   */
  (function (arr) {
    arr.forEach(function (item) {
      if (item.hasOwnProperty('remove')) {
        return;
      }

      Object.defineProperty(item, 'remove', {
        configurable: true,
        enumerable: true,
        writable: true,
        value: function remove() {
          if (this.parentNode !== null) this.parentNode.removeChild(this);
        }
      });
    });
  })([Element.prototype, CharacterData.prototype, DocumentType.prototype]);

  /**
   * {@link https://gist.github.com/darthwade/9310975}
   */
  if (!String.prototype.format) {
    String.prototype.format = function () {
      var args = arguments;
      return this.replace(/{(\d+)}/g, function (match, number) {
        return typeof args[number] != 'undefined' ? args[number] : match;
      });
    };
  }

  /**
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill}
   */
  if (typeof Object.assign != 'function') {
    // Must be writable: true, enumerable: false, configurable: true
    Object.defineProperty(Object, "assign", {
      value: function assign(target, varArgs) {

        if (target == null) {
          // TypeError if undefined or null
          throw new TypeError('Cannot convert undefined or null to object');
        }

        var to = Object(target);

        for (var index = 1; index < arguments.length; index++) {
          var nextSource = arguments[index];

          if (nextSource != null) {
            // Skip over if undefined or null
            for (var nextKey in nextSource) {
              // Avoid bugs when hasOwnProperty is shadowed
              if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }

        return to;
      },
      writable: true,
      configurable: true
    });
  }

  /**
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill}
   */
  (function () {
    if (typeof window.CustomEvent === "function") return false; //If not IE

    function CustomEvent(event, params) {
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: undefined
      };
      var evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    }

    CustomEvent.prototype = window.Event.prototype;
    window.CustomEvent = CustomEvent;
  })();

  //

  var constants = {
    GLOBAL_ERR: 0,
    FILES_ERR: 1,
    UPLOAD_ERR: 2
  };
  var methods = {
    trigger: function (element, event) {
      var theEvent;

      if (typeof event === "string") {
        theEvent = document.createEvent("Event");
        theEvent.initEvent(event, false, true);
      } else if (event instanceof Event) {
        theEvent = event;
      } else return;

      element.dispatchEvent(theEvent);
    },
    fadeOut: function (el, callback) {
      el.style.opacity = 1;
      var last = +new Date();

      var tick = function () {
        el.style.opacity = +el.style.opacity - (new Date() - last) / 400;
        last = +new Date();

        if (+el.style.opacity > 0) {
          window.requestAnimationFrame && requestAnimationFrame(tick) || setTimeout(tick, 16);
        } else {
          callback();
        }
      };

      tick();
    },
    truncate: function (fullStr, strLen, separator) {
      if (fullStr.length <= strLen) return fullStr;
      separator = separator || '...';
      var sepLen = separator.length,
          charsToShow = strLen - sepLen,
          frontChars = charsToShow - 7,
          backChars = 7;
      return fullStr.substr(0, frontChars) + separator + fullStr.substr(fullStr.length - backChars);
    },
    fileExtension: function (filename) {
      var parts = filename.split('.');
      return parts[parts.length - 1];
    },
    fileNameTruncated: function (filename) {
      return methods.truncate(this.file.name, 53);
    },
    fileSizeHuman: function (size) {
      var e = Math.log(size) / Math.log(1e3) | 0;
      return +(size / Math.pow(1e3, e)).toFixed(1) + ' ' + ('kMGTPEZY'[e - 1] || '') + 'B';
    },
    delay: function () {
    }
  };
  var utils$1 = {
    constants: constants,
    methods: methods
  };

  /**
   * Uploaded File Validation Exception
   *
   * @param message
   * @param type
   * @param item
   * @constructor
   */

  function ValidationException(message, type, item) {
    this.message = message;
    this.type = type;
    this.item = item;
  }

  ValidationException.prototype.isGlobalError = function () {
    return this.type === constants.GLOBAL_ERR;
  };

  /**
   * Uploader File Item
   * @param {File|string} file
   * @param {number} index
   * @constructor
   */

  function UploaderFile(file, index) {
    /**
     * Unique identifier for this file
     * @type {number}
     */
    this.index = index;
    /**
     * File Object to be uploaded
     * @type {File|string}
     */

    this.file = file;
    /**
     * Current state
     * @type {string}
     */

    this.state = 'uploading';
    /**
     *
     * @type {XMLHttpRequest|null}
     */

    this.request = null;
  }

  UploaderFile.prototype = {
    constructor: UploaderFile,

    /**
     * Get index of the file
     * @returns {number}
     */
    getIndex: function () {
      return this.index;
    },

    /**
     * Get the file object itself
     * @returns {File}
     */
    getFile: function () {
      return this.file;
    },

    /**
     * get the file size
     * @returns {number}
     */
    fileSize: function () {
      return this.file.size;
    },

    /**
     * get file size in human readable format
     * @returns {*}
     */
    fileSizeHuman: function () {
      return utils$1.methods.fileSizeHuman(this.file.size);
    },

    /**
     * get the file name
     * @returns {string}
     */
    fileName: function () {
      if (typeof this.file === "string") return this.file;
      return this.file.name;
    },

    /**
     *
     * @param {int} [numberOfChar]
     * @returns {string}
     */
    fileNameTruncated: function (numberOfChar) {
      return utils$1.methods.truncate(this.file.name, numberOfChar || 53);
    },

    /**
     * Get the extension of the file
     * @returns {string}
     */
    fileExtension: function () {
      return utils$1.methods.fileExtension(this.file.name);
    },

    getType() {
      return this.file.type;
    },

    /**
     * Set upload AJAX request
     * @param {XMLHttpRequest} xhr
     */
    setRequest: function (xhr) {
      this.request = xhr;
    },

    /**
     * Get upload AJAX request
     * @returns {XMLHttpRequest}
     */
    getRequest: function () {
      return this.request;
    },

    /**
     * Stop uploading operation, cancels the HTTP request
     */
    abort: function () {
      if (this.request) this.request.abort();
    },

    /**
     * Update the current state of the uploading file
     * @param {string} newState
     */
    setState: function (newState) {
      this.state = newState;
    },

    /**
     * Get the current state of the uploading file
     * @returns {string}
     */
    getState: function () {
      return this.state;
    }
  };

  /**
   * Default plugin options
   * @type {object}
   */

  var defaultOptions = {
    input: 'input[type=file]',
    multiple: false,
    allowed: false,
    skipMtypeCheck: [],
    maxFiles: 1,
    maxSize: false,
    dropzone: '.uploader__dropzone',
    previousFilesCount: 0,
    handlers: {},
    strings: {
      fileTypeError: "File type is not supported. Please cancel and try again.",
      uploadError: "Error uploading file. Please cancel and try again.",
      uploadLimitError: "No more than {0} can be uploaded.",
      fileSizeError: "File size exceeds {0} limit. Please cancel and try again."
    }
  };
  /**
   * Prefix for console errors in this plugins
   * @type {string}
   */

  var errorsPrefix = "AjaxUploader Error: ";
  /**
   * Helper function to log errors with prefix
   * @param {string} msg
   */

  function die(msg) {
    console.error(errorsPrefix + msg);
  }
  /**
   * workaround for exceptions
   */


  var BreakException = {};
  /**
   *
   * @param {Element|string|jQuery} element
   * @param {object} [options]
   * @constructor
   */

  function AjaxUploader(element, options) {
    if (!element) return die('No element is provided');
    this.element = this.parseElement(element);
    if (!this.element) return die('No element is provided'); // Build plugin options

    if (!this.buildOptions(options)) return;
    this.uploadedFiles = [];
    this.initialize();
  }

  AjaxUploader.prototype = {
    constructor: AjaxUploader,

    /**
     * Get DOM Element from css selector or jQuery or DOM element
     * @param {Element|string|jQuery} element
     * @returns {Element}
     * @private
     */
    parseElement: function (element) {
      if (!element) return false;
      if (element instanceof Element) // Element is provided
        return element;else if (element instanceof jQuery) // jQuery object is provided
        return element[0];else if (typeof element === "string") // Selector provided
        return this.element.querySelector(element);
      return false;
    },

    /**
     * Build Plugin attributes
     * @param options
     * @returns {void|boolean}
     * @private
     */
    buildOptions: function (options) {
      options = Object.assign(defaultOptions, options); // Make sure input is provided

      if (this.getInputFromOptions(options) !== true) return false; // Make sure ajax url is provided

      if (this.getAjaxUrlFromOptions(options) !== true) return false; // Get drop zone

      this.getDropAreaFromOptions(options);
      var dataset = this.input.dataset;
      this.multiple = this.input.multiple || options.multiple;
      this.maxFiles = dataset.maxFiles || options.maxFiles ? parseInt(dataset.maxFiles || options.maxFiles) : false;
      this.maxSize = dataset.maxSize || options.maxSize ? parseInt(dataset.maxSize || options.maxSize) : false;
      this.filesCount = parseInt(dataset.previousFilesCount || options.previousFilesCount);
      var allowed = dataset.allowed || options.allowed;
      if (typeof allowed === "string") this.allowedTypes = allowed.split(',');else if (Array.isArray(allowed)) this.allowedTypes = allowed;
      /**
       * Skip mime type checks
       * An array of file types to be validated by extension only, without mime type check
       */

      var skipMtypeCheck = dataset.skipMtypeCheck || options.skipMtypeCheck;
      if (typeof skipMtypeCheck === "string") this.skipMtypeCheck = skipMtypeCheck.split(',');else if (Array.isArray(skipMtypeCheck)) this.skipMtypeCheck = skipMtypeCheck; // set handlers

      this.handlers = options.handlers;
      this.strings = options.strings;
      return true;
    },

    /**
     *
     * @param options
     * @returns {void|boolean}
     * @private
     */
    getInputFromOptions: function (options) {
      this.input = this.parseElement(options.input); // if still cannot find the input then plugin breaks

      if (!this.input || !this.input.matches("input[type=file]")) return die('Invalid input provided');
      return true;
    },

    /**
     *
     * @param options
     * @returns {void|boolean}
     * @private
     */
    getAjaxUrlFromOptions: function (options) {
      if (!this.input.dataset.ajaxUrl && !options.ajax) return die('Ajax url is not provided');
      this.ajax = {};

      if (this.input.dataset.ajaxUrl) {
        this.ajax.url = this.input.dataset.ajaxUrl;
      } else if (typeof options.ajax === "string") {
        this.ajax.url = options.ajax;
      } else if (typeof options.ajax === "object") {
        if (!options.ajax.url) return die('Ajax url is not provided');
        this.ajax = options.ajax;
      }

      if (this.input.dataset.ajaxData) {
        this.ajax.data = JSON.parse(this.input.dataset.ajaxData);
      }

      return true;
    },

    /**
     *
     * @param options
     * @private
     */
    getDropAreaFromOptions: function (options) {
      this.dropArea = this.parseElement(options.dropzone);

      if (!this.dropArea) {
        this.dropArea = this.element;
      }
    },

    /**
     * Initialize uploader events
     * @protected
     */
    initialize: function () {
      var _this = this; // automatically submit the uploader on file select


      this.input.addEventListener('change', function (e) {
        _this.processFiles(e.target.files);
      });

      if (this.dropArea) {
        // drag&drop files if the feature is available
        ['drag', 'dragstart', 'dragend', 'dragover', 'dragenter', 'dragleave', 'drop'].forEach(function (event) {
          _this.dropArea.addEventListener(event, function (e) {
            // preventing the unwanted behaviours
            e.preventDefault();
            e.stopPropagation();
          });
        });
        ['dragover', 'dragenter'].forEach(function (event) {
          _this.dropArea.addEventListener(event, function () {
            _this.dropArea.classList.add('is-dragover');
          });
        });
        ['dragleave', 'dragend', 'drop'].forEach(function (event) {
          _this.dropArea.addEventListener(event, function () {
            _this.dropArea.classList.remove('is-dragover');
          });
        });
        this.dropArea.addEventListener('drop', function (e) {
          _this.processFiles(e.dataTransfer.files);
        });
      }
    },

    /**
     * On selecting/dropping files
     * @param {FileList} files
     * @protected
     */
    processFiles: function (files) {
      var _this = this;

      if (typeof this.handlers.start === "function") this.handlers.start(this);
      this.currentQueueLength = 0;
      var startIndexWith = _this.filesCount;

      try {
        // Check for files limit first
        this.currentQueueLength = files.length;
        Array.prototype.forEach.call(files, function (file, index) {
          _this.validateNumberOfFiles(); // Create object for the file


          var item = new UploaderFile(file, startIndexWith + index);
          if (typeof _this.handlers.beforeUpload === "function") _this.handlers.beforeUpload(_this, item); // Validate the file

          try {
            _this.validateFile(item);

            _this.filesCount++; // increment files count if file is validated
          } catch (ex) {
            if (typeof _this.handlers.validationError === "function") _this.handlers.validationError(_this, ex, item);
            if (typeof _this.handlers.complete === "function") _this.handlers.complete(_this, item);
            return;
          } // Upload the file


          _this.uploadFile(item);

          _this.currentQueueLength--;
        });
      } catch (ex) {
        if (ex instanceof ValidationException) {
          if (typeof _this.handlers.validationError === "function") _this.handlers.validationError(_this, ex);
        } else if (ex !== BreakException) throw ex;
      }
    },

    /**
     * Validate if the dropped files are less than maximum allowed
     * @protected
     */
    validateNumberOfFiles: function () {
      if (this.maxFiles && this.filesCount + 1 > this.maxFiles) {
        var str;
        if (this.maxFiles === 1) str = this.maxFiles + " file";else str = this.maxFiles + " files";
        throw new ValidationException(this.strings.uploadLimitError.format(str), utils$1.constants.GLOBAL_ERR);
      }
    },

    /**
     * Validate File before queueing it
     * @param {UploaderFile} item
     * @throws ValidationException
     * @protected
     */
    validateFile: function (item) {
      // check upload limit (again)
      if (this.maxFiles > 0 && this.filesCount >= this.maxFiles) {
        var str;
        if (this.maxFiles === 1) str = this.maxFiles + " file";else str = this.maxFiles + " files";
        item.setState('upload-error');
        throw new ValidationException(this.strings.uploadLimitError.format(str), utils$1.constants.GLOBAL_ERR);
      } // check file type


      this.validateType(item); // check file size

      this.validateSize(item);
      return true;
    },

    /**
     * @param {UploaderFile} item
     * @throws ValidationException
     * @protected
     */
    validateType(item) {
      // if exist in skip mime type check then return
      const extension = item.fileExtension();
      if (this.skipMtypeCheck.length && this.skipMtypeCheck.indexOf(extension) !== -1) return; // check mime type

      const type = item.getType();

      if (this.allowedTypes && this.allowedTypes.indexOf(type) === -1) {
        item.setState('files-error');
        const allowed = this.allowedTypes.join(', ');
        const errType = this.multiple ? utils$1.constants.FILES_ERR : utils$1.constants.GLOBAL_ERR;
        throw new ValidationException(this.strings.fileTypeError.format(allowed), errType);
      }
    },

    /**
     * @param {UploaderFile} item
     * @throws ValidationException
     * @protected
     */
    validateSize(item) {
      const fileSize = item.fileSize();

      if (this.maxSize && fileSize > this.maxSize) {
        const maxSizeHuman = utils$1.methods.fileSizeHuman(this.maxSize);
        item.setState('files-error');
        const errType = this.multiple ? utils$1.constants.FILES_ERR : utils$1.constants.GLOBAL_ERR;
        throw new ValidationException(this.strings.fileSizeError.format(maxSizeHuman), errType);
      }
    },

    /**
     * Upload File
     * @param {UploaderFile} item
     * @protected
     */
    uploadFile: function (item) {
      var _this = this; // create XHR object


      var request = new window.XMLHttpRequest(); // add progress events

      request.upload.addEventListener("progress", function (evt) {
        _this.onXhrProgress(evt, item);
      }, false);
      request.addEventListener("progress", function (evt) {
        _this.onXhrProgress(evt, item);
      }, false); // open connection

      request.open('POST', _this.ajax.url, true); // set request headers

      request.setRequestHeader("Accept", "application/json");
      request.setRequestHeader("X-Requested-With", "XMLHttpRequest"); // deal with response

      request.onload = function () {
        if (request.status >= 200 && request.status < 400) {
          // Success!
          var data = JSON.parse(request.responseText);

          _this.uploadSuccess(data, item);
        } else {
          // Crap!
          _this.uploadError(item);
        }

        if (typeof _this.handlers.complete === "function") _this.handlers.complete(_this, item);
      };

      request.onerror = function () {
        // Crap again!
        _this.uploadError(item);
      };

      item.setRequest(request); // gathering the form data

      var ajaxData = this.generateFormData(item); // send it

      request.send(ajaxData);
    },

    /**
     * Gather Form data to be sent in the AJAX request
     * @param {UploaderFile} item
     * @protected
     */
    generateFormData: function (item) {
      var ajaxData = new FormData();

      if (this.ajax.data) {
        for (var key in this.ajax.data) {
          ajaxData.append(key, this.ajax.data[key]);
        }
      }

      ajaxData.append("files", item.getFile());
      return ajaxData;
    },

    /**
     *
     * @param evt
     * @param item
     * @protected
     */
    onXhrProgress: function (evt, item) {
      if (evt.lengthComputable) {
        var percentage = evt.loaded / evt.total * 100;
        if (typeof this.handlers.progress === "function") this.handlers.progress(this, percentage, item);
      }
    },

    /**
     * Callback for XHR Success status
     * @param {object} data
     * @param {object} item
     * @protected
     */
    uploadSuccess: function (data, item) {
      // check result from backend
      if (data.success === true) {
        // File is uploaded
        item.setState("success");
        this.uploadedFiles.push(item);
        if (typeof this.handlers.success === "function") this.handlers.success(this, item, data);
        this.fire("success:uploader", {
          item: item,
          instance: this
        });
      } else {
        // File is refused
        item.setState("files-error");
        if (typeof this.handlers.error === "function") this.handlers.error(this, item, data.message);
      }
    },

    /**
     * Callback for XHR Fail status
     * @param {UploaderFile} item
     * @protected
     */
    uploadError: function (item) {
      item.setState("upload-error");
      this.filesCount--; // if the file couldn't be uploaded then decrease files count

      if (typeof this.handlers.error === "function") this.handlers.error(this, item, this.strings.uploadError);
    },

    /**
     * Reset uploader
     * @public
     */
    reset: function () {
      this.uploadedFiles = [];
      this.filesCount = 0;
      this.input.value = "";
      if (typeof this.handlers.reset === "function") this.handlers.reset(this);
    },

    /**
     * remove file from uploaded files
     * @param index
     * @public
     */
    removeFile: function (index) {
      this.uploadedFiles = this.uploadedFiles.filter(function (item) {
        if (item.index === index) {
          item.abort();
          return false;
        }

        return true;
      });
      this.filesCount--; // decrement files count
    },

    /**
     * abort uploading the file
     * @param {UploaderFile} item
     */
    abortFile: function (item) {
      item.abort();
      this.filesCount--; // decrement files count
    },

    /**
     * Fill Uploaded Files array with the saved files
     * @param {array} files
     */
    refreshPreviousUploadedFiles: function (files) {
      var that = this;
      this.uploadedFiles = [];
      files.forEach(function (file, i) {
        var item = new UploaderFile(file, i);
        that.uploadedFiles.push(item);
      });
      this.filesCount = this.uploadedFiles.length;
    },

    /**
     * Fire custom js event
     * @param {string} name
     * @param {object} data
     * @private
     */
    fire: function (name, data) {
      var event = new CustomEvent(name, {
        detail: data
      });
      this.element.dispatchEvent(event);
    }
  };

  /**
   * This JavaScript is jQuery free zone, please don't use jQuery here. Thanks
   * Actually please don't use jQuery anywhere else ;)
   */

  (function () {
    var fileUploader = {
      /**
       * All Uploader basic selectors
       */
      selectors: {
        uploader: '.ajax-uploader',
        dropzone: '.uploader__dropzone',
        validator: 'input.file__validator',
        uploaderFile: '.uploader__file',
        uploaderContainer: '.uploader__input',
        uploaderInputWrapper: '.uploader__input-wrapper',
        uploaderList: '.files-list',
        uploaderItem: '.files-list__item:not([data-state="dummy"])',
        uploaderItemTemplate: '.files-list__item[data-state="dummy"]',
        uploadedTable: '.uploaded-files',
        uploadedFilename: '[data-uploaded-filename]',
        uploaderError: '.uploader__message.error'
      },

      /**
       * Array holding uploader elements
       */
      uploaders: null,

      /**
       *
       * @type {Object}
       * @private
       */
      _instances: {},

      /**
       * The instance to apply changes on
       * @type {AjaxUploader}
       * @private
       */
      _currentInstance: null,
      init: function () {
        this.uploaders = document.querySelectorAll(this.selectors.uploader);
        this.uploaders.forEach(function (uploader) {
          fileUploader._instances[uploader.id] = new AjaxUploader(uploader, fileUploader.pluginOptions(uploader));
          fileUploader.controller(uploader);
        });
      },

      /**
       *
       * @param {Element} uploader
       */
      controller: function (uploader) {
        this._currentInstance = this.getInstance(uploader.id);
        uploader.addEventListener('click', function (e) {
          let currentId = e.target.closest('.ajax-uploader').id;
          fileUploader._currentInstance = fileUploader.getInstance(currentId);

          if (e.target.matches(fileUploader.selectors.uploaderItem + ' .remove-file, ' + fileUploader.selectors.uploaderItem + ' .remove-file *')) {
            fileUploader.cancelItem(e);
          } else if (e.target.matches(fileUploader.selectors.uploadedTable + ' tbody .remove-file, ' + fileUploader.selectors.uploadedTable + ' tbody .remove-file *')) {
            fileUploader.removeItem(e);
          } else if (e.target.matches('.remove-error, .remove-error *')) {
            fileUploader.reset();
          }
        });
      },

      /**
       * Cancel and remove an on-going uploading item
       * @param e
       */
      cancelItem(e) {
        fileUploader.hideErrors();
        let item = e.target.closest('.files-list__item'),
            index = item.dataset.index;

        fileUploader._currentInstance.removeFile(index);

        item.remove();
        if (!fileUploader._currentInstance.multiple) fileUploader.reset();
        fileUploader.refreshBuffer();
      },

      /**
       * Remove uploaded item
       * @param e
       */
      removeItem(e) {
        fileUploader.hideErrors();
        let item = e.target.closest('tr'),
            index = item.dataset.index;

        fileUploader._currentInstance.removeFile(index);

        item.remove();
        fileUploader.refreshBuffer();
      },

      /**
       *
       * @param {Element} uploader
       * @returns {Object}
       */
      pluginOptions: function (uploader) {
        let options = {};
        let dropzone = uploader.closest(fileUploader.selectors.dropzone);
        if (dropzone) options.dropzone = dropzone;
        options.handlers = {
          /**
           *
           * @param {AjaxUploader} instance
           */
          start: function (instance) {
            fileUploader._currentInstance = instance;
            fileUploader.invalidate();
          },

          /**
           *
           * @param {AjaxUploader} instance
           * @param {UploaderFile} item
           */
          beforeUpload: function (instance, item) {
            fileUploader._currentInstance = instance;

            if (!instance.multiple) {
              fileUploader.reset();
              fileUploader._find(fileUploader.selectors.uploaderContainer).style.display = 'none';
            }

            fileUploader.showItem(item);
          },

          /**
           *
           * @param {AjaxUploader} instance
           * @param {ValidationException|string} exception
           * @param {UploaderFile} item
           */
          validationError: function (instance, exception, item) {
            fileUploader._currentInstance = instance;
            fileUploader.showError(item, exception);
            fileUploader.invalidate();
          },

          /**
           *
           * @param {AjaxUploader} instance
           * @param {number} value
           * @param {UploaderFile} item
           */
          progress: function (instance, value, item) {
            fileUploader._currentInstance = instance;

            let itemElement = fileUploader._getItemElement(item);

            if (itemElement) {
              var progressbar = itemElement.querySelector('.uploader__progress progress');
              if (value < 100) progressbar.value = value;else progressbar.removeAttribute('value');
            }
          },

          /**
           *
           * @param {AjaxUploader} instance
           * @param {UploaderFile} item
           */
          success: function (instance, item) {
            fileUploader._currentInstance = instance;
            fileUploader._getItemElement(item).dataset.state = item.getState();

            fileUploader._getItemElement(item).setAttribute('data-state', item.getState());

            fileUploader.setValid();
            fileUploader.showFilename(item.fileName());
          },

          /**
           *
           * @param {AjaxUploader} instance
           * @param {UploaderFile} item
           * @param {ValidationException|string} message
           */
          error: function (instance, item, message) {
            fileUploader._currentInstance = instance;
            fileUploader.showError(item, message);
            fileUploader.invalidate();
          }
        };
        return options;
      },

      /**
       * Set the validation hidden input to invalid
       */
      invalidate: function () {
        var validator = this._find(this.selectors.validator);

        if (validator) {
          validator.value = '';

          this._find(`[data-related-field='${validator.name}']`).classList.add('hidden');
        }
      },

      /**
       * Set the validation hidden input to valid and auto save
       */
      setValid: function () {
        var validator = this._find(this.selectors.validator);

        if (validator) {
          validator.value = 'success';
        }
      },
      showFilename: function (name) {
        var filenameInput = this._find(this.selectors.uploadedFilename);

        if (filenameInput) {
          filenameInput.value = name;
        }
      },

      /**
       * Reset current Uploader instance
       */
      reset: function () {
        var uploaderError = this._find(this.selectors.uploaderError);

        this._find(this.selectors.uploaderInputWrapper).classList.remove('error-input');

        uploaderError.querySelector('span').textContent = '';
        uploaderError.classList.remove('show');

        if (!this._currentInstance.multiple) {
          var item = this._find(this.selectors.uploaderItem);

          if (item) {
            item.dataset.state = '';
            item.removeAttribute('data-state');
          }
        } else {
          var items = this._getAllItemsElement();

          items.forEach(function (item) {
            if (item.dataset.status === 'upload-error' || item.dataset.status === 'files-error') {
              item.removeAttribute('data-index');
            }
          });
        }

        this._find(this.selectors.uploaderContainer).style.display = '';
        this._find(this.selectors.uploaderFile).value = '';
      },

      /**
       *
       * @param {UploaderFile} item
       * @param {ValidationException|string} error
       */
      showError: function (item, error) {
        var uploaderError = this._find(this.selectors.uploaderError);

        if (item instanceof UploaderFile) {
          var itemElem = this._getItemElement(item);

          var itemError = itemElem.querySelector('.files-error');
        }

        var global = error instanceof ValidationException ? error.isGlobalError() : false; // Is it global error?

        var message = error instanceof ValidationException ? error.message : error; // Error message

        if (!this._currentInstance.multiple) {
          this._find(this.selectors.uploaderInputWrapper).classList.add('error-input');
        }

        if (global) {
          if (!this._currentInstance.multiple) {
            this._currentInstance.removeFile(item.getIndex());

            itemElem.remove();
          } else {
            this._find(this.selectors.uploaderInputWrapper).classList.add('error-input');
          }

          uploaderError.querySelector('span').textContent = message;
          uploaderError.classList.add('show');
          uploaderError.classList.remove('hide');
        } else if (itemElem) {
          itemElem.dataset.state = item.getState();
          itemElem.setAttribute('data-state', item.getState());
          itemElem.removeAttribute('data-index');

          if (message) {
            itemError.querySelector('span').textContent = message;
            itemError.classList.add('show');
            itemError.classList.remove('hide');
          }
        }
      },

      /**
       *
       * @param {UploaderFile} [item]
       */
      hideErrors: function (item) {
        this._find(this.selectors.uploaderInputWrapper).classList.remove('error-input');

        var uploaderError = this._find(this.selectors.uploaderError);

        uploaderError.querySelector('span').textContent = '';
        uploaderError.classList.remove('show');
        uploaderError.classList.add('hide');

        if (item instanceof UploaderFile) {
          var itemElem = this._getItemElement(item);

          var itemError = itemElem.querySelector('.files-error');
          itemError.querySelector('span').textContent = '';
          itemError.classList.remove('show');
          itemError.classList.add('hide');
        }
      },

      /**
       * Refresh indexes of uploaded files
       */
      refreshBuffer: function () {
        var previousItems = [];

        this._getAllUploadedElements().forEach((row, i) => {
          this._refreshUploadedItem(row, i);

          previousItems.push(row.querySelector('.path-td .td-text').textContent);
        });

        this._currentInstance.refreshPreviousUploadedFiles(previousItems);
      },

      /**
       * Refresh uploaded item
       * @param {HTMLElement} row
       * @param {number} i
       * @private
       */
      _refreshUploadedItem(row, i) {
        let previousIndex = row.dataset.index;
        row.dataset.index = i.toString();
        row.setAttribute('data-index', i);
        row.querySelectorAll(`[name^="supplemental-files[${previousIndex}]"]`).forEach(function (item) {
          item.setAttribute('name', item.getAttribute('name').replace(previousIndex, i));
        });
        let element = row.querySelector(`[id='supplemental-files[${previousIndex}]']`);
        if (element) element.setAttribute('id', item.getAttribute('id').replace(previousIndex, i));
      },

      /**
       *
       * @param {UploaderFile} item
       */
      showItem: function (item) {
        var filename = item.fileName();
        var fileSize = item.fileSizeHuman();

        var uploaderItem = this._find(this.selectors.uploaderItemTemplate).cloneNode(true);

        uploaderItem.querySelector('.file-name').textContent = filename;
        uploaderItem.querySelector('.file-size').textContent = `(${fileSize})`;
        uploaderItem.setAttribute('data-state', item.getState());
        uploaderItem.setAttribute('data-index', item.getIndex());

        this._find(this.selectors.uploaderList).appendChild(uploaderItem);
      },

      /**
       *
       * @param {UploaderFile} item
       * @returns {Element}
       * @private
       */
      _getItemElement: function (item) {
        return this._find(fileUploader.selectors.uploaderItem + `[data-index="${item.getIndex()}"]`);
      },

      /**
       *
       * @returns {NodeList}
       * @private
       */
      _getAllItemsElement: function () {
        return this._findAll(fileUploader.selectors.uploaderItem);
      },

      /**
       *
       * @returns {NodeList}
       * @private
       */
      _getAllUploadedElements: function () {
        return this._findAll(fileUploader.selectors.uploadedTable + ' tbody tr');
      },

      /**
       *
       * @param {string} id
       * @returns {AjaxUploader}
       * @protected
       */
      getInstance: function (id) {
        return this._instances[id];
      },

      /**
       *
       * @param {string} selector
       * @returns {Element}
       * @private
       */
      _find: function (selector) {
        return this._currentInstance.element.querySelector(selector);
      },

      /**
       *
       * @param {string} selector
       * @returns {NodeList}
       * @private
       */
      _findAll: function (selector) {
        return this._currentInstance.element.querySelectorAll(selector);
      }
    };
    UX.fileUploader = fileUploader; // add to global namespace
  })();

  (function () {
    var $window = $(window),
        $body = $('body');
    var clientPagination = {
      containerName: ".client-pagination",
      showPerPage: null,
      $currentPage: null,
      $pagesdisplyed: null,
      tableRow: ".client-pagination-table .tablerow",
      init: function () {
        clientPagination.showPerPage = parseInt($(clientPagination.containerName).find('.show_per_page').val(), 0);
        clientPagination.$currentPage = $(clientPagination.containerName).find('.current_page');
        clientPagination.$pagesdisplyed = parseInt($(clientPagination.containerName).find('.pages-displyed').val(), 0);
        clientPagination.buildPagination();
        clientPagination.control();
      },
      set: {
        containerName: function (name) {
          clientPagination.containerName = name;
        },
        tableRowName: function (name) {
          clientPagination.tableRow = name;
        }
      },
      control: function () {
        $body.on('click', clientPagination.containerName + ' .pagination__btn--prev', function (e) {
          e.preventDefault();
          clientPagination.previous();
        });
        $body.on('click', clientPagination.containerName + ' .pagination__btn--next', function (e) {
          e.preventDefault();
          clientPagination.next();
        });
        $body.on('click', clientPagination.containerName + ' .page', function (e) {
          e.preventDefault();
          clientPagination.goToPage($(this).data('page-index'));
        });
      },
      buildPagination: function () {
        var number_of_items = $(clientPagination.tableRow).length;
        var number_of_pages = Math.ceil(number_of_items / clientPagination.showPerPage);
        $(clientPagination.containerName).remove('.page');

        if (number_of_items > clientPagination.showPerPage) {
          $(clientPagination.tableRow).css('display', 'none');
          $(clientPagination.containerName).removeClass('hidden');
          $(clientPagination.tableRow).slice(0, clientPagination.showPerPage).css('display', 'table-row');
          $(clientPagination.containerName).find('.prev').hide();
          $(clientPagination.containerName).find('.next').show();
          var i = 0;
          $(clientPagination.containerName).find('.pages').empty();

          while (i < number_of_pages) {
            if (i >= clientPagination.$pagesdisplyed) {
              $(clientPagination.containerName).find('.pages').append('<a class="page hidden" href="#" title="page ' + (i + 1) + '" data-page-index="' + i + '">' + (i + 1) + '</a>');
            } else {
              $(clientPagination.containerName).find('.pages').append('<a class="page" href="#" title="page ' + (i + 1) + '" data-page-index="' + i + '">' + (i + 1) + '</a>');
            }

            i++;
          }

          $(clientPagination.containerName).find('[data-page-index="0"]').addClass('selected');
        } else {
          $(clientPagination.containerName).addClass('hidden');
        }
      },
      goToPage: function (page_num) {
        var number_of_items = $(clientPagination.tableRow).length;
        var number_of_pages = Math.ceil(number_of_items / clientPagination.showPerPage);
        var start_from = page_num * clientPagination.showPerPage;
        var end_on = start_from + clientPagination.showPerPage;
        var $currentPage = $(clientPagination.containerName).find('[data-page-index="' + page_num + '"]');
        $(clientPagination.tableRow).css('display', 'none').slice(start_from, end_on).css('display', 'table-row');
        clientPagination.$currentPage.val(page_num);
        $(clientPagination.containerName).find('.page').removeClass('selected');
        $currentPage.addClass('selected');
        var showpagesBeforeAfter = Math.ceil(clientPagination.$pagesdisplyed / 2);
        $(clientPagination.containerName).find('.page').addClass('hidden');

        if (page_num + 1 > showpagesBeforeAfter) {
          for (i = page_num + 1 - showpagesBeforeAfter; i < page_num + showpagesBeforeAfter; i++) {
            if (i <= number_of_pages) $(clientPagination.containerName).find('[data-page-index="' + i + '"]').removeClass('hidden');
          }
        } else {
          for (i = 0; i < clientPagination.$pagesdisplyed; i++) {
            $(clientPagination.containerName).find('[data-page-index="' + i + '"]').removeClass('hidden');
          }
        }

        if (page_num == 0) $(clientPagination.containerName).find('.prev').hide();else $(clientPagination.containerName).find('.prev').show();
        if (page_num == number_of_pages - 1) $(clientPagination.containerName).find('.next').hide();else $(clientPagination.containerName).find('.next').show();
      },
      previous: function () {
        var new_page = parseInt(clientPagination.$currentPage.val(), 0) - 1;

        if (new_page > -1) {
          clientPagination.goToPage(new_page);
        }
      },
      next: function () {
        var new_page = parseInt(clientPagination.$currentPage.val(), 0) + 1;
        var number_of_items = $(clientPagination.tableRow).length;
        var number_of_pages = Math.ceil(number_of_items / clientPagination.showPerPage);

        if (new_page < number_of_pages) {
          clientPagination.goToPage(new_page);
        }
      }
    };
    UX.clientPagination = clientPagination; // add to global namespace
  })();

  (function () {
    var $window = $(window),
        $body = $('body');
    var backToTop = {
      element: '.back-to-top',
      footerBackToTop: 'footer .back-to-top',
      init: function () {
        backToTop.controller();
      },
      controller: function () {
        $body.on('click', backToTop.element, function (e) {
          e.preventDefault();
          $('html, body').animate({
            scrollTop: 0
          }, 600);
        });
        $window.on("scroll", function () {
          if ($(backToTop.footerBackToTop).length) {
            if ($(this).scrollTop() > $('header').height()) {
              $(backToTop.footerBackToTop).addClass('back-to-top__is-visible');
            } else {
              $(backToTop.footerBackToTop).removeClass('back-to-top__is-visible back-to-top__fade-out');
            }

            if ($(this).scrollTop() > 400) {
              $(backToTop.footerBackToTop).addClass('back-to-top__fade-out');
            }

            if (backToTop.check.isfooterVisible()) {
              $(backToTop.footerBackToTop).addClass('back-to-top__static');
            } else {
              $(backToTop.footerBackToTop).removeClass('back-to-top__static');
            }
          }
        });
      },
      check: {
        isfooterVisible: function () {
          var docViewBottom = $(window).scrollTop() + $(window).height();
          var backToTopPos = $('footer').offset().top;
          return backToTopPos <= docViewBottom;
        }
      }
    };
    UX.backToTop = backToTop;
  })();

  (function () {
    var $window = $(window),
        $body = $('body');
    var sidebarSections = {
      isMobile: false,
      $scrollPoints: $('.section__title[id], .to-section[id]'),
      $block: $('.sections-block'),
      vPort: "screen-sm",
      scrollingToTarget: false,
      init: function () {
        if (sidebarSections.$scrollPoints.length) {
          sidebarSections.initSections();
          sidebarSections.set.selectedSection();
          sidebarSections.controller();
        }
      },
      initSections: function () {
        sidebarSections.$scrollPoints.each(function (e) {
          sidebarSections.$block.find('ul').append(sidebarSections.get.htmlSection($(this)));
        });
      },
      controller: function () {
        $body.on('click', '.sections-block a', function (e) {
          sidebarSections.$block = $('.sections-block');
          UX.progressBar.lock = false;
          sidebarSections.scrollingToTarget = true;
          sidebarSections.scrollToTarget($($(this).attr('href')));
          sidebarSections.$block.find('a').removeClass('active');
          $(this).addClass('active');
        });
        $(document).on(sidebarSections.vPort + '-on', function () {
        });
        $(document).on(sidebarSections.vPort + '-off', function () {
        });
        $window.on("scroll", function () {
          sidebarSections.$block = $('.sections-block');
          var scrollingPoints = sidebarSections.get.scrollingSectionPoints(); //if it on the top of the page

          if ($(window).scrollTop() == 0) {
            sidebarSections.$block.find('a').removeClass("active");
          } //if on the bottom of the bage
          else if (window.innerHeight + window.scrollY >= document.body.offsetHeight) {
              var id = scrollingPoints.last().attr('id');
              sidebarSections.$block.find('a').removeClass("active");
              sidebarSections.$block.find('a[href="#' + id + '"]').addClass("active");
            } else {
              if (!sidebarSections.scrollingToTarget) {
                scrollingPoints.each(function (e) {
                  if ($(window).scrollTop() >= $(this).offset().top - sidebarSections.get.fixedpageElementsHeight() - $(this).outerHeight() - 15) {
                    var id = $(this).attr('id');
                    sidebarSections.$block.find('a').removeClass("active");
                    sidebarSections.$block.find('a[href="#' + id + '"]').addClass("active");
                  }
                });
              }
            }
        });
      },
      scrollToTarget: function ($el) {
        // adding animation scroll to the scrolling functionality
        var scrollVal = $el.offset().top - sidebarSections.get.fixedpageElementsHeight();
        $('html, body').stop().animate({
          scrollTop: scrollVal
        }, 500, function () {
          UX.progressBar.lock = true;
        }).promise().done(function () {
          setTimeout(function () {
            sidebarSections.scrollingToTarget = false;
          }, 100);
        });
      },
      set: {
        selectedSection: function () {
          if (window.location.hash) {
            sidebarSections.$block.find('a[href="' + window.location.hash + '"]').addClass('active');
          }
        }
      },
      get: {
        scrollingSectionPoints: function () {
          return sidebarSections.$scrollPoints;
        },
        htmlSection: function ($this) {
          return '<li><a title="' + $this.text() + '" href="#' + $this.attr('id') + '">' + $this.html() + '</a></li>';
        },
        fixedpageElementsHeight: function () {
          var elementsHeight = $('header.fixed, .pageHeader').outerHeight();

          if (!elementsHeight) {
            elementsHeight = 0;
          }

          if ($('.fixed-element').length) {
            $.each($('.fixed-element'), function (index, value) {
              if ($(value).outerHeight()) {
                elementsHeight += $(value).outerHeight();
              }
            });
          }

          return elementsHeight;
        }
      }
    };
    UX.sidebarSections = sidebarSections; // add to global namespace
  })();

  $.widget("ui.slider", $.ui.slider, {
    options: {
      chart: false
    },
    _refreshValue: function () {
      var lastValPercent,
          valPercent,
          value,
          valueMin,
          valueMax,
          oRange = this.options.range,
          oChart = this.options.chart,
          o = this.options,
          that = this,
          animate = !this._animateOff ? o.animate : false,
          _set = {};

      if (this._hasMultipleValues()) {
        this.handles.each(function (i) {
          if (oChart) {
            if (i === 0) {
              valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin() + 1) * 100;
            }

            if (i === 1) {
              valPercent = (that.values(i) - that._valueMin() + 1) / (that._valueMax() - that._valueMin() + 1) * 100;
            }
          } else {
            valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;
          }

          _set[that.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
          $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);

          if (that.options.range === true) {
            if (that.orientation === "horizontal") {
              if (i === 0) {
                that.range.stop(1, 1)[animate ? "animate" : "css"]({
                  left: valPercent + "%"
                }, o.animate);
              }

              if (i === 1) {
                that.range[animate ? "animate" : "css"]({
                  width: valPercent - lastValPercent + "%"
                }, {
                  queue: false,
                  duration: o.animate
                });
              }
            } else {
              if (i === 0) {
                that.range.stop(1, 1)[animate ? "animate" : "css"]({
                  bottom: valPercent + "%"
                }, o.animate);
              }

              if (i === 1) {
                that.range[animate ? "animate" : "css"]({
                  height: valPercent - lastValPercent + "%"
                }, {
                  queue: false,
                  duration: o.animate
                });
              }
            }
          }

          lastValPercent = valPercent;
        });
      } else {
        value = this.value();
        valueMin = this._valueMin();
        valueMax = this._valueMax();
        valPercent = valueMax !== valueMin ? (value - valueMin) / (valueMax - valueMin) * 100 : 0;
        _set[this.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
        this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);

        if (oRange === "min" && this.orientation === "horizontal") {
          this.range.stop(1, 1)[animate ? "animate" : "css"]({
            width: valPercent + "%"
          }, o.animate);
        }

        if (oRange === "max" && this.orientation === "horizontal") {
          this.range.stop(1, 1)[animate ? "animate" : "css"]({
            width: 100 - valPercent + "%"
          }, o.animate);
        }

        if (oRange === "min" && this.orientation === "vertical") {
          this.range.stop(1, 1)[animate ? "animate" : "css"]({
            height: valPercent + "%"
          }, o.animate);
        }

        if (oRange === "max" && this.orientation === "vertical") {
          this.range.stop(1, 1)[animate ? "animate" : "css"]({
            height: 100 - valPercent + "%"
          }, o.animate);
        }
      }
    }
  });

  (function () {
    var $body = $('body');
    var $document = $(document);
    var facetDateChart = {
      $element: $('.facetDateChart'),
      rangeStartVal: null,
      rangeEndVal: null,
      yearWeights: null,
      queryID: null,
      height: 200,
      amplifierRatio: null,
      url: location.href,
      init: function () {
        facetDateChart.rangeStartVal = parseInt(facetDateChart.$element.data('min'));
        facetDateChart.rangeEndVal = parseInt(facetDateChart.$element.data('max'));
        facetDateChart.yearWeights = facetDateChart.$element.data('yearweights');
        facetDateChart.queryID = facetDateChart.$element.data('queryid');
        facetDateChart.amplifierRatio = parseInt(facetDateChart.$element.data('amplifierratio'));
        facetDateChart.chart.init();
        facetDateChart.control();
      },
      control: function () {
        $(document).on('slide:opened', function (event) {
          $('.ui-slider-handle__indicator, .ui-slider-handle__label').remove();
          facetDateChart.init();
          $(this).off(event);
        });
      },
      getSelectedRange: function (sliderRange) {
        var baseUrl = facetDateChart.url.split('?')[0];
        var queryString = facetDateChart.url.indexOf('?') !== -1 ? facetDateChart.url.split('?')[1] : '';
        var queryStringObj = {};

        if (queryString) {
          queryString.split('&').map(function (value) {
            var keyVal = value.split('=');
            queryStringObj[keyVal[0]] = keyVal[1];
          });

          if (queryStringObj.AfterYear && queryStringObj.BeforeYear) {
            return [queryStringObj.AfterYear, queryStringObj.BeforeYear];
          }
        }

        return [parseInt(facetDateChart.rangeStartVal), parseInt(facetDateChart.rangeEndVal)];
      },
      updateUrl: function (startYear, endYear) {
        facetDateChart.removeParam('AfterYear');
        facetDateChart.removeParam('BeforeYear');
        facetDateChart.removeParam('queryID');
        facetDateChart.url += (facetDateChart.url.indexOf('?') > -1 ? '&' : '?') + 'AfterYear=' + startYear + '&BeforeYear=' + endYear + '&queryID=' + facetDateChart.queryID;
        window.location = facetDateChart.url;
      },
      removeParam: function (key) {
        var baseUrl = facetDateChart.url.split('?')[0];
        var queryString = facetDateChart.url.indexOf('?') !== -1 ? facetDateChart.url.split('?')[1] : '';
        var queryStringObj = {};

        if (queryString) {
          queryString.split('&').map(function (value) {
            var keyVal = value.split('=');
            queryStringObj[keyVal[0]] = keyVal[1];
          });

          if (queryStringObj[key]) {
            delete queryStringObj[key];
          }

          queryString = Object.keys(queryStringObj).map(function (value) {
            return value + '=' + queryStringObj[value];
          }).join('&');
          facetDateChart.url = baseUrl + (queryString ? '?' + queryString : '');
        }
      },
      chart: {
        //more info https://www.jqueryscript.net/chart-graph/Histogram-Slider-Plugin-jQuery.html
        init: function () {
          facetDateChart.chart.setOptions();
          var self = facetDateChart.$element,
              dataItems = self.options.data.items,
              bins = new Array(self.options.numberOfBins).fill(0),
              range = self.options.numberOfBins,
              rangePerBin = range / self.options.numberOfBins;

          for (i = 0; i < dataItems.length; i++) {
            var index = parseInt(dataItems[i].value / rangePerBin),
                increment = 1;

            if (dataItems[i].count) {
              // Handle grouped data structure
              increment = parseInt(dataItems[i].count);
            }

            bins[index] += increment;
          }

          var chartName = self.attr('name') + "__chart",
              sliderName = self.attr('name') + "__slider";
          var wrapHtml = "<div class='" + chartName + "' style='height:" + self.options.height + "px; overflow: hidden;'></div>" + "<div class='" + sliderName + "'></div>";
          self.html(wrapHtml);
          var heightRatio = facetDateChart.chart.calculateHeightRatio(bins, self.options.height),
              widthPerBin = 100 / self.options.numberOfBins;

          for (i = 0; i < bins.length; i++) {
            var binRange = facetDateChart.chart.getBinRange(rangePerBin, i, facetDateChart.$element.options.sliderRange[0]),
                inRangeClass = "bin-color-selected",
                outRangeClass = "bin-color";

            if (self.options.optimalRange[0] <= binRange[0] && binRange[0] <= self.options.optimalRange[1]) {
              inRangeClass = "bin-color-optimal-selected";
              outRangeClass = "bin-color-optimal";
            }

            var toolTipHtml = self.options.showTooltips ? "<span class='tooltiptext'>" + binRange[0] + "/" + bins[i] + "</span>" : "";
            var scaledValue = parseInt(bins[i] * heightRatio),
                height = facetDateChart.chart.convertToHeight(scaledValue),
                inRangeOffset = parseInt(self.options.height - height),
                outRangeOffset = -parseInt(self.options.height - height * 2);
            var binHtml = "<div class='tooltip' style='float:left!important;width:" + widthPerBin + "%;'>" + toolTipHtml + "<div class='bin in-range " + inRangeClass + "' style='height:" + height + "px;bottom:-" + inRangeOffset + "px;position: relative;'></div>" + "<div class='bin out-of-range " + outRangeClass + "' style='height:" + height + "px;bottom:" + outRangeOffset + "px;position: relative;'></div>" + "</div>";
            $("." + chartName).append(binHtml);
          }

          $("." + sliderName).slider({
            range: true,
            min: self.options.sliderRange[0],
            max: self.options.sliderRange[1],
            values: self.options.selectedRange,
            chart: true,
            slide: function (event, ui) {
              facetDateChart.chart.update(ui.values, self.options.sliderRange[0], rangePerBin, chartName, sliderName);
            },
            create: function (event, ui) {
              $(event.target).find('.ui-slider-handle').append('<span class="ui-slider-handle__indicator"></span>').first().addClass('first');
              $(event.target).find('.ui-slider-handle').append('<span class="ui-slider-handle__label"></span>');
              $(event.target).find('.ui-slider-handle__indicator').height(facetDateChart.height + 10);
            },
            stop: function (event, ui) {
              facetDateChart.updateUrl(ui.values[0], ui.values[1]);
            }
          });
          facetDateChart.chart.update(self.options.selectedRange, self.options.sliderRange[0], rangePerBin, chartName, sliderName);
        },
        setOptions: function () {
          var data = {
            "items": []
          };
          $.each(facetDateChart.yearWeights, function (index, value) {
            data.items.push({
              "value": index,
              "count": value * facetDateChart.amplifierRatio
            });
          });
          facetDateChart.chart.setHeight(data);
          var options = {
            data: data,
            sliderRange: [facetDateChart.rangeStartVal, facetDateChart.rangeEndVal],
            optimalRange: [facetDateChart.rangeStartVal, facetDateChart.rangeEndVal],
            selectedRange: facetDateChart.getSelectedRange(),
            numberOfBins: data.items.length,
            height: facetDateChart.height,
            showTooltips: false
          };
          facetDateChart.$element.options = options;
        },
        setHeight: function (data) {
          facetDateChart.height = Math.max.apply(Math, data.items.map(function (o) {
            return o.count;
          })) * 5 + 20;

          if (facetDateChart.height < 150) {
            facetDateChart.height = 150;
          }
        },
        update: function (selectedRange, sliderMin, rangePerBin, chartName, sliderName) {
          var leftValue = selectedRange[0],
              rightValue = selectedRange[1],
              $minLabelHandler = $("." + sliderName).find('.ui-slider-handle.first .ui-slider-handle__label').html(leftValue),
              $maxLabelHandler = $("." + sliderName).find('.ui-slider-handle:not(.first) .ui-slider-handle__label').html(rightValue); // set opacity per bin based on the slider values

          $("." + chartName + " .in-range").each(function (index, bin) {
            var binRange = facetDateChart.chart.getBinRange(rangePerBin, index, sliderMin);

            if (binRange[1] < rightValue) {
              // Set opacity based on left (min) slider
              if (leftValue > binRange[1]) {
                facetDateChart.chart.setOpacity(bin, 0);
              } else if (leftValue < binRange[0]) {
                facetDateChart.chart.setOpacity(bin, 1);
              } else {
                //setOpacity(bin, 1);
                facetDateChart.chart.setOpacity(bin, 1 - (leftValue - binRange[0]) / rangePerBin);
              }
            } else if (binRange[0] > leftValue) {
              // Set opacity based on right (max) slider value
              if (rightValue > binRange[1]) {
                facetDateChart.chart.setOpacity(bin, 1);
              } else if (rightValue < binRange[0]) {
                facetDateChart.chart.setOpacity(bin, 0);
              } else {
                facetDateChart.chart.setOpacity(bin, 1 - (rightValue - binRange[0]) / rangePerBin);
              }
            }
          });
          facetDateChart.chart.setLabelHandlersPosition($minLabelHandler, $maxLabelHandler);
          setTimeout(function () {
            facetDateChart.chart.setLabelHandlersPosition($minLabelHandler, $maxLabelHandler);
          }, 500);
        },
        setLabelHandlersPosition: function ($minLabelHandler, $maxLabelHandler) {
          var minOuterLeft = $minLabelHandler.offset().left,
              minWidth = $minLabelHandler.outerWidth(),
              minOuterRight = minOuterLeft + minWidth,
              maxOuterLeft = $maxLabelHandler.offset().left,
              rangeLabelsPosition = maxOuterLeft - minOuterRight - 2,
              marginValue = (2 - rangeLabelsPosition) / 2;
          $minLabelHandler.css('left', '-=' + marginValue);
          $maxLabelHandler.css('left', '+=' + marginValue);

          if (Math.floor(rangeLabelsPosition) > 2) {
            $minLabelHandler.css('left', '0');
            $maxLabelHandler.css('left', '0');
          }
        },
        getBinRange: function (rangePerBin, index, sliderMin) {
          var min = rangePerBin * index + sliderMin,
              max = rangePerBin * (index + 1) - 1;
          if (rangePerBin == 1) max = min;
          return [min, max];
        },
        setOpacity: function (bin, val) {
          $(bin).css("opacity", val);
        },
        convertToHeight: function (v) {
          return parseInt(5 * v + 1);
        },
        calculateHeightRatio: function (bins, chartHeight) {
          var maxValue = Math.max.apply(null, bins);
          var height = facetDateChart.chart.convertToHeight(maxValue);

          if (height > chartHeight) {
            return chartHeight / height;
          }

          return 1;
        }
      }
    };
    UX.facetDateChart = facetDateChart; // add to global namespace
  })();

  (function () {
    var $window = $(window),
        $document = $(document),
        $body = $('body');
    var progressBar = {
      $barWrapper: $('.progress-bar--wrapper'),
      $bar: $('.progress-bar'),
      scrollPercent: null,
      lock: true,
      init: function () {
        progressBar.controller();
      },
      controller: function () {
        $window.on("scroll load", function () {
          progressBar.scrollPercent = 100 * $window.scrollTop() / ($document.height() - $window.height() - $('footer').outerHeight());
          if (progressBar.scrollPercent > 100 || $window.height() >= $('main').height() + $('header').outerHeight()) progressBar.scrollPercent = 100;
          if (progressBar.lock) progressBar.$bar.stop().animate({
            width: progressBar.scrollPercent + "%"
          }, 50);
        });
      }
    };
    UX.progressBar = progressBar;
  })();

  // Import components

  (function () {
    var $body = $('body');
    var fieldsCtrl = {
      container: null,
      $wrapper: null,
      $toggle: null,
      $form: null,
      $terms: null,
      $markAll: null,
      maxClone: 2,
      init: function () {
        fieldsCtrl.$toggle = $('.reproducible');
        fieldsCtrl.$wrapper = $('.reproducible__wrapper');
        fieldsCtrl.container = '.reproducible__container'; // Support for the legacy emails and phones used in account page
        //fieldsCtrl.check.terms();

        fieldsCtrl.control();
        var $lastTerm = fieldsCtrl.$wrapper.children('.reproducible').length;
        fieldsCtrl.check.lastClone($lastTerm);
        fieldsCtrl.accessibility.init();
        fieldsCtrl.additionalControls();
      },
      accessibility: {
        init: function () {
          this.radioCheckbox();

          if ($('.force--disabled').length == 0) {
            this.selectBox();
          }

          this.buttons.init();
          this.range();
        },
        radioCheckbox: function () {
          var radioCheckboxSelector = '.radio--primary, .radio--secondary, .checkbox--primary, .checkbox--secondary';
          $(document).on('mousedown', radioCheckboxSelector, function (event) {
            var $this = $(this);
            $this.attr({
              tabindex: 0
            });
            $this.focus();
          }).on('mouseup', radioCheckboxSelector, function (event) {
            var $this = $(this);
            $this.removeAttr('tabindex');

            if ($this.hasClass('withInput')) {
              $this.find('input[type=email], input[type=text]').focus();
            } else {
              $this.find('input[type=radio], input[type=checkbox]').focus();
            }
          });
        },
        selectBox: function () {
          // JCF selectbox
          $(document).on('mousedown', '.jcf-select', function (event) {
            var $this = $(this);
            $this.attr({
              tabindex: 0
            });
            $this.siblings('.jcf-hidden').attr('disabled', true);
            $this.focus();
          }).on('mouseup', '.jcf-select', function (event) {
            var $this = $(this);
            $this.removeAttr('tabindex');
            $this.siblings('.jcf-hidden').focus();
            $this.siblings('.jcf-hidden').removeAttr('disabled');
          });
          $(document).on('keydown', 'select.jcf-hidden', function (event) {
            if (event.which === 13) {
              event.preventDefault();
            } else if (event.which === 27 && $(this).siblings('.jcf-drop-active').length > 0) {
              event.which = 13;
              $(this).trigger(event);
            }
          }); // Hide on blur
          // note it doesn't work over document selector, event is not fired

          $('select.jcf-hidden').on('blur', function (event) {
            var $this = $(this); // if key was pressed, than we need to operate with related target, not original target

            if (event.relatedTarget !== null) {
              event.target = event.relatedTarget;
            }

            var instance = jcf.getInstance($this[0]).instance;
            var target = $(event.target),
                focusInsideSelect = target.filter(instance.realElement).length || target.closest(instance.fakeElement).length || target.closest(instance.dropdown).length;

            if (!focusInsideSelect) {
              instance.hideDropdown();
            }
          });
        },
        buttons: {
          init: function () {
            this.prepare(); // Enable Screen reader standard behavior on space and enter for [role=buttons] to be consistent with normal button element

            $(document).on('keydown', 'a[role=button]', function (event) {
              if (event.which === 32 || event.which === 13) {
                event.preventDefault();
                $(this).click();
              }
            });
          },
          prepare: function () {
            // Remove HREF=# on a[role=button] as screen-reader would read whole page URL otherwise on focus
            $('a[role=button]').each(function () {
              var $this = $(this);
              var href = $this.attr('href');
              href = href === '#' ? null : href;
              var target = $this.data('target');
              $this.attr({
                'data-target': target || href,
                'tabindex': 0
              });

              if (!href) {
                $this.removeAttr('href');
              }
            });
          }
        },
        range: function () {
          // range slider accessible by keyboard even if it's in slideshow, we want to catch key arrows and stop event propagation
          $('input[type="range"]').on('keydown', function (event) {
            var keyCodes = {
              DOWN: 40,
              END: 35,
              HOME: 36,
              LEFT: 37,
              RIGHT: 39,
              UP: 38
            }; // do nothing for not allowed keys

            if (!(Object.values(keyCodes).indexOf(event.keyCode) > -1)) return;
            event.stopPropagation();
          }).on('mousedown', function (event) {
            // and catch dragging
            event.stopPropagation();
          });
        }
      },
      control: function () {
        $body.on('keypress click', '[class*="-ctrl-field"]', function (e) {
          if (e.which === 13 || e.type === 'click') {
            e.preventDefault();
            fieldsCtrl.$wrapper = $(this).closest('.reproducible__wrapper');
            fieldsCtrl.$toggle = $(this).closest('.reproducible');
            fieldsCtrl.$terms = $(this).closest('.reproducible__wrapper').find('.reproducible'); // LIT-161778 Support for the legacy emails and phones used in account page

            if ($(fieldsCtrl.container).length == 0) {
              if ($(this).is('.add-ctrl-field')) {
                if (fieldsCtrl.$terms.length < fieldsCtrl.maxClone + 1) {
                  fieldsCtrl.on.clone($(this));
                }
              } else {
                if (fieldsCtrl.$terms.length > 1) {
                  fieldsCtrl.on.remove($(this));
                }
              }
            }
          }
        });
        $body.on('click', '.markAll [type="checkbox"]', function (e) {
          var $this = $(this);

          if ($this.is('[name="markall"]')) {
            fieldsCtrl.on.markAll($this);
          } else {
            fieldsCtrl.on.checkMarkAll($this);
          }
        });
      },
      additionalControls: function () {},
      on: {
        clone: function ($this) {
          jcf.destroy($('.reproducible .jcf'));
          fieldsCtrl.$toggle.clone(true, true).find('input').val('').end().appendTo(fieldsCtrl.$wrapper);
          $('.reproducible .jcf').each(function () {
            jcf.replace($(this));
          });
          fieldsCtrl.check.terms($this);
          var $lastTerm = fieldsCtrl.$wrapper.children('.reproducible').length;
          fieldsCtrl.check.lastClone($lastTerm);
        },
        remove: function ($this) {
          fieldsCtrl.$toggle.remove();
          fieldsCtrl.check.terms($this);
          var $lastTerm = fieldsCtrl.$wrapper.children('.reproducible').length;
          fieldsCtrl.check.lastClone($lastTerm);
        },
        markAll: function ($el) {
          fieldsCtrl.$markAll = $el.closest('.markAll');

          if ($el.prop('checked')) {
            fieldsCtrl.$markAll.find('[type="checkbox"]').prop('checked', true);
          } else {
            fieldsCtrl.$markAll.find('[type="checkbox"]').prop('checked', false);
          }
        },
        checkMarkAll: function ($el) {
          fieldsCtrl.$markAll = $el.closest('.markAll');
          var $inputs = fieldsCtrl.$markAll.find('[type="checkbox"]:not([name="markall"])');
          $inputs.each(function () {
            if (!$(this).prop('checked')) {
              fieldsCtrl.$markAll.find('[name="markall"]').prop('checked', false);
              return false;
            }

            fieldsCtrl.$markAll.find('[name="markall"]').prop('checked', true);
          });
        }
      },
      check: {
        terms: function ($this) {
          var nameInput = $this.closest('.reproducible').find('input').attr('name');

          if (nameInput) {
            var before = nameInput.split("[");
            var after = before[1].split("]");
          }
          /*var matches = nameInput.match(/\[(.*?)\]/);
          if (matches) {
              var submatch = matches[1];
          }*/
          // Support for the legacy emails and phones used in account page


          if ($(fieldsCtrl.container).length == 0) {
            fieldsCtrl.$terms = $('.reproducible');
          } else {
            fieldsCtrl.$terms = $this.parents(fieldsCtrl.container).find('.reproducible');
          }

          var copy_from_template = 0;
          fieldsCtrl.$terms.each(function (index) {
            var $el = $(this);

            if ($el.parents('.template').length) {
              copy_from_template = 1;
            } else {
              var number = index - copy_from_template;
              $(this).find('input').attr('name', before[0] + "[" + number + "]" + after[1]);
            }
          }); // fieldsCtrl.$terms = $('.reproducible');
          //
          // fieldsCtrl.$terms.each(function (index) {
          //     var number = index;
          //
          //     $(this).find('input').attr('name', before[0] + "[" + index + "]" + after[1]);
          //
          // });
        },
        lastClone: function ($this) {
          if ($this == fieldsCtrl.maxClone) {
            fieldsCtrl.$wrapper.children('.reproducible:last-child').children('.add-ctrl-field').addClass('hidden');
          } else {
            fieldsCtrl.$wrapper.children('.reproducible:last-child').children('.add-ctrl-field').removeClass('hidden');
          }
        }
      }
    };
    UX.fieldsCtrl = fieldsCtrl; // add to global namespace
  })();

  (function () {
    var $window = $(window),
        $body = $('body');
    var slider = {
      $slider: null,
      options: {},
      vPort: "always",
      // default responsive break point
      isMobile: false,
      navText: ["<span class='hidden-xs'>prev</span><i class='icon-arrow_l visible-xs'></i>", "<span class='hidden-xs'>next</span><i class='icon-arrow_r visible-xs'></i>"],
      init: function () {
        slider.additionalInit();
        slider.on.build();
        slider.control();
        slider.additionalControls();
      },
      control: function () {
        $body.on('click', '.owl-play', function () {
          slider.$slider = $(this).closest('.owl-carousel');
          slider.$slider.data('owl.carousel').options.autoplay = true;
          slider.$slider.trigger('refresh.owl.carousel'); //slider.$slider.trigger('play.owl.autoplay');
        });
        $body.on('click', '.owl-pause', function () {
          slider.$slider = $(this).closest('.owl-carousel');
          slider.$slider.trigger('stop.owl.autoplay');
        });
        $body.on('touchend', '.owl-pause, .owl-play, .owl-prev, .owl-next', function () {
          $(this).css('background', '#d6d6d6');
        });
        $('body').on('touchstart', '.owl-pause, .owl-play, .owl-prev, .owl-next', function () {
          $(this).css('background', '#869791');
        });
        $('.owl-carousel').each(function () {
          var $element = $(this);

          if (typeof $element.closest('.viewport-slider').data("slider-vport") != 'undefined') {
            slider.vPort = $element.closest('.viewport-slider').data("slider-vport");
            $(document).on(slider.vPort + '-on', function () {
              // Waiting for custom event that will be triggered by controller.js to activate responsive effects
              slider.isMobile = true;
              slider.get.options($element, true);
            });
            $(document).on(slider.vPort + '-off', function () {
              // Waiting for custom event that will be triggered by controller.js to deactivate responsive effects
              slider.isMobile = false;
              slider.on.destroy($element);
            });
          }
        });

        if ($('.owl-item:not(.cloned)').first().hasClass('active')) {
          $('.owl-nav .owl-next').addClass('owl-nav-active');
        }
      },
      additionalInit: function () {},
      additionalControls: function () {},
      beforeInitSlider: function ($element) {},

      /**
       * Accessibility for owl carousel
       * @namespace
       * @property {boolean} _flagChangeFocus - flag to inform translate to change focus, when we cannot pass this information in event
       */
      accessibility: {
        /**
         * @name _flagChangeFocus
         * @type Boolean
         * @default false
         * @protected
         */
        _flagChangeFocus: false,

        /**
         * Setup slider accessibility
         * @param {jQuery} $slider - jQuery object of Owl carousel container .owl-carousel
         * @public
         */
        setup: function ($slider) {
          // make slides accessible
          this.slider($slider); // apply meta info to next and previous buttons and make them focusable

          $slider.find('.owl-prev').attr({
            'role': 'button',
            'title': 'Go to previous slide',
            'aria-label': 'Go to previous slide',
            'tabindex': '0'
          });
          $slider.find('.owl-next').attr({
            'role': 'button',
            'title': 'Go to next slide',
            'aria-label': 'Go to next slide',
            'tabindex': '0'
          });
          $slider.find('.owl-dot').each(function () {
            var $dot = $(this);
            $dot.attr({
              'role': 'button',
              'title': 'Go to slide: ' + ($dot.index() + 1),
              'aria-label': 'Go to slide: ' + ($dot.index() + 1),
              'tabindex': '0'
            });
          }); // make root element focusable

          var $root = $slider.find('.owl-stage');
          var label = $slider.data('label') || "Slideshow";
          $root.attr({
            'role': 'listbox',
            'aria-label': label,
            // @todo aria-labeled-by if we have data for it, we don't right now
            'tabindex': '0'
          });
          $slider.find('.owl-item').attr({
            'role': 'option'
          }); // make root element id and use it for aria controls

          var id = $root.attr('id');

          if (!id) {
            id = 'slider' + UX.utils.generateId();
            $root.attr('id', id);
          } // make Controls to inform screen readers what they control


          $slider.find('.owl-nav, .owl-dots, .owl-controls').attr({
            'role': 'navigation',
            'aria-label': label,
            'aria-controls': id
          }); // listen for keyboard input

          this.keyboardControls($slider); // make slider accessible by tab key

          this.keyboardTabAccess($slider); // handle autoplay carousels

          this.handleAutoplay($slider); // make dots accessible

          this.dots($slider);
        },

        /**
         * Setup keyboard navigation for slider
         * @param {jQuery} $slider - jQuery object of Owl carousel container .owl-carousel
         * @protected
         */
        keyboardControls: function ($slider) {
          $slider.on('keydown', function (e) {
            slider.$slider = $(this);
            var $focusedElement = $(document.activeElement),
                type = e.which == 39 ? 'next' : null,
                type = e.which == 37 ? 'prev' : type,
                type = e.which == 13 ? 'enter' : type; // use left and right arrow keys to navigate

            if (type == 'next') {
              slider.accessibility._flagChangeFocus = true; // flag to change focus after change

              slider.$slider.trigger('next.owl.carousel');
            } else if (type == 'prev') {
              slider.accessibility._flagChangeFocus = true; // flag to change focus after change

              slider.$slider.trigger('prev.owl.carousel');
            } else if (type == 'enter') {
              // if the prev and next buttons are focused, catch "Enter" and navigate in the right direction
              e.preventDefault();

              if ($focusedElement.hasClass('owl-next')) {
                slider.$slider.trigger('next.owl.carousel');
              } else if ($focusedElement.hasClass('owl-prev')) {
                slider.$slider.trigger('prev.owl.carousel');
              } else if ($focusedElement.hasClass('owl-dot') || $focusedElement.hasClass('owl-play') || $focusedElement.hasClass('owl-pause')) {
                $focusedElement.trigger('click');
              }
            }
          });
          $slider.on('translated.owl.carousel', function (event) {
            // change focus to first tabbable element in slide
            if (slider.accessibility._flagChangeFocus) {
              slider.accessibility._flagChangeFocus = false;
              var $slide = $(event.target).find('.owl-item').eq(event.item.index);
              $slide.find(':tabbable').first().focus();
            }

            slider.accessibility.slider($slider);
          });
        },

        /**
         * Setup tab key access for slider
         * @param {jQuery} $slider - jQuery object of Owl carousel container .owl-carousel
         * @see inspired by Peppermint.js slider [https://wd.dizaina.net/en/scripts/peppermint/]
         * @protected
         */
        keyboardTabAccess: function ($slider) {
          $slider.find('.owl-item').each(function () {
            var slide = this;
            var $slide = $(slide); //IE fallback first

            slide.onfocusin = function () {
              slider.accessibility.slide($slide, 'enable');
              slider.accessibility.slide($slide, 'show');
              slider.$slider = $(this).closest('.owl-carousel');
              var oneOwl = slider.$slider.data('owl.carousel'),
                  stageToReset = slider.$slider.find('.owl-stage-outer')[0],
                  indexOfFocusedSlide = oneOwl.relative($(this).index()); //Reset the scroll

              stageToReset.scrollLeft = 0; //WebKit sets the scroll after the event, we need to reset it with zero timeout.
              //Keep the first reset to prevent jittering in other browsers

              setTimeout(function () {
                stageToReset.scrollLeft = 0;
              }, 0);

              if (!$(this).hasClass('active')) {
                // switch to the slide containing the event if is not visible already
                // last argument is to enforce "OLD" function for moving in slideshow, necesary for multiple slides displayed in same time
                // it is not documented anywhere, it comes from built-in plugin src/js/owl.navigation.js from method Navigation.prototype.to ....
                oneOwl.to(indexOfFocusedSlide, oneOwl.settings.smartSpeed ? oneOwl.settings.smartSpeed : 500, true);
              }
            }; //Now use the function bound to `onfocusin` in a regular `addEventListener`


            if (slide.addEventListener) slide.addEventListener('focus', slide.onfocusin, true); //`true` turns on the capturing
          });
        },

        /**
         * Make dots navigation accessible
         * @param $slider
         */
        dots: function ($slider) {
          $slider.find('.owl-dot').on('click', function () {
            /**
             * Solution for outlines here:
             *
             * Blur this, while we don't want to outline to be visible in this case
             * but we want to see outline when user cycle through page by tab key
             *
             * solution combined with CSS rule - to don't display outline, when mouse button is pressed
             *  .owl-dot:active:focus {
             *      outline: none;
             *  }
             *
             */
            $(this).blur();
            slider.accessibility._flagChangeFocus = true; // flag to change focus after change
          });
        },

        /**
         * Make controls accessible
         * @param $slider
         * @public
         */
        controls: function ($slider) {
          $slider.find('.owl-play').attr({
            'role': 'button',
            'title': 'Play slideshow',
            'aria-label': 'Play slideshow',
            'tabindex': '0'
          }).on('click', function () {
            $slider.removeAttr('data-pause');
          });
          $slider.find('.owl-pause').attr({
            'role': 'button',
            'title': 'Pause slideshow',
            'aria-label': 'Pause slideshow',
            'tabindex': '0'
          }).on('click', function () {
            $slider.attr({
              'data-pause': 'true'
            });
          });
        },

        /**
         * Pause on focus if auto-play is enabled
         * @see aria-live documentation
         * @param {jQuery} $slider
         */
        handleAutoplay: function ($slider) {
          var autoplay = $slider.data('autoplay');

          if (autoplay) {
            $slider.attr({
              'aria-live': 'off'
            });
            $slider.bind('focusin', function (event) {
              $(this).attr({
                'aria-live': 'polite'
              });

              if (event.target && ($(event.target).hasClass('owl-play') || $(event.target).hasClass('owl-pause'))) {
                // don't stop autoplay on controls
                return;
              }

              $(this).trigger('stop.owl.autoplay');
            }).bind('focusout', function () {
              if (!$slider.data('pause')) {
                $(this).trigger('play.owl.autoplay');
              }

              $(this).attr({
                'aria-live': 'off'
              });
            });
          }
        },

        /**
         * Set attributes for slider based on active slide
         * This is only wrapper function to avoid necessity of finding slides in function call
         * @param {jQuery} $slider - jQuery object of Owl carousel container .owl-carousel
         * @public
         */
        slider: function ($slider) {
          this.slides($slider.find('.owl-item'));
        },

        /**
         * Set attributes for slides based on active slide and cloned slides
         * This is the main logic for handling accessibility visibility to be correctly read by screen readers, etc.
         * @param {jQuery} $slides - jQuery collection of slides
         * @public
         */
        slides: function ($slides) {
          // hide all
          this.slide($slides, 'hide'); // disable cloned items to skip duplicate slides

          this.slide($slides.filter('.cloned'), 'disable'); // enable clone in case it becomes active

          this.slide($slides.filter('.cloned.active'), 'enable'); // show active

          this.slide($slides.filter('.active'));
        },

        /**
         * Handle one slide - mixed methods
         * @param {jQuery} $slide - collections of slides or one slide
         * @param {('show'|'hide'|'enable'|'disable')} [action] - available methods
         * @public
         */
        slide: function ($slide, action) {
          var actions = {
            /**
             * let screen readers know an item is active
             * set aria visible on active slide
             * @param {jQuery} $slide - collections of slides or one slide
             * @private
             */
            show: function ($slide) {
              $slide.attr('aria-selected', 'true');
              $slide.attr('aria-hidden', 'false');
            },

            /**
             * set aria hidden on all slides
             * @param {jQuery} $slide - collections of slides or one slide
             * @private
             */
            hide: function ($slide) {
              $slide.attr('aria-selected', 'false');
              $slide.attr('aria-hidden', 'true');
            },

            /**
             * enable tab index on in case it becomes active
             * @param {jQuery} $slide - collections of slides or one slide
             * @private
             */
            enable: function ($slide) {
              $slide.find('[data-was-tabbable]').removeAttr('tabindex').removeAttr('data-was-tabbable');
            },

            /**
             * disable tab index on items to skip duplicate slides in tab order
             * @param {jQuery} $slide - collections of slides or one slide
             * @private
             */
            disable: function ($slide) {
              $slide.find(':tabbable').attr('data-was-tabbable', true).attr('tabindex', '-1');
            }
          }; // actions logic

          if (typeof action === 'string') {
            if (typeof actions[action] === 'undefined') {
              throw new TypeError('No method named "' + action + '" found.');
            }

            actions[action]($slide);
          } else if (actions.show) {
            // default action
            actions.show($slide);
          }
        }
      },
      get: {
        options: function ($element, pass) {
          slider.$slider = $element;
          slider.speed = slider.$slider.data('speed');
          slider.autoplay = slider.$slider.data('autoplay');
          slider.animation = slider.$slider.data('animation');
          slider.autoWidth = slider.set.autoWidth();

          if (slider.animation === 'fade') {
            slider.animation = 'fadeOut';
          } else if (slider.animation === 'slide') {
            slider.animation = '';
          } else if (slider.animation === 'none') {
            slider.animation = 'fadeOut';
            slider.speed = 0;
          }

          slider.items = slider.$slider.data('items');
          slider.stagePadding = slider.$slider.data('stagepadding');
          slider.set.responsive();
          slider.indicators = slider.$slider.data('indicators');
          slider.arrow = slider.$slider.data('arrow');
          slider.controls = slider.$slider.data('controls');
          slider.autoHeight = slider.set.autoHeight();
          slider.dotsEach = slider.$slider.data('dotseach') != undefined ? slider.$slider.data('dotseach') : false;
          slider.lazyLoad = slider.$slider.closest('.lazyLoad-slides').length ? true : false;
          slider.center = slider.set.center();
          UX.slider.loop = UX.slider.$slider.data('loop');
          UX.slider.slideBy = UX.slider.$slider.data('slideby');
          slider.options = {
            center: slider.center,
            stagePadding: slider.stagePadding,
            loop: UX.slider.loop,
            items: slider.items,
            responsive: slider.responsive,
            autoplay: slider.autoplay,
            autoWidth: slider.autoWidth,
            animateOut: slider.animation,
            dots: slider.indicators,
            nav: slider.arrow,
            dotsEach: slider.dotsEach,
            slideBy: UX.slider.slideBy,
            autoHeight: slider.autoHeight,
            autoplayTimeout: slider.speed,
            autoplayHoverPause: slider.autoplay,
            navText: slider.navText,
            lazyLoad: slider.lazyLoad,
            onInitialize: function (event) {
              slider.on.sliderBeforeInit($(event.target));
            },
            onInitialized: function (event) {
              // allow slider accessibility
              slider.accessibility.setup(slider.$slider);
              slider.$slider.find('.owl-item.active').first().addClass("first");

              if (slider.$slider.closest('.equal-height-slides').length) {
                //make all slide same height if slide container contains ".equal-height-slides" class
                var sliderHeight = slider.$slider.height();

                if (sliderHeight > 0) {
                  slider.$slider.find('.owl-item', '.slide-item').css('height', slider.$slider.height());
                  slider.$slider.find('.slide-item').css('height', '100%');
                }
              }

              slider.on.sliderInit($(event.target));
            },
            onLoadedLazy: function () {
              var onLoadedLazy = false;

              if (!onLoadedLazy) {
                slider.$slider.trigger('refresh.owl.carousel');
                onLoadedLazy = true;
              }
            }
          };
          slider.on.activate(slider.$slider, pass);

          if (slider.controls) {
            slider.on.buildControls(slider.$slider);
          }
        },
        responsiveData: function () {
          if (slider.$slider.data('responsive')) {
            return slider.$slider.data('responsive');
          } else {
            var responsiveData = slider.$slider.closest('.responsive-slider').data("responsive");

            if (responsiveData) {
              return responsiveData;
            }
          }

          return null;
        }
      },
      set: {
        responsive: function () {
          slider.responsive = slider.get.responsiveData();

          if (slider.responsive) {
            for (var key in slider.responsive) {
              switch (key) {
                case "xsMin":
                  slider.responsive[0] = slider.responsive[key];
                  break;

                case "smMin":
                  slider.responsive[UX.grid.screenXs] = slider.responsive[key];
                  break;

                case "mdMin":
                  slider.responsive[UX.grid.screenSm] = slider.responsive[key];
                  break;

                case "lgMin":
                  slider.responsive[UX.grid.screenMd] = slider.responsive[key];
                  break;

                case "xlgMin":
                  slider.responsive[UX.grid.screenLg] = slider.responsive[key];
                  break;

                case "xxlgMin":
                  slider.responsive[UX.grid.screenXlg] = slider.responsive[key];
                  break;
              }
            }
          }
        },
        autoHeight: function () {
          var autoHeight = slider.$slider.closest('.autoheight-slider').data('autoheight');

          if (autoHeight != undefined) {
            return autoHeight;
          } else {
            return true;
          }
        },
        autoWidth: function () {
          return false;
        },
        center: function () {
          // if there is wrapper class 'center-slider' then set slider to be center
          return slider.$slider.closest('.center-slider').length > 0;
        }
      },
      on: {
        destroy: function ($element) {
          if (slider.vPort.length > 0) {
            $element.each(function () {
              if (!$(this).hasClass('slide-removal')) {
                $(this).addClass('slide-removal').trigger('destroy.owl.carousel');
                $(this).find('.owl-stage-outer').children(':eq(0)').unwrap();
              }
            });
          }
        },
        activate: function ($element, pass) {
          slider.beforeInitSlider($element);

          if (pass || slider.vPort == "always") {
            $element.owlCarousel(slider.options);

            if ($element.hasClass('slide-removal')) {
              $element.removeClass('slide-removal');
            }
          } else {
            if (!$element.hasClass('slide-removal')) {
              $element.addClass('slide-removal');
            }
          }
        },
        build: function () {
          $('.owl-carousel').each(function (index) {
            if (typeof $(this).closest('.viewport-slider').data("slider-vport") != 'undefined') {
              slider.vPort = $(this).closest('.viewport-slider').data("slider-vport");
            } else {
              slider.vPort = "always";
            }

            slider.get.options($(this), false);
            $(this).on('changed.owl.carousel', function (e) {
              slider.on.changedSlide($(this), e);
            });
            $(this).on('translated.owl.carousel', function (e) {
              slider.on.translated($(this));
            });
          });
        },
        translated: function ($slider) {
          $slider.find('.owl-item').removeClass('first');
          $slider.find('.owl-item.active').first().addClass('first');
        },
        changedSlide: function ($slider, e) {
          if ($slider.find('.owl-item:not(.cloned)').last().hasClass('active')) {
            $slider.find('.owl-nav .owl-next').addClass('owl-nav-active');
            $slider.find('.owl-nav .owl-prev').removeClass('owl-nav-active');
          } else if ($('.owl-item:not(.cloned)').first().hasClass('active')) {
            $slider.find('.owl-nav .owl-prev').addClass('owl-nav-active');
            $slider.find('.owl-nav .owl-next').removeClass('owl-nav-active');
          }
        },
        rebuild: {
          responsive: function () {}
        },
        buildControls: function (elem) {
          var $owlContainer = elem.find('.owl-stage-outer');

          if (elem.find('.owl-controls').length == 0) {
            $owlContainer.after('<div class="owl-controls"><div class="owl-play">Play</div><div class="owl-pause">Pause</div></div>');
          }

          slider.accessibility.controls(elem);
        },
        sliderInit: function ($slider) {},
        sliderBeforeInit: function ($slider) {}
      }
    };
    UX.slider = slider; // add to global namespace

    /* if (window.PB && window.PB.$) {
     // make this module reinitializes in pageBuilder mode
     window.PB.$(document.documentElement).on("WidgetReinit.slider", slider.init);
     }*/
  })();

  //Todo:After we remove the old LOI we should clean up this script and remove all code related to old loi
  //IN LIT-257898 I merged list-of-issues-detailed script and add here because list-of-issues-detailed.js  is already was overriding loi.js and it was confusing
  //After we remove list-of-issue folder we should copy this file with cleanup and put it under list-of-issues-detailed and modify the path for all ux3 products
  (function () {
    //document.activeElement
    var $body = $('body'),
        $window = $(window);
    var loi = {
      $wrapper: null,
      $list: null,
      $loiHolder: null,
      $controls: null,
      $nextBtn: null,
      $prevBtn: null,
      $listItem: null,
      revers: false,
      isTouched: false,
      pointerPosition: 0.0,
      cumulativeShift: 0.0,
      isMobile: false,
      vPort: "screen-sm",
      // default responsive break point
      year: null,
      // holds active year
      widgetId: null,
      // holds widget ID
      pagecontext: null,
      // holds page context
      doi: null,
      // holds DOI
      decade: null,
      // holds decade range
      wrapper: $(".loi-wrapper"),
      targetPane: null,
      url: "/specs/products/ux3/widgets/list-of-issues/templates/list-of-issues/ajax/2009.html",
      isNewLoi: false,
      init: function () {
        loi.$wrapper = $('.swipe__wrapper');
        loi.$list = $('.loi__list');
        loi.$loiHolder = $('.dropBlock-loi__holder');
        loi.$controls = '<div class="loi-list__controls"><span class="loi__btn--prev"><i class="icon-arrow_l" aria-hidden="true"></i></span><span class="loi__btn--next"><i class="icon-arrow_r" aria-hidden="true"></i></span></div>';
        loi.isNewLoi = $('.loi-wrapper').hasClass('list-of-issues-detailed');
        loi.addtionalInitialization();
        loi.on.build();
        loi.control();
        loi.addtionalControls();
        $window.on('resized', function () {
          loi.on.rebuild();
        });
        $window.load(function () {
          $('.loi__list:visible').each(function () {
            loi.on.recalculate($(this));
          });
        });
        $(".loi__archive").addClass("event-init");
        loi.on.pageLoad();
      },
      addtionalInitialization: function () {},
      ajaxResponse: function () {},
      control: function () {
        loi.$list.on('click', 'a', function (e) {
          loi.$listItem = $(this);
          loi.on.select();
        });
        $body.on('click', '.loi__btn--prev', function () {
          loi.$prevBtn = $(this);
          loi.on.prev();
        });
        $body.on('click', '.loi__btn--next', function () {
          loi.$nextBtn = $(this);
          loi.on.next();
        });
        $body.on('touchmove', function (e) {
          loi.on.touch.move(e);
        });
        loi.responsiveController();

        if (loi.isNewLoi) {
          // check if new loi or its the old one
          $body.on('click', '.list-of-issues-detailed .loi__list a', function () {
            //on click call
            var _this = $(this);

            var paneSlected = _this.data('target') ? _this.data('target') : _this.attr('href');

            if ($(paneSlected).hasClass('nested-tab')) {
              setTimeout(function () {
                //Need to check this code when we remove old loi
                var loiTabNav = '> .loi > .swipe__wrapper .tab__nav';
                loi.on.recalculate($(paneSlected).find(loiTabNav)); // to grab the first nav

                $(paneSlected).find('.tab__pane.active').find(loiTabNav).each(function () {
                  loi.on.recalculate($(this)); // to grab the nested navs
                });
              }, 50);
            }

            var tabTarget = _this.data('target'),
                currentTab = $(tabTarget),
                innerTabs = currentTab.find('.tab__nav'),
                selectionEnd = currentTab.parents('.loi-wrapper').length && currentTab.parents('.loi-wrapper').data('order') === 'ascendingOrder' ? 'last' : 'first';

            if (currentTab.length && innerTabs.length) {
              // find all tabs inside and selected actives
              var activeTabSource = currentTab.find('.tab__nav').find('li:' + selectionEnd + '-of-type a');
              var activeTab = activeTabSource.data('target') ? activeTabSource.data('target') : activeTabSource.attr('href');
              var triggerTarget = $('[data-target=\'' + activeTab + '\'], [href=\'' + activeTab + '\']');
              triggerTarget.click();
              return;
            }

            loi.wrapper = _this.closest('.loi-wrapper');
            loi.get.activeLink(_this);
            loi.set.historyState(_this);

            if (loi.link && $('.list-of-issues-detailed').attr('data-ajax') == 'ajax') {
              loi.load.ajax();
            }
          });
        } else {
          // this should be removed once we replace the new loi with the old one
          $body.on('click', '.tab__nav a', function () {
            var _this = $(this);

            var paneSlected = _this.data('target') ? _this.data('target') : _this.attr('href');

            if ($(paneSlected).hasClass('nested-tab')) {
              setTimeout(function () {
                //Need to check this code when we remove old loi
                var loiTabNav = '> .loi > .swipe__wrapper .tab__nav';
                loi.on.recalculate($(paneSlected).find(loiTabNav)); // to grab the first nav

                $(paneSlected).find('.tab__pane.active').find(loiTabNav).each(function () {
                  loi.on.recalculate($(this)); // to grab the nested navs
                });
              }, 50);
            }
          });
          $body.on('click', '.loi__list a', function () {
            loi.wrapper = $(this).closest(".loi-wrapper");

            if ($(this).closest(".tab__pane").length) {
              loi.get.activeDecade($(this));
              loi.get.year($(this));
            } else {
              loi.get.decade($(this));
              loi.get.activeYear($(this));
            }

            loi.get.doi();
            loi.get.pagecontext();
            loi.get.url();

            if (loi.wrapper.find(".dropBlock-loi__holder").length) {
              var type = loi.wrapper.find(".dropBlock-loi__holder").attr("data-grouptype");
            } else {
              var type = loi.wrapper.attr("data-grouptype");
            }

            if (type == "decade") {
              if (loi.year && loi.decade && loi.pagecontext && loi.doi) {
                loi.load.ajax();
              }
            }
          });
        }
      },
      responsiveController: function () {
        $(document).on(loi.vPort + '-on', function () {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          loi.isMobile = true;
          $('.loi').addClass("loi--res"); // class will be used in our scss (to replace media queries)

          $('.loi__banner').addClass("loi--res"); // class will be used in our scss (to replace media queries)

          if ($('.corrections-container__label').length > 0) {
            $('.corrections-container__label').addClass('w-slide__btn slide-active');
          }
        });
        $(document).on(loi.vPort + '-off', function () {
          // Waiting for custom event that will be triggered by controller.js to deactivate responsive effects
          loi.isMobile = false;
          $('.loi').removeClass("loi--res");
          $('.loi__banner').removeClass("loi--res");

          if ($('.corrections-container__label').length > 0) {
            $('.corrections-container__label').removeClass('w-slide__btn slide-active');
          }
        });
      },
      addtionalControls: function () {},
      on: {
        select: function () {
          loi.$list = loi.$listItem.closest('.swipe__wrapper').find('.loi__list');
          loi.$nextBtn = loi.$listItem.closest('.swipe__wrapper').find('.loi__btn--next');
          loi.$prevBtn = loi.$listItem.closest('.swipe__wrapper').find('.loi__btn--prev');
          loi.$scroll = loi.$list.closest('.scroll');
          var thisLinkPosition = loi.$listItem.offset().left;
          var nextButtonPosition = loi.$nextBtn.offset().left;
          var prevButtonPosition = loi.$prevBtn.offset().left;

          if (thisLinkPosition > nextButtonPosition - loi.$listItem.outerWidth()) {
            loi.$scroll.stop().animate({
              scrollLeft: '+=' + loi.$listItem.outerWidth()
            }, 500, 'linear', function () {
              loi.on.activeArrows();
            });
          } else if (thisLinkPosition < prevButtonPosition + loi.$prevBtn.outerWidth()) {
            loi.$scroll.stop().animate({
              scrollLeft: '-=' + loi.$listItem.outerWidth()
            }, 500, 'linear', function () {
              loi.on.activeArrows();
            });
          }
        },
        next: function () {
          loi.$list = loi.$nextBtn.closest('.swipe__wrapper').find('.loi__list');
          loi.$prevBtn = loi.$list.closest('.loi-list__wrapper').find('.loi__btn--prev');
          loi.$scroll = loi.$list.closest('.scroll');
          var screenSize = loi.$scroll.width();
          var shiftSize = screenSize - 20; /// 3;

          if (!loi.$nextBtn.hasClass('inactive')) {
            loi.$scroll.stop().animate({
              scrollLeft: '+=' + shiftSize
            }, 500, 'linear', function () {
              loi.on.activeArrows();
            });
          }
        },
        prev: function () {
          loi.$list = loi.$prevBtn.closest('.swipe__wrapper').find('.loi__list');
          loi.$nextBtn = loi.$list.closest('.loi-list__wrapper').find('.loi__btn--next');
          loi.$scroll = loi.$list.closest('.scroll');
          var screenSize = loi.$scroll.width();
          var shiftSize = screenSize - 20; /// 3;

          loi.$scroll.stop().animate({
            scrollLeft: '-=' + shiftSize
          }, 500, 'linear', function () {
            loi.on.activeArrows();
          });
        },
        touch: {
          move: function (e) {
            if ($(e.target).closest('.loi__list').length || $(e.target).hasClass('loi__list')) {
              loi.$list = $(e.target).closest('.loi__list');
              loi.$wrapper = $(e.target).closest('.loi-list__wrapper');
              loi.$nextBtn = $(e.target).closest('.loi-list__wrapper').find('.loi__btn--next');
              loi.$prevBtn = $(e.target).closest('.loi-list__wrapper').find('.loi__btn--prev');
              loi.on.activeArrows();
            }
          }
        },
        escape: function () {},
        tab: function () {},
        tabRevers: function () {},
        activeArrows: function () {
          loi.$scroll = loi.$list.closest('.scroll');

          if (parseInt(loi.$scroll.scrollLeft()) > 0) {
            loi.$prevBtn.removeClass('inactive');
          } else {
            loi.$prevBtn.addClass('inactive');
          }

          var sliderSize = loi.$list.width();
          var wrapperSize = loi.$wrapper.width() + 10;

          if (parseInt(loi.$scroll.scrollLeft()) > parseInt(sliderSize - wrapperSize)) {
            loi.$nextBtn.addClass('inactive');
          } else {
            loi.$nextBtn.removeClass('inactive');
          }
        },
        build: function () {
          //setTimeout(function () {
          loi.$wrapper = loi.$list.closest('.swipe__wrapper');
          loi.$wrapper.addClass('loi-list__wrapper');
          loi.$list.each(function (index) {
            var loiListWidth = $(this).width();

            if (loiListWidth > loi.$wrapper.width()) {
              $(this).closest('.swipe__wrapper').prepend(loi.$controls);
            }

            $('.loi__btn--prev').addClass('inactive');
          }); //}, 250);

          loi.$nextBtn = $('.loi__btn--next');
          loi.$prevBtn = $('.loi__btn--prev');

          if ($('.journal-home').length) {
            loi.vPort = "screen-md";
          }
        },
        rebuild: function () {
          $('.loi-list__controls').remove();
          loi.$list = $('.loi__list');
          loi.$list.each(function (index) {
            var loiListWidth = $(this).width();

            if (loiListWidth > loi.$wrapper.width()) {
              $(this).closest('.swipe__wrapper').prepend(loi.$controls);
              $('.loi__btn--prev').addClass('inactive');
            } else {
              $(this).closest('.swipe__wrapper').find('.loi-list__controls').remove();
            }
          });
        },
        recalculate: function (elem) {
          var tabNavWidth = 25;
          elem.find('li').each(function (index) {
            tabNavWidth += $(this).innerWidth();
          });
          elem.width(tabNavWidth);
          loi.$wrapper = elem.closest('.swipe__wrapper').addClass('loi-list__wrapper');

          if (tabNavWidth > loi.$wrapper.width()) {
            if (elem.closest('.swipe__wrapper').find('.loi-list__controls').length == 0) {
              elem.closest('.swipe__wrapper').prepend(loi.$controls);
            }

            $('.loi__btn--prev').addClass('inactive');
          } else {
            elem.closest('.swipe__wrapper').find('.loi-list__controls').remove();
          }
        },
        pageLoad: function () {
          var qs = window.location.search.substr(1);
          var qsParams = {};
          qs.split('&').map(function (param) {
            var keyVal = param.split('=');
            qsParams[keyVal[0]] = keyVal[1];
          });
          loi.$loiHolder.each(function (index, elem) {
            var groupType = $(elem).attr('data-grouptype');
            var $loiBanner = $(elem).prev('.loi__banner-list');

            if (qsParams.year) {
              if (groupType === 'decade') {
                var $yearElem = $('[data-expand=' + qsParams.year + ']', elem);

                if ($yearElem.length) {
                  var decadeElemId = $yearElem.closest('li[role=tabpanel]').attr('id');
                  var $decadeElem = $('a[href$=#' + decadeElemId + ']', elem);
                  $('.loi__archive', $loiBanner).trigger('click');

                  if ($decadeElem.length) {
                    $decadeElem.trigger('focus').trigger('click');
                  }

                  setTimeout(function () {
                    $yearElem.trigger('focus').trigger('click');
                  }, 100);
                }
              } else if (groupType === 'year') {
                $('.loi__archive', $loiBanner).trigger('click');
                $('[data-expand=' + qsParams.year + ']', elem).trigger('focus').trigger('click');
              }
            }

            if (qsParams.volume) {
              if (groupType === 'volume') {
                $('.loi__archive', $loiBanner).trigger('click');
                $('[data-expand=' + qsParams.volume + ']', elem).trigger('click');
              }
            }
          });
        }
      },
      load: {
        ajax: function () {
          if ($(loi.targetPane).is(':empty') || $(loi.targetPane).children("ul").is(':empty')) {
            if (loi.isNewLoi) {
              loi.get.doi();
              loi.get.pagecontext();
              loi.get.url();
            }

            $('.tab__pane').removeClass("loading");
            $(loi.targetPane).addClass("loading");
            $(loi.targetPane).load(loi.url, function (response, status, xhr) {
              if (status == "error") {
                var msg = "Sorry but there was an error: ";
                console.log(msg + xhr.status + " " + xhr.statusText + "==========" + loi.url);
              }

              $(loi.targetPane).removeClass("loading");
              loi.ajaxResponse();
            });
          }
        }
      },
      get: {
        year: function (element) {
          // get year from selected
          loi.year = element.find("span").text();
          loi.targetPane = element.attr("href");
        },
        activeDecade: function (element) {
          // get active decade based on selected element
          var parent = element.closest(".tab__pane").attr("aria-labelledby");
          loi.decade = $("#" + parent).data("decade") ? $("#" + parent).data("decade") : $("#" + parent).find("span").text();
        },
        decade: function (element) {
          // get decade from selected
          loi.decade = element.data("decade") ? element.data("decade") : element.find("span").text();
        },
        activeYear: function (element) {
          // get active year based in selected element
          var child = element.attr("href");
          loi.year = $(child).find(".loi__list").find(".active").find("span").text();
          loi.targetPane = $(child).find(".loi__list").find(".active").find("a").attr("href");
        },
        url: function () {
          if (loi.isNewLoi) {
            loi.widgetId = $('.loi-wrapper').attr('data-db-parent-of'); //get widget ID

            if (loi.widgetId == undefined) {
              loi.widgetId = loi.wrapper.attr('data-widget-id'); //get widget ID
            }

            loi.url = '/pb/widgets/loi/content?widgetId=' + loi.widgetId + '&pbContext=' + loi.pagecontext.replace(/#/g, '%23') + '&id=' + loi.link; // The hash is not encoded in pbContext
          } else {
            //This for old loi it should removed
            loi.widgetId = loi.wrapper.attr("data-db-parent-of"); //get widget ID

            if (loi.widgetId == undefined) {
              loi.widgetId = loi.wrapper.attr("data-widget-id"); //get widget ID
            }

            loi.url = "/pb/widgets/loi/loiAjax?widgetId=" + loi.widgetId + "&pbContext=" + loi.pagecontext + "&doi=" + loi.doi + "&decadeRange=" + loi.decade + "&yearParam=" + loi.year; // group all needed parameters
          }
        },
        doi: function () {
          loi.doi = loi.wrapper.attr("data-journal-doi");
        },
        pagecontext: function () {
          loi.pagecontext = encodeURI($("[name='pbContext']").attr("content")); // get page context
        },
        activeLink: function (element) {
          // clicked item
          if (element.attr('data-url')) {
            var itemLink = element.attr('data-url'),
                targetSource = element.data('target');
            loi.link = itemLink;
            loi.targetPane = $(targetSource);
          } else {
            //Todo:check if this code needed!
            var itemLink = element.attr('href'),
                targetSource = $(itemLink).find('.tab__nav .active a.empty');
            loi.targetPane = targetSource.data('target') ? targetSource.data('target') : targetSource.attr('href');
            loi.link = targetSource.attr('data-url');
          }
        }
      },
      set: {
        historyState: function (element) {
          var href = element.attr('href');

          if (href) {
            history.replaceState(null, 'loi history', href);
          }
        }
      },
      check: {
        viewPort: function () {
          $('.loi').each(function () {
            if ($(this).attr('data-ctrl-res')) {
              loi.vPort = $(this).attr('data-ctrl-res');
            }
          });
        }
      }
    };
    UX.loi = loi; // add to global namespace
  })();

  (function () {
    var trustedPoxy = {
      init: function () {
        trustedPoxy.control();
      },
      control: function () {
        $(document).on('change', '.trustedProxyUserId', function () {
          this.closest('form').submit();
        });
      }
    };
    UX.trustedPoxy = trustedPoxy; // add to global namespace
  })();

  $(document).ready(function () {
    $('.registration__personal .registration__button').on('click', function (e) {
      e.preventDefault();
      alert('Registration magic happens'); //TODO: For testing purposes only, obviously. Delete after registration procedure is implemented

      $(this).parents('.row').slideUp(200);
      $(this).parents('.row').next().find('.accordion__control').click();
    });
  });

  /**
   * Multiple Selection Component for Bootstrap
   * Check nicolasbize.github.io/magicsuggest/ for latest updates.
   *
   * Author:       Nicolas Bize
   * Created:      Feb 8th 2013
   * Last Updated: Oct 16th 2014
   * Version:      2.1.4
   * Licence:      MagicSuggest is licenced under MIT licence (http://opensource.org/licenses/MIT)
   */
  (function ($) {

    var MagicSuggest = function (element, options) {
      var ms = this;
      /**
       * Initializes the MagicSuggest component
       */

      var defaults = {
        /**********  CONFIGURATION PROPERTIES ************/

        /**
         * Restricts or allows the user to validate typed entries.
         * Defaults to true.
         */
        allowFreeEntries: true,

        /**
         * Restricts or allows the user to add the same entry more than once
         * Defaults to false.
         */
        allowDuplicates: false,

        /**
         * Additional config object passed to each $.ajax call
         */
        ajaxConfig: {},

        /**
         * If a single suggestion comes out, it is preselected.
         */
        autoSelect: true,

        /**
         * Auto select the first matching item with multiple items shown
         */
        selectFirst: false,

        /**
         * Allow customization of query parameter
         */
        queryParam: 'query',

        /**
         * A function triggered just before the ajax request is sent, similar to jQuery
         */
        beforeSend: function () {},

        /**
         * A custom CSS class to apply to the field's underlying element.
         */
        cls: '',

        /**
         * JSON Data source used to populate the combo box. 3 options are available here:
         * No Data Source (default)
         *    When left null, the combo box will not suggest anything. It can still enable the user to enter
         *    multiple entries if allowFreeEntries is * set to true (default).
         * Static Source
         *    You can pass an array of JSON objects, an array of strings or even a single CSV string as the
         *    data source.For ex. data: [* {id:0,name:"Paris"}, {id: 1, name: "New York"}]
         *    You can also pass any json object with the results property containing the json array.
         * Url
         *     You can pass the url from which the component will fetch its JSON data.Data will be fetched
         *     using a POST ajax request that will * include the entered text as 'query' parameter. The results
         *     fetched from the server can be:
         *     - an array of JSON objects (ex: [{id:...,name:...},{...}])
         *     - a string containing an array of JSON objects ready to be parsed (ex: "[{id:...,name:...},{...}]")
         *     - a JSON object whose data will be contained in the results property
         *      (ex: {results: [{id:...,name:...},{...}]
         * Function
         *     You can pass a function which returns an array of JSON objects  (ex: [{id:...,name:...},{...}])
         *     The function can return the JSON data or it can use the first argument as function to handle the data.
         *     Only one (callback function or return value) is needed for the function to succeed.
         *     See the following example:
         *     function (response) { var myjson = [{name: 'test', id: 1}]; response(myjson); return myjson; }
         */
        data: null,

        /**
         * Additional parameters to the ajax call
         */
        dataUrlParams: {},

        /**
         * Start the component in a disabled state.
         */
        disabled: false,

        /**
         * Name of JSON object property that defines the disabled behaviour
         */
        disabledField: null,

        /**
         * Name of JSON object property displayed in the combo list
         */
        displayField: 'name',

        /**
         * Set to false if you only want mouse interaction. In that case the combo will
         * automatically expand on focus.
         */
        editable: true,

        /**
         * Set starting state for combo.
         */
        expanded: false,

        /**
         * Automatically expands combo on focus.
         */
        expandOnFocus: false,

        /**
         * JSON property by which the list should be grouped
         */
        groupBy: null,

        /**
         * Set to true to hide the trigger on the right
         */
        hideTrigger: false,

        /**
         * Set to true to highlight search input within displayed suggestions
         */
        highlight: true,

        /**
         * A custom ID for this component
         */
        id: null,

        /**
         * A class that is added to the info message appearing on the top-right part of the component
         */
        infoMsgCls: '',

        /**
         * Additional parameters passed out to the INPUT tag. Enables usage of AngularJS's custom tags for ex.
         */
        inputCfg: {},

        /**
         * The class that is applied to show that the field is invalid
         */
        invalidCls: 'ms-inv',

        /**
         * Set to true to filter data results according to case. Useless if the data is fetched remotely
         */
        matchCase: false,

        /**
         * Once expanded, the combo's height will take as much room as the # of available results.
         *    In case there are too many results displayed, this will fix the drop down height.
         */
        maxDropHeight: 290,

        /**
         * Defines how long the user free entry can be. Set to null for no limit.
         */
        maxEntryLength: null,

        /**
         * A function that defines the helper text when the max entry length has been surpassed.
         */
        maxEntryRenderer: function (v) {
          return 'Please reduce your entry by ' + v + ' character' + (v > 1 ? 's' : '');
        },

        /**
         * The maximum number of results displayed in the combo drop down at once.
         */
        maxSuggestions: null,

        /**
         * The maximum number of items the user can select if multiple selection is allowed.
         *    Set to null to remove the limit.
         */
        maxSelection: 10,

        /**
         * A function that defines the helper text when the max selection amount has been reached. The function has a single
         *    parameter which is the number of selected elements.
         */
        maxSelectionRenderer: function (v) {
          return 'You cannot choose more than ' + v + ' item' + (v > 1 ? 's' : '');
        },

        /**
         * The method used by the ajax request.
         */
        method: 'POST',

        /**
         * The minimum number of characters the user must type before the combo expands and offers suggestions.
         */
        minChars: 0,

        /**
         * A function that defines the helper text when not enough letters are set. The function has a single
         *    parameter which is the difference between the required amount of letters and the current one.
         */
        minCharsRenderer: function (v) {
          return 'Please type ' + v + ' more character' + (v > 1 ? 's' : '');
        },

        /**
         * Whether or not sorting / filtering should be done remotely or locally.
         * Use either 'local' or 'remote'
         */
        mode: 'local',

        /**
         * The name used as a form element.
         */
        name: null,

        /**
         * The text displayed when there are no suggestions.
         */
        noSuggestionText: 'No suggestions',

        /**
         * The default placeholder text when nothing has been entered
         */
        placeholder: 'Type or click here',

        /**
         * A function used to define how the items will be presented in the combo
         */
        renderer: null,

        /**
         * Whether or not this field should be required
         */
        required: false,

        /**
         * Set to true to render selection as a delimited string
         */
        resultAsString: false,

        /**
         * Text delimiter to use in a delimited string.
         */
        resultAsStringDelimiter: ',',

        /**
         * Name of JSON object property that represents the list of suggested objects
         */
        resultsField: 'results',

        /**
         * A custom CSS class to add to a selected item
         */
        selectionCls: '',

        /**
         * An optional element replacement in which the selection is rendered
         */
        selectionContainer: null,

        /**
         * Where the selected items will be displayed. Only 'right', 'bottom' and 'inner' are valid values
         */
        selectionPosition: 'inner',

        /**
         * A function used to define how the items will be presented in the tag list
         */
        selectionRenderer: null,

        /**
         * Set to true to stack the selectioned items when positioned on the bottom
         *    Requires the selectionPosition to be set to 'bottom'
         */
        selectionStacked: false,

        /**
         * Direction used for sorting. Only 'asc' and 'desc' are valid values
         */
        sortDir: 'asc',

        /**
         * name of JSON object property for local result sorting.
         *    Leave null if you do not wish the results to be ordered or if they are already ordered remotely.
         */
        sortOrder: null,

        /**
         * If set to true, suggestions will have to start by user input (and not simply contain it as a substring)
         */
        strictSuggest: false,

        /**
         * Custom style added to the component container.
         */
        style: '',

        /**
         * If set to true, the combo will expand / collapse when clicked upon
         */
        toggleOnClick: false,

        /**
         * Amount (in ms) between keyboard registers.
         */
        typeDelay: 400,

        /**
         * If set to true, tab won't blur the component but will be registered as the ENTER key
         */
        useTabKey: false,

        /**
         * If set to true, using comma will validate the user's choice
         */
        useCommaKey: true,

        /**
         * Determines whether or not the results will be displayed with a zebra table style
         */
        useZebraStyle: false,

        /**
         * initial value for the field
         */
        value: null,

        /**
         * name of JSON object property that represents its underlying value
         */
        valueField: 'id',

        /**
         * regular expression to validate the values against
         */
        vregex: null,

        /**
         * type to validate against
         */
        vtype: null
      };
      var conf = $.extend({}, options);
      var cfg = $.extend(true, {}, defaults, conf);
      /**********  PUBLIC METHODS ************/

      /**
       * Add one or multiple json items to the current selection
       * @param items - json object or array of json objects
       * @param isSilent - (optional) set to true to suppress 'selectionchange' event from being triggered
       */

      this.addToSelection = function (items, isSilent) {
        if (!cfg.maxSelection || _selection.length < cfg.maxSelection) {
          if (!$.isArray(items)) {
            items = [items];
          }

          var valuechanged = false;
          $.each(items, function (index, json) {
            if (cfg.allowDuplicates || $.inArray(json[cfg.valueField], ms.getValue()) === -1) {
              _selection.push(json);

              valuechanged = true;
            }
          });

          if (valuechanged === true) {
            self._renderSelection();

            this.empty();

            if (isSilent !== true) {
              $(this).trigger('selectionchange', [this, this.getSelection()]);
            }
          }
        }

        this.input.attr('placeholder', cfg.selectionPosition === 'inner' && this.getValue().length > 0 ? '' : cfg.placeholder);
      };
      /**
       * Clears the current selection
       * @param isSilent - (optional) set to true to suppress 'selectionchange' event from being triggered
       */


      this.clear = function (isSilent) {
        this.removeFromSelection(_selection.slice(0), isSilent); // clone array to avoid concurrency issues
      };
      /**
       * Collapse the drop down part of the combo
       */


      this.collapse = function () {
        if (cfg.expanded === true) {
          this.combobox.detach();
          cfg.expanded = false;
          $(this).trigger('collapse', [this]);
        }
      };
      /**
       * Set the component in a disabled state.
       */


      this.disable = function () {
        this.container.addClass('ms-ctn-disabled');
        cfg.disabled = true;
        ms.input.attr('disabled', true);
      };
      /**
       * Empties out the combo user text
       */


      this.empty = function () {
        this.input.val('');
      };
      /**
       * Set the component in a enable state.
       */


      this.enable = function () {
        this.container.removeClass('ms-ctn-disabled');
        cfg.disabled = false;
        ms.input.attr('disabled', false);
      };
      /**
       * Expand the drop drown part of the combo.
       */


      this.expand = function () {
        if (!cfg.expanded && (this.input.val().length >= cfg.minChars || this.combobox.children().size() > 0)) {
          this.combobox.appendTo(this.container);

          self._processSuggestions();

          cfg.expanded = true;
          $(this).trigger('expand', [this]);
        }
      };
      /**
       * Retrieve component enabled status
       */


      this.isDisabled = function () {
        return cfg.disabled;
      };
      /**
       * Checks whether the field is valid or not
       * @return {boolean}
       */


      this.isValid = function () {
        var valid = cfg.required === false || _selection.length > 0;

        if (cfg.vtype || cfg.vregex) {
          $.each(_selection, function (index, item) {
            valid = valid && self._validateSingleItem(item[cfg.valueField]);
          });
        }

        return valid;
      };
      /**
       * Gets the data params for current ajax request
       */


      this.getDataUrlParams = function () {
        return cfg.dataUrlParams;
      };
      /**
       * Gets the name given to the form input
       */


      this.getName = function () {
        return cfg.name;
      };
      /**
       * Retrieve an array of selected json objects
       * @return {Array}
       */


      this.getSelection = function () {
        return _selection;
      };
      /**
       * Retrieve the current text entered by the user
       */


      this.getRawValue = function () {
        return ms.input.val();
      };
      /**
       * Retrieve an array of selected values
       */


      this.getValue = function () {
        return $.map(_selection, function (o) {
          return o[cfg.valueField];
        });
      };
      /**
       * Remove one or multiples json items from the current selection
       * @param items - json object or array of json objects
       * @param isSilent - (optional) set to true to suppress 'selectionchange' event from being triggered
       */


      this.removeFromSelection = function (items, isSilent) {
        if (!$.isArray(items)) {
          items = [items];
        }

        var valuechanged = false;
        $.each(items, function (index, json) {
          var i = $.inArray(json[cfg.valueField], ms.getValue());

          if (i > -1) {
            _selection.splice(i, 1);

            valuechanged = true;
          }
        });

        if (valuechanged === true) {
          self._renderSelection();

          if (isSilent !== true) {
            $(this).trigger('selectionchange', [this, this.getSelection()]);
          }

          if (cfg.expandOnFocus) {
            ms.expand();
          }

          if (cfg.expanded) {
            self._processSuggestions();
          }
        }

        this.input.attr('placeholder', cfg.selectionPosition === 'inner' && this.getValue().length > 0 ? '' : cfg.placeholder);
      };
      /**
       * Get current data
       */


      this.getData = function () {
        return _cbData;
      };
      /**
       * Set up some combo data after it has been rendered
       * @param data
       */


      this.setData = function (data) {
        cfg.data = data;

        self._processSuggestions();
      };
      /**
       * Sets the name for the input field so it can be fetched in the form
       * @param name
       */


      this.setName = function (name) {
        cfg.name = name;

        if (name) {
          cfg.name += name.indexOf('[]') > 0 ? '' : '[]';
        }

        if (ms._valueContainer) {
          $.each(ms._valueContainer.children(), function (i, el) {
            el.name = cfg.name;
          });
        }
      };
      /**
       * Sets the current selection with the JSON items provided
       * @param items
       */


      this.setSelection = function (items) {
        this.clear();
        this.addToSelection(items);
      };
      /**
       * Sets a value for the combo box. Value must be an array of values with data type matching valueField one.
       * @param data
       */


      this.setValue = function (values) {
        var items = [];
        $.each(values, function (index, value) {
          // first try to see if we have the full objects from our data set
          var found = false;
          $.each(_cbData, function (i, item) {
            if (item[cfg.valueField] == value) {
              items.push(item);
              found = true;
              return false;
            }
          });

          if (!found) {
            if (typeof value === 'object') {
              items.push(value);
            } else {
              var json = {};
              json[cfg.valueField] = value;
              json[cfg.displayField] = value;
              items.push(json);
            }
          }
        });

        if (items.length > 0) {
          this.addToSelection(items);
        }
      };
      /**
       * Sets data params for subsequent ajax requests
       * @param params
       */


      this.setDataUrlParams = function (params) {
        cfg.dataUrlParams = $.extend({}, params);
      };
      /**********  PRIVATE ************/


      var _selection = [],
          // selected objects
      _comboItemHeight = 0,
          // height for each combo item.
      _timer,
          _hasFocus = false,
          _groups = null,
          _cbData = [],
          _ctrlDown = false,
          KEYCODES = {
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        CTRL: 17,
        ESC: 27,
        SPACE: 32,
        UPARROW: 38,
        DOWNARROW: 40,
        COMMA: 188
      };

      var self = {
        /**
         * Empties the result container and refills it with the array of json results in input
         * @private
         */
        _displaySuggestions: function (data) {
          ms.combobox.show();
          ms.combobox.empty();
          var resHeight = 0,
              // total height taken by displayed results.
          nbGroups = 0;

          if (_groups === null) {
            self._renderComboItems(data);

            resHeight = _comboItemHeight * data.length;
          } else {
            for (var grpName in _groups) {
              nbGroups += 1;
              $('<div/>', {
                'class': 'ms-res-group',
                html: grpName
              }).appendTo(ms.combobox);

              self._renderComboItems(_groups[grpName].items, true);
            }

            var _groupItemHeight = ms.combobox.find('.ms-res-group').outerHeight();

            if (_groupItemHeight !== null) {
              var tmpResHeight = nbGroups * _groupItemHeight;
              resHeight = _comboItemHeight * data.length + tmpResHeight;
            } else {
              resHeight = _comboItemHeight * (data.length + nbGroups);
            }
          }

          if (resHeight < ms.combobox.height() || resHeight <= cfg.maxDropHeight) {
            ms.combobox.height(resHeight);
          } else if (resHeight >= ms.combobox.height() && resHeight > cfg.maxDropHeight) {
            ms.combobox.height(cfg.maxDropHeight);
          }

          if (data.length === 1 && cfg.autoSelect === true) {
            ms.combobox.children().filter(':not(.ms-res-item-disabled):last').addClass('ms-res-item-active');
          }

          if (cfg.selectFirst === true) {
            ms.combobox.children().filter(':not(.ms-res-item-disabled):first').addClass('ms-res-item-active');
          }

          if (data.length === 0 && ms.getRawValue() !== "") {
            var noSuggestionText = cfg.noSuggestionText.replace(/\{\{.*\}\}/, ms.input.val());

            self._updateHelper(noSuggestionText);

            ms.collapse();
          } // When free entry is off, add invalid class to input if no data matches


          if (cfg.allowFreeEntries === false) {
            if (data.length === 0) {
              $(ms.input).addClass(cfg.invalidCls);
              ms.combobox.hide();
            } else {
              $(ms.input).removeClass(cfg.invalidCls);
            }
          }
        },

        /**
         * Returns an array of json objects from an array of strings.
         * @private
         */
        _getEntriesFromStringArray: function (data) {
          var json = [];
          $.each(data, function (index, s) {
            var entry = {};
            entry[cfg.displayField] = entry[cfg.valueField] = $.trim(s);
            json.push(entry);
          });
          return json;
        },

        /**
         * Replaces html with highlighted html according to case
         * @param html
         * @private
         */
        _highlightSuggestion: function (html) {
          var q = ms.input.val(); //escape special regex characters

          var specialCharacters = ['^', '$', '*', '+', '?', '.', '(', ')', ':', '!', '|', '{', '}', '[', ']'];
          $.each(specialCharacters, function (index, value) {
            q = q.replace(value, "\\" + value);
          });

          if (q.length === 0) {
            return html; // nothing entered as input
          }

          var glob = cfg.matchCase === true ? 'g' : 'gi';
          return html.replace(new RegExp('(' + q + ')(?!([^<]+)?>)', glob), '<em>$1</em>');
        },

        /**
         * Moves the selected cursor amongst the list item
         * @param dir - 'up' or 'down'
         * @private
         */
        _moveSelectedRow: function (dir) {
          if (!cfg.expanded) {
            ms.expand();
          }

          var list, start, active, scrollPos;
          list = ms.combobox.find(".ms-res-item:not(.ms-res-item-disabled)");

          if (dir === 'down') {
            start = list.eq(0);
          } else {
            start = list.filter(':last');
          }

          active = ms.combobox.find('.ms-res-item-active:not(.ms-res-item-disabled):first');

          if (active.length > 0) {
            if (dir === 'down') {
              start = active.nextAll('.ms-res-item:not(.ms-res-item-disabled)').first();

              if (start.length === 0) {
                start = list.eq(0);
              }

              scrollPos = ms.combobox.scrollTop();
              ms.combobox.scrollTop(0);

              if (start[0].offsetTop + start.outerHeight() > ms.combobox.height()) {
                ms.combobox.scrollTop(scrollPos + _comboItemHeight);
              }
            } else {
              start = active.prevAll('.ms-res-item:not(.ms-res-item-disabled)').first();

              if (start.length === 0) {
                start = list.filter(':last');
                ms.combobox.scrollTop(_comboItemHeight * list.length);
              }

              if (start[0].offsetTop < ms.combobox.scrollTop()) {
                ms.combobox.scrollTop(ms.combobox.scrollTop() - _comboItemHeight);
              }
            }
          }

          list.removeClass("ms-res-item-active");
          start.addClass("ms-res-item-active");
        },

        /**
         * According to given data and query, sort and add suggestions in their container
         * @private
         */
        _processSuggestions: function (source) {
          var json = null,
              data = source || cfg.data;

          if (data !== null) {
            if (typeof data === 'function') {
              data = data.call(ms, ms.getRawValue());
            }

            if (typeof data === 'string') {
              // get results from ajax
              $(ms).trigger('beforeload', [ms]);
              var queryParams = {};
              queryParams[cfg.queryParam] = ms.input.val();
              var params = $.extend(queryParams, cfg.dataUrlParams);
              $.ajax($.extend({
                type: cfg.method,
                url: data,
                data: params,
                beforeSend: cfg.beforeSend,
                success: function (asyncData) {
                  json = typeof asyncData === 'string' ? JSON.parse(asyncData) : asyncData;

                  self._processSuggestions(json);

                  $(ms).trigger('load', [ms, json]);

                  if (self._asyncValues) {
                    ms.setValue(typeof self._asyncValues === 'string' ? JSON.parse(self._asyncValues) : self._asyncValues);

                    self._renderSelection();

                    delete self._asyncValues;
                  }
                },
                error: function () {
                  throw "Could not reach server";
                }
              }, cfg.ajaxConfig));
              return;
            } else {
              // results from local array
              if (data.length > 0 && typeof data[0] === 'string') {
                // results from array of strings
                _cbData = self._getEntriesFromStringArray(data);
              } else {
                // regular json array or json object with results property
                _cbData = data[cfg.resultsField] || data;
              }
            }

            var sortedData = cfg.mode === 'remote' ? _cbData : self._sortAndTrim(_cbData);

            self._displaySuggestions(self._group(sortedData));
          }
        },

        /**
         * Render the component to the given input DOM element
         * @private
         */
        _render: function (el) {
          ms.setName(cfg.name); // make sure the form name is correct
          // holds the main div, will relay the focus events to the contained input element.

          ms.container = $('<div/>', {
            'class': 'ms-ctn form-control ' + (cfg.resultAsString ? 'ms-as-string ' : '') + cfg.cls + ($(el).hasClass('input-lg') ? ' input-lg' : '') + ($(el).hasClass('input-sm') ? ' input-sm' : '') + (cfg.disabled === true ? ' ms-ctn-disabled' : '') + (cfg.editable === true ? '' : ' ms-ctn-readonly') + (cfg.hideTrigger === false ? '' : ' ms-no-trigger'),
            style: cfg.style,
            id: cfg.id
          });
          ms.container.focus($.proxy(handlers._onFocus, this));
          ms.container.blur($.proxy(handlers._onBlur, this));
          ms.container.keydown($.proxy(handlers._onKeyDown, this));
          ms.container.keyup($.proxy(handlers._onKeyUp, this)); // holds the input field

          ms.input = $('<input/>', $.extend({
            type: 'text',
            'class': cfg.editable === true ? '' : ' ms-input-readonly',
            readonly: !cfg.editable,
            placeholder: cfg.placeholder,
            disabled: cfg.disabled
          }, cfg.inputCfg));
          ms.input.focus($.proxy(handlers._onInputFocus, this));
          ms.input.click($.proxy(handlers._onInputClick, this)); // holds the suggestions. will always be placed on focus

          ms.combobox = $('<div/>', {
            'class': 'ms-res-ctn dropdown-menu'
          }).height(cfg.maxDropHeight); // bind the onclick and mouseover using delegated events (needs jQuery >= 1.7)

          ms.combobox.on('click', 'div.ms-res-item', $.proxy(handlers._onComboItemSelected, this));
          ms.combobox.on('mouseover', 'div.ms-res-item', $.proxy(handlers._onComboItemMouseOver, this));

          if (cfg.selectionContainer) {
            ms.selectionContainer = cfg.selectionContainer;
            $(ms.selectionContainer).addClass('ms-sel-ctn');
          } else {
            ms.selectionContainer = $('<div/>', {
              'class': 'ms-sel-ctn'
            });
          }

          ms.selectionContainer.click($.proxy(handlers._onFocus, this));

          if (cfg.selectionPosition === 'inner' && !cfg.selectionContainer) {
            ms.selectionContainer.append(ms.input);
          } else {
            ms.container.append(ms.input);
          }

          ms.helper = $('<span/>', {
            'class': 'ms-helper ' + cfg.infoMsgCls
          });

          self._updateHelper();

          ms.container.append(ms.helper); // Render the whole thing

          $(el).replaceWith(ms.container);

          if (!cfg.selectionContainer) {
            switch (cfg.selectionPosition) {
              case 'bottom':
                ms.selectionContainer.insertAfter(ms.container);

                if (cfg.selectionStacked === true) {
                  ms.selectionContainer.width(ms.container.width());
                  ms.selectionContainer.addClass('ms-stacked');
                }

                break;

              case 'right':
                ms.selectionContainer.insertAfter(ms.container);
                ms.container.css('float', 'left');
                break;

              default:
                ms.container.append(ms.selectionContainer);
                break;
            }
          } // holds the trigger on the right side


          if (cfg.hideTrigger === false) {
            ms.trigger = $('<div/>', {
              'class': 'ms-trigger',
              html: '<div class="ms-trigger-ico"></div>'
            });
            ms.trigger.click($.proxy(handlers._onTriggerClick, this));
            ms.container.append(ms.trigger);
          }

          $(window).resize($.proxy(handlers._onWindowResized, this)); // do not perform an initial call if we are using ajax unless we have initial values

          if (cfg.value !== null || cfg.data !== null) {
            if (typeof cfg.data === 'string') {
              self._asyncValues = cfg.value;

              self._processSuggestions();
            } else {
              self._processSuggestions();

              if (cfg.value !== null) {
                ms.setValue(cfg.value);

                self._renderSelection();
              }
            }
          }

          $("body").click(function (e) {
            if (ms.container.hasClass('ms-ctn-focus') && ms.container.has(e.target).length === 0 && e.target.className.indexOf('ms-res-item') < 0 && e.target.className.indexOf('ms-close-btn') < 0 && ms.container[0] !== e.target) {
              handlers._onBlur();
            }
          });

          if (cfg.expanded === true) {
            cfg.expanded = false;
            ms.expand();
          }
        },

        /**
         * Renders each element within the combo box
         * @private
         */
        _renderComboItems: function (items, isGrouped) {
          var ref = this,
              html = '';
          $.each(items, function (index, value) {
            var displayed = cfg.renderer !== null ? cfg.renderer.call(ref, value) : value[cfg.displayField];
            var disabled = cfg.disabledField !== null && value[cfg.disabledField] === true;
            var resultItemEl = $('<div/>', {
              'class': 'ms-res-item ' + (isGrouped ? 'ms-res-item-grouped ' : '') + (disabled ? 'ms-res-item-disabled ' : '') + (index % 2 === 1 && cfg.useZebraStyle === true ? 'ms-res-odd' : ''),
              html: cfg.highlight === true ? self._highlightSuggestion(displayed) : displayed,
              'data-json': JSON.stringify(value)
            });
            html += $('<div/>').append(resultItemEl).html();
          });
          ms.combobox.append(html);
          _comboItemHeight = ms.combobox.find('.ms-res-item:first').outerHeight();
        },

        /**
         * Renders the selected items into their container.
         * @private
         */
        _renderSelection: function () {
          var ref = this,
              w = 0,
              inputOffset = 0,
              items = [],
              asText = cfg.resultAsString === true && !_hasFocus;
          ms.selectionContainer.find('.ms-sel-item').remove();

          if (ms._valueContainer !== undefined) {
            ms._valueContainer.remove();
          }

          $.each(_selection, function (index, value) {
            var selectedItemEl,
                delItemEl,
                selectedItemHtml = cfg.selectionRenderer !== null ? cfg.selectionRenderer.call(ref, value) : value[cfg.displayField];
            var validCls = self._validateSingleItem(value[cfg.displayField]) ? '' : ' ms-sel-invalid'; // tag representing selected value

            if (asText === true) {
              selectedItemEl = $('<div/>', {
                'class': 'ms-sel-item ms-sel-text ' + cfg.selectionCls + validCls,
                html: selectedItemHtml + (index === _selection.length - 1 ? '' : cfg.resultAsStringDelimiter)
              }).data('json', value);
            } else {
              selectedItemEl = $('<div/>', {
                'class': 'ms-sel-item ' + cfg.selectionCls + validCls,
                html: selectedItemHtml
              }).data('json', value);

              if (cfg.disabled === false) {
                // small cross img
                delItemEl = $('<span/>', {
                  'class': 'ms-close-btn'
                }).data('json', value).appendTo(selectedItemEl);
                delItemEl.click($.proxy(handlers._onTagTriggerClick, ref));
              }
            }

            items.push(selectedItemEl);
          });
          ms.selectionContainer.prepend(items); // store the values, behaviour of multiple select

          ms._valueContainer = $('<div/>', {
            style: 'display: none;'
          });
          $.each(ms.getValue(), function (i, val) {
            var el = $('<input/>', {
              type: 'hidden',
              name: cfg.name,
              value: val
            });
            el.appendTo(ms._valueContainer);
          });

          ms._valueContainer.appendTo(ms.selectionContainer);

          if (cfg.selectionPosition === 'inner' && !cfg.selectionContainer) {
            ms.input.width(0);
            inputOffset = ms.input.offset().left - ms.selectionContainer.offset().left;
            w = ms.container.width() - inputOffset - 42;
            ms.input.width(w);
          }

          if (_selection.length === cfg.maxSelection) {
            self._updateHelper(cfg.maxSelectionRenderer.call(this, _selection.length));
          } else {
            ms.helper.hide();
          }
        },

        /**
         * Select an item either through keyboard or mouse
         * @param item
         * @private
         */
        _selectItem: function (item) {
          if (cfg.maxSelection === 1) {
            _selection = [];
          }

          ms.addToSelection(item.data('json'));
          item.removeClass('ms-res-item-active');

          if (cfg.expandOnFocus === false || _selection.length === cfg.maxSelection) {
            ms.collapse();
          }

          if (!_hasFocus) {
            ms.input.focus();
          } else if (_hasFocus && (cfg.expandOnFocus || _ctrlDown)) {
            self._processSuggestions();

            if (_ctrlDown) {
              ms.expand();
            }
          }
        },

        /**
         * Sorts the results and cut them down to max # of displayed results at once
         * @private
         */
        _sortAndTrim: function (data) {
          var q = ms.getRawValue(),
              filtered = [],
              newSuggestions = [],
              selectedValues = ms.getValue(); // filter the data according to given input

          if (q.length > 0) {
            $.each(data, function (index, obj) {
              var name = obj[cfg.displayField];

              if (cfg.matchCase === true && name.indexOf(q) > -1 || cfg.matchCase === false && name.toLowerCase().indexOf(q.toLowerCase()) > -1) {
                if (cfg.strictSuggest === false || name.toLowerCase().indexOf(q.toLowerCase()) === 0) {
                  filtered.push(obj);
                }
              }
            });
          } else {
            filtered = data;
          } // take out the ones that have already been selected


          $.each(filtered, function (index, obj) {
            if (cfg.allowDuplicates || $.inArray(obj[cfg.valueField], selectedValues) === -1) {
              newSuggestions.push(obj);
            }
          }); // sort the data

          if (cfg.sortOrder !== null) {
            newSuggestions.sort(function (a, b) {
              if (a[cfg.sortOrder] < b[cfg.sortOrder]) {
                return cfg.sortDir === 'asc' ? -1 : 1;
              }

              if (a[cfg.sortOrder] > b[cfg.sortOrder]) {
                return cfg.sortDir === 'asc' ? 1 : -1;
              }

              return 0;
            });
          } // trim it down


          if (cfg.maxSuggestions && cfg.maxSuggestions > 0) {
            newSuggestions = newSuggestions.slice(0, cfg.maxSuggestions);
          }

          return newSuggestions;
        },
        _group: function (data) {
          // build groups
          if (cfg.groupBy !== null) {
            _groups = {};
            $.each(data, function (index, value) {
              var props = cfg.groupBy.indexOf('.') > -1 ? cfg.groupBy.split('.') : cfg.groupBy;
              var prop = value[cfg.groupBy];

              if (typeof props != 'string') {
                prop = value;

                while (props.length > 0) {
                  prop = prop[props.shift()];
                }
              }

              if (_groups[prop] === undefined) {
                _groups[prop] = {
                  title: prop,
                  items: [value]
                };
              } else {
                _groups[prop].items.push(value);
              }
            });
          }

          return data;
        },

        /**
         * Update the helper text
         * @private
         */
        _updateHelper: function (html) {
          ms.helper.html(html);

          if (!ms.helper.is(":visible")) {
            ms.helper.fadeIn();
          }
        },

        /**
         * Validate an item against vtype or vregex
         * @private
         */
        _validateSingleItem: function (value) {
          if (cfg.vregex !== null && cfg.vregex instanceof RegExp) {
            return cfg.vregex.test(value);
          } else if (cfg.vtype !== null) {
            switch (cfg.vtype) {
              case 'alpha':
                return /^[a-zA-Z_]+$/.test(value);

              case 'alphanum':
                return /^[a-zA-Z0-9_]+$/.test(value);

              case 'email':
                return /^(\w+)([\-+.][\w]+)*@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/.test(value);

              case 'url':
                return /(((^https?)|(^ftp)):\/\/([\-\w]+\.)+\w{2,3}(\/[%\-\w]+(\.\w{2,})?)*(([\w\-\.\?\\\/+@&#;`~=%!]*)(\.\w{2,})?)*\/?)/i.test(value);

              case 'ipaddress':
                return /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(value);
            }
          }

          return true;
        }
      };
      var handlers = {
        /**
         * Triggered when blurring out of the component
         * @private
         */
        _onBlur: function () {
          ms.container.removeClass('ms-ctn-focus');
          ms.collapse();
          _hasFocus = false;

          if (ms.getRawValue() !== '' && cfg.allowFreeEntries === true) {
            var obj = {};
            obj[cfg.displayField] = obj[cfg.valueField] = ms.getRawValue().trim();
            ms.addToSelection(obj);
          }

          self._renderSelection();

          if (ms.isValid() === false) {
            ms.container.addClass(cfg.invalidCls);
          } else if (ms.input.val() !== '' && cfg.allowFreeEntries === false) {
            ms.empty();

            self._updateHelper('');
          }

          $(ms).trigger('blur', [ms]);
        },

        /**
         * Triggered when hovering an element in the combo
         * @param e
         * @private
         */
        _onComboItemMouseOver: function (e) {
          var target = $(e.currentTarget);

          if (!target.hasClass('ms-res-item-disabled')) {
            ms.combobox.children().removeClass('ms-res-item-active');
            target.addClass('ms-res-item-active');
          }
        },

        /**
         * Triggered when an item is chosen from the list
         * @param e
         * @private
         */
        _onComboItemSelected: function (e) {
          var target = $(e.currentTarget);

          if (!target.hasClass('ms-res-item-disabled')) {
            self._selectItem($(e.currentTarget));
          }
        },

        /**
         * Triggered when focusing on the container div. Will focus on the input field instead.
         * @private
         */
        _onFocus: function () {
          ms.input.focus();
        },

        /**
         * Triggered when clicking on the input text field
         * @private
         */
        _onInputClick: function () {
          if (ms.isDisabled() === false && _hasFocus) {
            if (cfg.toggleOnClick === true) {
              if (cfg.expanded) {
                ms.collapse();
              } else {
                ms.expand();
              }
            }
          }
        },

        /**
         * Triggered when focusing on the input text field.
         * @private
         */
        _onInputFocus: function () {
          if (ms.isDisabled() === false && !_hasFocus) {
            _hasFocus = true;
            ms.container.addClass('ms-ctn-focus');
            ms.container.removeClass(cfg.invalidCls);
            var curLength = ms.getRawValue().length;

            if (cfg.expandOnFocus === true) {
              ms.expand();
            }

            if (_selection.length === cfg.maxSelection) {
              self._updateHelper(cfg.maxSelectionRenderer.call(this, _selection.length));
            } else if (curLength < cfg.minChars) {
              self._updateHelper(cfg.minCharsRenderer.call(this, cfg.minChars - curLength));
            }

            self._renderSelection();

            $(ms).trigger('focus', [ms]);
          }
        },

        /**
         * Triggered when the user presses a key while the component has focus
         * This is where we want to handle all keys that don't require the user input field
         * since it hasn't registered the key hit yet
         * @param e keyEvent
         * @private
         */
        _onKeyDown: function (e) {
          // check how tab should be handled
          var active = ms.combobox.find('.ms-res-item-active:not(.ms-res-item-disabled):first'),
              freeInput = ms.input.val();
          $(ms).trigger('keydown', [ms, e]);

          if (e.keyCode === KEYCODES.TAB && (cfg.useTabKey === false || cfg.useTabKey === true && active.length === 0 && ms.input.val().length === 0)) {
            handlers._onBlur();

            return;
          }

          switch (e.keyCode) {
            case KEYCODES.BACKSPACE:
              if (freeInput.length === 0 && ms.getSelection().length > 0 && cfg.selectionPosition === 'inner') {
                _selection.pop();

                self._renderSelection();

                $(ms).trigger('selectionchange', [ms, ms.getSelection()]);
                ms.input.attr('placeholder', cfg.selectionPosition === 'inner' && ms.getValue().length > 0 ? '' : cfg.placeholder);
                ms.input.focus();
                e.preventDefault();
              }

              break;

            case KEYCODES.TAB:
            case KEYCODES.ESC:
              e.preventDefault();
              break;

            case KEYCODES.ENTER:
              if (freeInput !== '' || cfg.expanded) {
                e.preventDefault();
              }

              break;

            case KEYCODES.COMMA:
              if (cfg.useCommaKey === true) {
                e.preventDefault();
              }

              break;

            case KEYCODES.CTRL:
              _ctrlDown = true;
              break;

            case KEYCODES.DOWNARROW:
              e.preventDefault();

              self._moveSelectedRow("down");

              break;

            case KEYCODES.UPARROW:
              e.preventDefault();

              self._moveSelectedRow("up");

              break;

            default:
              if (_selection.length === cfg.maxSelection) {
                e.preventDefault();
              }

              break;
          }
        },

        /**
         * Triggered when a key is released while the component has focus
         * @param e
         * @private
         */
        _onKeyUp: function (e) {
          var freeInput = ms.getRawValue(),
              inputValid = $.trim(ms.input.val()).length > 0 && (!cfg.maxEntryLength || $.trim(ms.input.val()).length <= cfg.maxEntryLength),
              selected,
              obj = {};

          if (/(^\s$)|(\s\s+)/g.test(freeInput)) {
            return;
          }

          $(ms).trigger('keyup', [ms, e]);
          clearTimeout(_timer); // collapse if escape, but keep focus.

          if (e.keyCode === KEYCODES.ESC && cfg.expanded) {
            ms.combobox.hide();
          } // ignore a bunch of keys


          if (e.keyCode === KEYCODES.TAB && cfg.useTabKey === false || e.keyCode > KEYCODES.ENTER && e.keyCode < KEYCODES.SPACE) {
            if (e.keyCode === KEYCODES.CTRL) {
              _ctrlDown = false;
            }

            return;
          }

          switch (e.keyCode) {
            case KEYCODES.UPARROW:
            case KEYCODES.DOWNARROW:
              e.preventDefault();
              break;

            case KEYCODES.ENTER:
            case KEYCODES.TAB:
            case KEYCODES.COMMA:
              if (e.keyCode !== KEYCODES.COMMA || cfg.useCommaKey === true) {
                e.preventDefault();

                if (cfg.expanded === true) {
                  // if a selection is performed, select it and reset field
                  selected = ms.combobox.find('.ms-res-item-active:not(.ms-res-item-disabled):first');

                  if (selected.length > 0) {
                    self._selectItem(selected);

                    return;
                  }
                } // if no selection or if freetext entered and free entries allowed, add new obj to selection


                if (inputValid === true && cfg.allowFreeEntries === true) {
                  obj[cfg.displayField] = obj[cfg.valueField] = freeInput.trim();
                  ms.addToSelection(obj);
                  ms.collapse(); // reset combo suggestions

                  ms.input.focus();
                }

                break;
              }

            default:
              if (_selection.length === cfg.maxSelection) {
                self._updateHelper(cfg.maxSelectionRenderer.call(this, _selection.length));
              } else {
                if (freeInput.length < cfg.minChars) {
                  self._updateHelper(cfg.minCharsRenderer.call(this, cfg.minChars - freeInput.length));

                  if (cfg.expanded === true) {
                    ms.collapse();
                  }
                } else if (cfg.maxEntryLength && freeInput.length > cfg.maxEntryLength) {
                  self._updateHelper(cfg.maxEntryRenderer.call(this, freeInput.length - cfg.maxEntryLength));

                  if (cfg.expanded === true) {
                    ms.collapse();
                  }
                } else {
                  ms.helper.hide();

                  if (cfg.minChars <= freeInput.length) {
                    _timer = setTimeout(function () {
                      if (cfg.expanded === true) {
                        self._processSuggestions();
                      } else {
                        ms.expand();
                      }
                    }, cfg.typeDelay);
                  }
                }
              }

              break;
          }
        },

        /**
         * Triggered when clicking upon cross for deletion
         * @param e
         * @private
         */
        _onTagTriggerClick: function (e) {
          ms.removeFromSelection($(e.currentTarget).data('json'));
        },

        /**
         * Triggered when clicking on the small trigger in the right
         * @private
         */
        _onTriggerClick: function () {
          if (ms.isDisabled() === false && !(cfg.expandOnFocus === true && _selection.length === cfg.maxSelection)) {
            $(ms).trigger('triggerclick', [ms]);

            if (cfg.expanded === true) {
              ms.collapse();
            } else {
              var curLength = ms.getRawValue().length;

              if (curLength >= cfg.minChars) {
                ms.input.focus();
                ms.expand();
              } else {
                self._updateHelper(cfg.minCharsRenderer.call(this, cfg.minChars - curLength));
              }
            }
          }
        },

        /**
         * Triggered when the browser window is resized
         * @private
         */
        _onWindowResized: function () {
          self._renderSelection();
        }
      }; // startup point

      if (element !== null) {
        self._render(element);
      }
    };

    $.fn.magicSuggest = function (options) {
      var obj = $(this);

      if (obj.size() === 1 && obj.data('magicSuggest')) {
        return obj.data('magicSuggest');
      }

      obj.each(function (i) {
        // assume $(this) is an element
        var cntr = $(this); // Return early if this element already has a plugin instance

        if (cntr.data('magicSuggest')) {
          return;
        }

        if (this.nodeName.toLowerCase() === 'select') {
          // rendering from select
          options.data = [];
          options.value = [];
          $.each(this.children, function (index, child) {
            if (child.nodeName && child.nodeName.toLowerCase() === 'option') {
              options.data.push({
                id: child.value,
                name: child.text
              });

              if ($(child).attr('selected')) {
                options.value.push(child.value);
              }
            }
          });
        }

        var def = {}; // set values from DOM container element

        $.each(this.attributes, function (i, att) {
          def[att.name] = att.name === 'value' && att.value !== '' ? JSON.parse(att.value) : att.value;
        });
        var field = new MagicSuggest(this, $.extend([], $.fn.magicSuggest.defaults, options, def));
        cntr.data('magicSuggest', field);
        field.container.data('magicSuggest', field);
      });

      if (obj.size() === 1) {
        return obj.data('magicSuggest');
      }

      return obj;
    };

    $.fn.magicSuggest.defaults = {};
  })(jQuery);

  (function () {
    var $body = $('body');
    var quickSearch = {
      autoCompeteSearchUrl: "",
      suggestedData: [],
      enteredTerm: "",
      inputElem: "",
      maxWords: "",
      maxChars: "",
      confNumOfContributors: "",
      confNumOfHistoryItems: "",
      confNumOfPublicationTitles: "",
      confNumOfTopics: "",
      selectedOption: "",
      seriesKey: "",
      vPort: "screen-md",
      isMobile: false,
      init: function () {
        quickSearch.inputElem = $('.quick-search .magicsuggest');
        quickSearch.seriesKey = $('input[name=SeriesKey]', '[name=thisJournalQuickSearch]').val();
        quickSearch.controller();
        quickSearch.additionalController();
      },
      controller: function () {
        $('.quick-search').find('.magicsuggest').each(function () {
          quickSearch.inputElem = $(this);
          quickSearch.maxWords = $(this).data("auto-complete-max-words");
          quickSearch.maxChars = $(this).data("auto-complete-max-chars");
          var searchType = $(this).parent();
          quickSearch.enteredTerm = $(this).val();

          if (searchType.hasClass('option-citation')) {
            quickSearch.citationSuggestions();
          } else if (searchType.hasClass('option-journal')) {
            quickSearch.journalSearchSuggestions();
          } else {
            quickSearch.searchSuggistions();
          }
        });
        $(document).on('submit', '[name="defaultQuickSearch"],[name="citationQuickSearch"],[name="thisJournalQuickSearch"]', function (e) {
          var empty = true;
          $(this).find('input[type="text"],input[type="search"]').each(function () {
            if ($(this).val() && $(this).val() != '') {
              empty = false;
            }
          });

          if ($(this).find('.ms-sel-item').length > 0) {
            empty = false;
          }

          if (empty) {
            window.location = '/search/advanced';
            e.preventDefault();
          }
        }); // FOCUS TRAP for QuickSearch in Dropdown

        $(function () {
          $(document).on('keydown', '.quick-search :tabbable:not([readonly])', function (e) {
            var loop = $(this).closest('.quick-search');

            if ($body.attr('data-active') !== 'dropBlock' && !loop.closest('.dropBlock__holder.js--open').length) {
              return;
            }

            var firstTabbable = loop.find(':tabbable:not([readonly])').first();
            var lastTabbable = loop.find(':tabbable:not([readonly])').last(); // Leaving the first element with Tab : focus the last one

            if (firstTabbable.is(e.target) && e.shiftKey == true) {
              e.preventDefault();
              lastTabbable.focus();
            } // Leaving the last element with Tab : focus the first one


            if (lastTabbable.is(e.target) && e.shiftKey == false) {
              if (e.which == 13) {
                UX.dropBlock.on.hide();
              }

              e.preventDefault();
              firstTabbable.focus();
            }
          });
        });
      },
      additionalController: function () {},
      doSuggest: function (sug) {
        quickSearch.inputElem.magicSuggest({
          data: sug,
          method: 'GET',
          valueField: 'value',
          autoSelect: false,
          displayField: 'label',
          cls: 'search-term',
          hideTrigger: 'true',
          beforeSend: function (xhr, settings) {
            var enteredTerm = settings.url.substr(settings.url.indexOf('query=') + 6).replace(/[​​+]/g, ' ');

            if (enteredTerm.split(" ").length > quickSearch.maxWords || enteredTerm.length > quickSearch.maxChars || !enteredTerm.replace(/\s/g, '').length) {
              return false;
            }
          }
        });
      },
      citationSuggestions: function () {
        quickSearch.confNumOfPublicationTitles = quickSearch.inputElem.data('publication-titles-conf');
        quickSearch.autoCompeteSearchUrl = '/action/doSuggest?target=title-auto-complete&pts=' + quickSearch.confNumOfPublicationTitles + '&fl=PubID';
        quickSearch.selectedOption = "citation";
        quickSearch.doSuggest(quickSearch.autoCompeteSearchUrl);
      },
      searchSuggistions: function () {
        quickSearch.confNumOfPublicationTitles = quickSearch.inputElem.data('publication-titles-conf');
        quickSearch.confNumOfContributors = quickSearch.inputElem.data('contributors-conf');
        quickSearch.confNumOfTopics = quickSearch.inputElem.data('topics-conf');
        quickSearch.confNumOfHistoryItems = quickSearch.inputElem.data('history-items-conf');
        quickSearch.autoCompeteSearchUrl = '/action/doSuggest?target=auto-complete&hs=' + quickSearch.confNumOfHistoryItems + '&pts=' + quickSearch.confNumOfPublicationTitles + '&ts=' + quickSearch.confNumOfTopics + '&cs=' + quickSearch.confNumOfContributors + '&fl=PubID';
        quickSearch.doSuggest(quickSearch.autoCompeteSearchUrl);
      },
      journalSearchSuggestions: function () {
        quickSearch.confNumOfPublicationTitles = quickSearch.inputElem.data('publication-titles-conf');
        quickSearch.confNumOfContributors = quickSearch.inputElem.data('contributors-conf');
        quickSearch.confNumOfTopics = quickSearch.inputElem.data('topics-conf');
        quickSearch.confNumOfHistoryItems = quickSearch.inputElem.data('history-items-conf');
        quickSearch.autoCompeteSearchUrl = '/action/doSuggest?target=auto-complete&hs=' + quickSearch.confNumOfHistoryItems + '&pts=' + quickSearch.confNumOfPublicationTitles + '&ts=' + quickSearch.confNumOfTopics + '&cs=' + quickSearch.confNumOfContributors + '&fl=PubID&within=' + quickSearch.seriesKey;
        quickSearch.doSuggest(quickSearch.autoCompeteSearchUrl);
      }
    };
    UX.quickSearch = quickSearch; // add to global namespace
  })();

  (function () {
    var $body = $('body');
    var searchFieldsCtrl = {
      $wrapper: null,
      $form: null,
      $terms: null,
      escape: 27,
      dateRangeVal: $('#staticRangeSelect').val(),
      vPort: "screen-sm",
      // default responsive break point
      isMobile: false,
      $magicSuggest: null,
      magicSuggestObjects: [],
      magicSuggestTrigger: false,
      $cloningInput: null,
      init: function () {
        searchFieldsCtrl.$form = $('.frmSearch');
        searchFieldsCtrl.$magicSuggest = $('.magicsuggest');

        if (searchFieldsCtrl.magicSuggestTrigger) {
          searchFieldsCtrl.$magicSuggest.each(function () {
            searchFieldsCtrl.on.doSuggest($(this));
          });
        }

        searchFieldsCtrl.$magicSuggest.each(function () {
          searchFieldsCtrl.on.doSuggest($(this));
        });
        searchFieldsCtrl.check.submitButton();
        searchFieldsCtrl.check.terms();
        searchFieldsCtrl.control();
        searchFieldsCtrl.addtionalControls();
        var $lastTerm = $('.advanced-search--searchIn').find('.searchIn--field:last-child');
        searchFieldsCtrl.check.lastClone($lastTerm);
        searchFieldsCtrl.select.dateRangeRadio($(this));
      },
      control: function () {
        $body.on('click', '[class*="-ctrl-field"]', function (e) {
          e.preventDefault();
          e.stopPropagation();
          searchFieldsCtrl.$wrapper = $(this).closest('.searchIn--field');

          if ($(this).is('.add-ctrl-field')) {
            searchFieldsCtrl.$terms = $(this).closest('.advanced-search--searchIn').find('.searchIn--field');

            if (searchFieldsCtrl.$terms.length < 7) {
              searchFieldsCtrl.on.clone($(this));
            }
          } else {
            searchFieldsCtrl.on.remove($(this));
          }
        });
        $body.on('focus', '.magicsuggest', function () {
          searchFieldsCtrl.on.doSuggest($(this));
        });
        $('.time-frame').on('change', 'select', function () {
          searchFieldsCtrl.select.dateRange($(this));
        });
        $('.time-frame').on('change', 'input', function () {
          searchFieldsCtrl.select.dateRangeRadio($(this));
        });
        $body.on('keyup input', '.searchIn--field input', function () {
          searchFieldsCtrl.$form = $(this).closest('form');
          searchFieldsCtrl.check.submitButton();
        });
        searchFieldsCtrl.click.toggleSearchBlock();
        $(document).on(searchFieldsCtrl.vPort + '-on', function () {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          searchFieldsCtrl.isMobile = true;
        });
        $(document).on(searchFieldsCtrl.vPort + '-off', function () {
          // Waiting for custom event that will be triggered by controller.js to deactivate responsive effects
          searchFieldsCtrl.isMobile = false;
        });
        $('.advanced-search--advancedFilters .radio--primary input[type="radio"]').change(function () {
          $('.advanced-search--advancedFilters .radio--primary input[type="radio"]').prop('checked', false);
          $(this).prop('checked', true);
        });
        /*$('body').on('input', '.ms-ctn input', function () {
             var $parent = $(this).closest('.ms-ctn');
            if ($(this).val() === '') {
                $parent.find('.ms-res-ctn.dropdown-menu').remove();
            }
         });*/

        $('body').on('change', '#earlyCite', function () {
          // this code added to solve LIT-190918
          var $earlyCite_hidden = $("#earlyCite_hidden");

          if ($earlyCite_hidden.val() === "") {
            $earlyCite_hidden.val("off");
            $earlyCite_hidden.prop("disabled", false);
          } else {
            $earlyCite_hidden.val("");
            $earlyCite_hidden.prop("disabled", true);
          }
        });
      },
      addtionalControls: function () {},
      hideTriggerOption: function ($elem) {
        var hideTrigger = true;

        if ($elem.hasClass('showDefaultData')) {
          hideTrigger = false;
        }

        return hideTrigger;
      },
      click: {
        toggleSearchBlock: function () {
          $body.on('click', '.search__result .advanced-search__ctrl', function (e) {
            if (!searchFieldsCtrl.isMobile) {
              e.preventDefault();
              $(this).toggleClass('js--open');
              $('.search-result__meta .advanced-search__tabs').toggle(); //UX.tab.on.calculate($('.search-result__meta .tab__nav'));
            }
          });
        }
      },
      on: {
        clone: function ($this) {
          jcf.destroy($('.searchIn--field .jcf'));
          searchFieldsCtrl.$wrapper.clone(true, true).find('input').val('').end().appendTo('.advanced-search--searchIn');
          $this.addClass('hidden');
          $this.siblings('.remove-ctrl-field').removeClass('hidden');
          $('.searchIn--field .jcf').each(function () {
            jcf.replace($(this));
          });
          $this = $('.advanced-search--searchIn').children('.searchIn--field:last-child');
          searchFieldsCtrl.check.lastClone($this);
        },
        remove: function ($this) {
          searchFieldsCtrl.$form = $this.closest('form');
          searchFieldsCtrl.$wrapper.remove();
          searchFieldsCtrl.check.submitButton();
          $this = $('.advanced-search--searchIn').children('.searchIn--field:last-child');
          searchFieldsCtrl.check.lastClone($this);
        },
        doSuggest: function ($elem) {
          var doSuggestTarget = $elem.data('auto-complete-target');
          var withinData = $elem.data('auto-complete-within');
          var maxWords = 200;
          var maxChars = 222;
          var name = $elem.attr('name');
          var id = $elem.attr('id');
          var values = $elem.attr('data-values') ? JSON.parse($elem.attr('data-values')) : [];

          if (withinData) {
            doSuggestTarget = doSuggestTarget + '&within=' + withinData;
          }

          var $ms = $elem.magicSuggest({
            data: '/action/doSuggest?target=' + doSuggestTarget,
            // realData
            // data: '/specs/ux3/widgets/advanced-search/templates/demo/fakeAutoCompleteData.json', // fakeData
            method: 'GET',
            valueField: 'value',
            autoSelect: false,
            allowFreeEntries: 'false',
            displayField: 'label',
            cls: 'search-term',
            hideTrigger: searchFieldsCtrl.hideTriggerOption($elem),
            inputCfg: {
              'id': id,
              'name': name
            },
            beforeSend: function (xhr, settings) {
              var enteredTerm = settings.url.substr(settings.url.indexOf('query=') + 6).replace(/[​​+]/g, ' ');

              if (enteredTerm.split(" ").length > maxWords || enteredTerm.length > maxChars || !enteredTerm.replace(/\s/g, '').length) {
                if ($elem.hasClass('showDefaultData')) {
                  //get all data
                  settings.url += '*:*';
                } else {
                  return false;
                }
              }
            }
          });
          $ms.input.focus();

          if (values.length) {
            $ms.setSelection(values);
          }

          $($ms).on('selectionchange', function () {
            searchFieldsCtrl.check.submitButton();
          });
          searchFieldsCtrl.magicSuggestObjects.push($ms);
        }
      },
      select: {
        dateRange: function ($this) {
          var $radioParent = $this.closest('.time-frame');
          var radio = $radioParent.find('input[type=radio]');
          radio.trigger('click');

          if ($this.attr('id') === 'staticRangeSelect') {
            if ($this.hasClass('jcf')) {
              searchFieldsCtrl.dateRangeVal = $('#staticRangeSelect').find('option:contains("' + $('.jcf-select-staticRange .jcf-select-text span').text() + '")').val();
              $('#staticRangeSelect').val(searchFieldsCtrl.dateRangeVal);
            }
          }

          searchFieldsCtrl.$form = $this.closest('form');
          searchFieldsCtrl.check.submitButton();
        },
        dateRangeRadio: function ($this) {
          if (!$('#staticRange:checked').length) {
            $('#staticRangeSelect').val('');
          } else {
            if ($this.hasClass('jcf')) {
              searchFieldsCtrl.dateRangeVal = $('#staticRangeSelect').find('option:contains("' + $('.jcf-select-staticRange .jcf-select-text span').text() + '")').val();
              $('#staticRangeSelect').val(searchFieldsCtrl.dateRangeVal);
            }
          }
        }
      },
      check: {
        emptyInputs: function (form) {
          var textInputs = $(form).find('input[type=search]');

          if (textInputs.length === 0) {
            textInputs = $(form).find('input[type=text]');
          }

          textInputs = $(textInputs).add($(form).find('.checkVal'));
          var $emptyFields = $(textInputs).filter(function () {
            return this.value === "";
          });
          return $emptyFields.length === textInputs.length;
        },
        submitButton: function () {
          if (searchFieldsCtrl.check.emptyInputs(searchFieldsCtrl.$form) && searchFieldsCtrl.check.emptySuggestions()) {
            $(searchFieldsCtrl.$form).find('button[type=submit]').attr('disabled', true);
          } else {
            $(searchFieldsCtrl.$form).find('button[type=submit]').removeAttr('disabled', true);
          }
        },

        emptySuggestions() {
          const suggestions = searchFieldsCtrl.magicSuggestObjects;

          if (!suggestions.length) {
            return true;
          }

          return suggestions.filter(suggestion => suggestion.getValue().length > 0).length === 0;
        },

        terms: function () {
          searchFieldsCtrl.$terms = $('.advanced-search--searchIn .searchIn--field');
          searchFieldsCtrl.$terms.each(function (index) {
            var number = index + 1;
            var $this = $(this);
            searchFieldsCtrl.$cloningInput = searchFieldsCtrl.check.defineCloningInput($this);
            $this.find('[for*="searchArea"]').attr({
              for: 'searchArea' + number
            });
            $this.find('[for*="text"]').attr({
              for: 'text' + number
            });
            $this.find('select').attr({
              id: 'searchArea' + number,
              name: 'field' + number
            });
            searchFieldsCtrl.$cloningInput.attr({
              id: 'text' + number,
              name: 'text' + number
            });
          });
        },
        defineCloningInput: function ($this) {
          return $this.find('input');
        },
        lastClone: function ($this) {
          if ($this.index() === 6) {
            $this.children('.add-ctrl-field').addClass('hidden');
            $this.children('.remove-ctrl-field').removeClass('hidden');
          } else {
            $this.children('.add-ctrl-field').removeClass('hidden');
            $this.children('.remove-ctrl-field').addClass('hidden');
          }

          searchFieldsCtrl.check.terms();
        }
      }
    };
    UX.searchFieldsCtrl = searchFieldsCtrl; // add to global namespace
  })();

  (function () {
    const $body = $('body');
    const searchResult = {
      url: location.href,
      rememberUserLayout: true,

      /**
       * The saved search panel
       */
      $savedSearchPanel: null,

      /**
       * Frequency Column Labels
       */
      frequencyLabels: {},

      /**
       * The max search queries needed to for iteration over the table
       */
      maxSearchQueries: null,

      /**
       * Link to edit saved search item
       */
      goLink: '/action/doSearch?target=saved&runSaved=',

      /**
       * Link to remove saved search item
       */
      removeLink: '/action/doDeleteSearch?searchType=saved&queryId=',

      init() {
        //searchResult.get.url();
        this.$savedSearchPanel = $('.advancedSearch__tabs .saved-searches');
        this.maxSearchQueries = this.$savedSearchPanel.data('queries');
        this.frequencyLabels = this.$savedSearchPanel.data('frequency-labels');
        searchResult.control();
        searchResult.additionalInit();
        searchResult.additionalControl();
        searchResult.set.userPublicationLayout();
      },

      control: function () {
        $body.on('click', '#saveSearchTriggerButton', function () {
          searchResult.openSaveSearchDialog();
        });
        $body.on('submit', '#saveSearchDialog form', function (event) {
          return searchResult.onSaveSearchSubmitHandler(event);
        });
        $body.on('click', '.search__layout>span', function () {
          $(".search__layout>span").removeClass('active');
          $(this).addClass('active');

          if ($(this).hasClass('search__layout-tile')) {
            $(".search-result__body").addClass('search-result--tile');
            localStorage.setItem("userPublicationLayout", "tile");
          } else {
            $(".search-result__body").removeClass('search-result--tile');
            localStorage.setItem("userPublicationLayout", "list");
          }
        });
      },
      additionalControl: function () {},
      additionalInit: function () {},
      set: {
        userPublicationLayout: function () {
          if (searchResult.rememberUserLayout) {
            if (localStorage.userPublicationLayout == 'tile') {
              $('.search__layout-tile').click();
            } else if (localStorage.userPublicationLayout == 'list') {
              $('.search__layout-list').click();
            }
          }
        }
      },
      get: {
        url: function () {},
        text: function (name) {
          name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
          var regexS = "[\\?&]" + name + "=([^&#]*)";
          var regex = new RegExp(regexS);
          var results = regex.exec(searchResult.url);
          return results == null ? null : results[1];
        },
        value: function () {}
      },

      /**
       * Responsible for rendering row items
       */
      render: {
        /**
         * Responsible for rendering rows
         *
         * @param {object} item
         * @param {number} index
         */
        row(item, index) {
          console.log(searchResult.$savedSearchPanel);
          const $row = searchResult.$savedSearchPanel.find('tbody tr').eq(index);
          console.log($row);
          this.columns($row, item);
          this.actions($row, item);

          if ($row.hasClass('hidden')) {
            $row.removeClass('hidden');
            searchResult.$savedSearchPanel.find('.table-responsive').parent().removeClass('hidden');
            searchResult.$savedSearchPanel.find('.emptySavedSearches').remove();
          }
        },

        /**
         * Responsible for rendering columns
         *
         * @param {jQuery} $row
         * @param {object} item
         */
        columns($row, item) {
          const {
            qName,
            qSavedOn,
            qLastRun
          } = item;
          $row.find('.name-td').html(qName);
          $row.find('.saved-on-td').html(qSavedOn);
          $row.find('.last-run-td').html(qLastRun);
          this.additionalColumns($row, item);
          this.frequencyColumn($row, item);
        },

        /**
         * Responsible for additional columns rendering,
         * can be used to modify rendered row columns
         *
         * @param {jQuery} $row
         * @param {object} item
         */
        additionalColumns($row, item) {},

        /**
         * Render Frequency Column
         *
         * @param {jQuery} $row
         * @param {string} qAlertStatus
         */
        frequencyColumn($row, {
          qAlertStatus
        }) {
          let frequency = qAlertStatus;

          if (searchResult.frequencyLabels && searchResult.frequencyLabels[frequency]) {
            frequency = searchResult.frequencyLabels[frequency];
          }

          $row.find('.frequency-td').html(frequency);
        },

        /**
         * Responsible for rendering action columns
         *
         * @param {jQuery} $row
         * @param {number} qId
         */
        actions($row, {
          qId
        }) {
          $row.find('[data-action-type="saved-search--remove"]').attr('href', searchResult.removeLink + qId);
          $row.find('[data-action-type="saved-search--run"]').attr('href', searchResult.goLink + qId);
        }

      },
      openSaveSearchDialog: function () {
        var openDialog = searchResult.getCookie("openDialog");

        if (openDialog != null && openDialog != "") {
          var saveSearchButton = $('#saveSearchTriggerButton');

          if (saveSearchButton.length > 0) {
            document.cookie = "openDialog=;expires=Wed; 01 Jan 1970";
            saveSearchButton.click();
          }
        }
      },
      getCookie: function (name) {
        var nameEQ = name + "=";
        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {
          var c = ca[i];

          while (c.charAt(0) == ' ') c = c.substring(1);

          if (c.indexOf(nameEQ) != -1) return c.substring(nameEQ.length, c.length);
        }

        return null;
      },
      onSaveSearchSubmitHandler: function (e) {
        $('#newSearchSaveButton').hide();
        $('.saveSearchProgress').show();
        $.ajax({
          type: "POST",
          url: "/action/doSaveSearch",
          data: $(e.target).serialize(),
          success: searchResult.saveSearchSuccessHandler,
          error: function (data) {
            $('.error.saveSearchMsg').show('fade').removeClass('hidden');
            $('#newSearchSaveButton').show();
            $('.saveSearchProgress').hide();
            $('#saveSearchDialog').modal('toggle');
          }
        });
        return false;
      },
      saveSearchSuccessHandler: function (data) {
        $('.success.saveSearchMsg').show('fade').removeClass('hidden');
        $('#newSearchSaveButton').show();
        $('.saveSearchProgress').hide();
        $('#saveSearchDialog').modal('toggle');
        UX.modal.on.hide();
        searchResult.redrawSavedSearchesPanel(JSON.parse(data).favQueries);
      },

      /**
       * Redraws the table rows using the incoming from favQueries
       *
       * @param {array} jsonData
       */
      redrawSavedSearchesPanel(jsonData) {
        jsonData.forEach((value, index) => {
          if (index >= searchResult.maxSearchQueries) {
            return;
          }

          console.log('trying to render');
          this.render.row(value, index);
        });
      }

    };
    UX.searchResult = searchResult; // add to global namespace
  })();

  (function () {
    var loader = {
      element: '',
      target: '',
      $activator: '',
      doi: '',
      figure: '',
      tab: '',
      references: '',
      related: '',
      details: '',
      defaultTab: null,
      $tabs: null,
      $spinner: null,
      figuresTab: '.figures-tab',
      tabFigure: '#pane-pcw-Figures , #pane-pcw-figures',
      referencesTab: '.references-tab',
      tabReferences: '#pane-pcw-References, #pane-pcw-references',
      relatedTab: '.related-tab',
      tabRelated: '#pane-pcw-Related, #pane-pcw-related',
      detailsTab: '.details-tab',
      accessTab: '.access-tab',
      tabDetails: '#pane-pcw-Details, #pane-pcw-details',
      vPort: 'screen-xs',
      isMobile: false,
      mathJaxConfig: 'MathJax.Hub.Config({CommonHTML: { linebreaks: { automatic: true } },"HTML-CSS": { linebreaks: {automatic: true}},SVG: { linebreaks: { automatic: true} },});',
      init: function () {
        // show spinner
        loader.$tabs = $('article .tab');
        loader.$spinner = $('.tab__spinner');
        loader.defaultTab = loader.$tabs.data('default-tab');
        loader.get.figures();
        loader.get.references();
        loader.get.related();
        loader.get.details();
        loader.controller();
        loader.additionalController();
        loader.truncation.init();

        if ($('article')) {
          loader.load.articleTabs();
        }

        loader.tableToggle();
      },
      controller: function () {
        $('body').on('click', '.boxed-text', function (e) {
          e.preventDefault();
          var $el = $(this),
              boxedContent = $el.attr('href'),
              boxedHtml = $(boxedContent).html(),
              $myModal = $('#myModal');

          if ($myModal.length === 0) {
            var modal_start = '<div class="ux-modal-container"><div id="myModal" class="modal"><div class="modal__dialog  modal--large"><div class="modal-content">',
                modal_header = '<div class="modal__header clearfix"><button type="button" data-dismiss="modal" class="close">X</button></div>',
                modal_body = '<div class="modal__body"></div>',
                modal_end = '</div></div></div></div>',
                modal = modal_start + modal_header + modal_body + modal_end;
            $('body').append(modal);
          }

          $myModal.find('.modal__body').html(boxedHtml);
          $myModal.modal('show');
        });
        $(document).on(loader.vPort + '-on', function () {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          loader.isMobile = true;
          loader.rebuild.responsive();
          loader.rebuild.extra();
          loader.figures.accordion();
        });
        $(document).on(loader.vPort + '-off', function () {
          // Waiting for custom event that will be triggered by controller.js to deactivate responsive effects
          loader.isMobile = false;
          loader.rebuild.original();
          loader.figures.back();
        });
        loader.articleTabsTrigger();
        loader.get.mathjax();
      },
      additionalController: function () {},
      articleTabsTrigger: function () {
        if ($('.access-tab').length) {
          $('.access-tab').trigger('click');
        } else {
          $('.details-tab').trigger('click');
        }

        loader.get.mathjax();
      },
      rebuild: {
        original: function () {
          // return loi to be as default
          var $loaWrapper = $('.loa-wrapper');
          $loaWrapper.find('.accordion-tabbed__tab').removeClass('accordion-tabbed__tab').addClass('accordion-tabbed__tab-mobile');
          $loaWrapper.find('.delimiter').removeClass('hidden');
          var $author = $loaWrapper.find('.accordion-tabbed__control');
          $author.each(function () {
            var id = $(this).attr('data-id');
            $(this).attr('data-db-target-for', id);
            $(this).next().attr('data-db-target-of', id).removeAttr('style');
          });
        },
        responsive: function () {
          // rebuild loi to be in selected responsive mode
          var $loaWrapper = $('.loa-wrapper');
          $loaWrapper.find('.accordion-tabbed__tab-mobile').removeClass('accordion-tabbed__tab-mobile').addClass('accordion-tabbed__tab ').find('.accordion-tabbed__control').removeAttr('data-db-target-for');
          $loaWrapper.find('.loa-accordion').contents().map(function () {
            if (this.nodeType === 3) {
              //Node.TEXT_NODE
              $(this).wrap('<span class="delimiter hidden"></span>');
            }

            if ($(this).hasClass('delimiter')) {
              $(this).addClass('hidden');
            }
          });
          $loaWrapper.find('.accordion-tabbed__content').removeAttr('data-db-target-of').hide();
        },
        extra: function () {}
      },
      get: {
        figures: function () {
          // get current doi
          loader.figure = $('article').attr('data-figures');
        },
        references: function () {
          // get current doi
          loader.references = $('article').attr('data-references');
        },
        related: function () {
          // get current doi
          loader.related = $('article').attr('data-related');
          loader.truncation.creativeWorkMeta();
        },
        details: function () {
          // get current doi
          loader.details = $('article').attr('data-details');
        },
        mathjax: function () {
          if ($("article").attr("data-enable-mathjax") == "true" && ($(".math-formula").length || $(".disp-formula").length || $(".inline-formula").length)) {
            var script = document.createElement("script");
            script.type = "text/javascript";
            script.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"; // use the location of your MathJax

            var config = loader.mathJaxConfig;

            if (window.opera) {
              script.innerHTML = config;
            } else {
              script.text = config;
            }

            document.getElementsByTagName("head")[0].appendChild(script);
          }
        },

        defaultTabClass() {
          let tab = loader.defaultTab;

          if (!tab) {
            tab = $(loader.detailsTab).length ? 'access' : 'details';
          }

          return `.${tab}-tab`;
        },

        detailsTab() {
          const $accessTab = $(loader.accessTab);

          if ($accessTab.length) {
            return $accessTab;
          } else {
            return $(loader.detailsTab);
          }
        }

      },
      load: {
        articleTabs: function () {
          loader.load.figures();
          var $articleReferences = $('.article__body .article__references');

          if ($articleReferences.length) {
            if ($('.article__body.show-references').length) {
              //copy past references
              var articlesRefCopy = $articleReferences.clone();
              articlesRefCopy.appendTo(loader.tabReferences);
              $articleReferences.find('[id]').each(function () {
                //to remove dupliate Ids
                this.id = this.id + "_copied";
              });
            } else {
              //cut past references
              $articleReferences.appendTo(loader.tabReferences);
              $articleReferences.show();
            }

            $(loader.tabReferences).removeClass('empty');
            $('.tab__spinner').hide(); // hide spinner pane
          } else {
            loader.load.references();
          }

          loader.load.related();
          loader.load.details();
        },
        figures: function () {
          // set figures pane as a target and set the requested html file
          if (loader.figure === undefined) {
            // check if figures' service url has been defined
            return false;
          }

          loader.element = loader.figure;
          loader.target = loader.tabFigure;

          if (loader.check.empty()) {
            // check if figures panes is empty
            loader.getContent('figure'); // get references content
          }
        },
        references: function () {
          // set references pane as a target and set the requested html file
          if (loader.references === undefined) {
            // check if references' service url has been defined
            return false;
          }

          loader.element = loader.references;
          loader.target = loader.tabReferences;

          if (loader.check.empty()) {
            // check if figures panes is empty
            loader.getContent('references'); // get references content
          }
        },
        related: function () {
          // set related pane as a target and set the requested html file
          if (loader.related === undefined) {
            // check if related' service url has been defined
            return false;
          }

          loader.element = loader.related;
          loader.target = loader.tabRelated;

          if (loader.check.empty()) {
            // check if figures panes is empty
            loader.getContent('related'); // get references content
          }

          loader.truncation.creativeWorkMeta();
        },
        details: function () {
          // set details pane as a target and set the requested html file
          if (loader.details === undefined) {
            // check if details' service url has been defined
            return false;
          }

          loader.element = loader.details;
          loader.target = loader.tabDetails;

          if (loader.check.empty()) {
            // check if figures panes is empty
            loader.getContent('details'); // get references content
          }
        }
      },
      getContent: function ($elem) {
        // get content using ajax request
        $('.tab__spinner').show(); // show spinner pane

        var $loaderTarget = $(loader.target);
        if ($(loader.target).find('.contentTab').length) $loaderTarget = $(loader.target).find('.contentTab');
        $loaderTarget.load(loader.element, function (response, status, xhr) {
          if (status === 'error') {
            var msg = 'Sorry but there was an error: ';
            console.log(msg + xhr.status + " " + xhr.statusText); //return false; // abort
          }

          $('.tab__spinner').hide(); // hide spinner pane

          $(loader.target).removeClass('empty').trigger('content-loaded');
          loader.check.empty();
          loader.attach();
          var loaderTarget = $(this).attr('id'),
              isFigures = loader.tabFigure.indexOf(loaderTarget) != -1;

          if (isFigures && loader.isMobile) {
            loader.figures.accordion();
          }

          loader.getContentSuccess($elem);
        });
      },
      getContentSuccess: function ($elem) {},
      check: {
        // check if target pane is empty
        empty: function () {
          if ($(loader.target).length <= 0 || !$(loader.target).is(':empty') && $(loader.target).find('.emptyTab').length <= 0) {
            $('.tab__spinner').hide(); // hide spinner pane

            return false; // abort
          } else {
            $(loader.target).removeClass('empty');
            return true;
          }
        }
      },
      attach: function () {
        if (UX.figureViewer !== undefined) UX.figureViewer.expand();
      },
      figures: {
        figcaption: "figcaption",
        figureTitle: ".figure__title",
        figureCaption: ".figure__caption",
        accordionClass: "accordion",
        accordionContent: "accordion__content",
        accordionTrigger: $('<button title="Toggle figure caption" class="accordion__control"/>'),
        accordionTriggerIcon: $('<i aria-hidden="true" class="icon-section_arrow_d"/>'),
        accordionTriggerCaption: $('<span>Caption</span>'),
        accordion: function () {
          //turn figures caption into accordion on mobile
          if (!$(loader.figures.figcaption).hasClass(loader.figures.accordionClass)) {
            loader.figures.accordionTriggerCaption.appendTo(loader.figures.accordionTrigger);
            loader.figures.accordionTriggerIcon.appendTo(loader.figures.accordionTrigger);
            $(loader.figures.figcaption).find(loader.figures.figureCaption).before(loader.figures.accordionTrigger);
            $(loader.figures.figcaption).addClass(loader.figures.accordionClass);
            $(loader.figures.figcaption).find(loader.figures.figureCaption).addClass(loader.figures.accordionContent).hide();
          }
        },
        back: function () {
          // remove accordion features on desktop
          if ($(loader.figures.figcaption).hasClass(loader.figures.accordionClass)) {
            $(".accordion__control").remove();
            $(loader.figures.figcaption).removeClass(loader.figures.accordionClass);
            $(loader.figures.figcaption).find(loader.figures.figureCaption).removeClass(loader.figures.accordionContent).show();
          }
        }
      },
      truncation: {
        toTrunk8: '.loa-accordion',
        toTrunk8Mobile: '.loa.mobile-authors',
        linesToShow: 3,
        showMoreText: 'Show all Authors',
        showLessText: 'Show less Authors',
        init: function () {
          if (loader.isMobile) {
            $(loader.truncation.toTrunk8Mobile).not("[data-truncate='none']").truncate({
              lines: loader.truncation.linesToShow,
              type: 'list',
              seeMoreLink: true,
              seeMoreText: loader.truncation.showMoreText,
              seeLessText: loader.truncation.showLessText,
              isMobile: true,
              mobileTarget: '#sb-1'
            });
          } else {
            $(loader.truncation.toTrunk8).not("[data-truncate='none']").truncate({
              lines: loader.truncation.linesToShow,
              type: 'list',
              seeMoreLink: true,
              seeMoreText: loader.truncation.showMoreText,
              seeLessText: loader.truncation.showLessText
            });
          }
        },
        creativeWorkMeta: function () {
          $('.creative-work .meta').not("[data-truncate='none']").truncate({
            lines: 1
          });
        }
      },
      tableToggle: function () {
        var $triggers = $(".tableToggle__trigger");

        if ($triggers.length) {
          $triggers.on("click", function (event) {
            var $target = $(event.currentTarget),
                $tableToggle = $target.closest(".tableToggle");
            $tableToggle.find(".tableToggle__table").toggle();
            $tableToggle.find(".tableToggle__image").toggle();
            $target.find("span").toggle();
          });
        }
      }
    };
    UX.loader = loader; // add to global namespace
  })();

  (function () {
    const tocJs = {
      $loa: null,
      vPort: 'screen-xs',
      init: function () {
        const $toSection = $('.to-section');

        if ($toSection.length) {
          $toSection.each(function () {
            var section = $(this).text();
            var id = $(this).attr("id");
            $('<li role="menuitem"><a class="w-slide__hide" href="#' + id + '"><span>' + section + '</span></a></li>').appendTo('.sections__drop');
          });
        } else {
          $('.toc-go-section, .toc__section').remove();
        }

        tocJs.$loa = $('.issue-item .loa, .search__item .meta__authors, .search__item .loa');
        tocJs.control();
      },

      control() {
        $(window).on('load orientationchange', function (event) {
          tocJs.truncate();
        });
        $(document).on(tocJs.vPort + '-on', function () {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          tocJs.isMobile = true;
          tocJs.truncate();
        });
        $(document).on(tocJs.vPort + '-off', function () {
          // Waiting for custom event that will be triggered by controller.js to deactivate responsive effects
          tocJs.isMobile = false;
          tocJs.truncate();
        });
      },

      truncate() {
        try {
          tocJs.$loa.not("[data-truncate='none']").truncate({
            lines: 2,
            type: 'list',
            seeMoreLink: true,
            seeMoreText: 'See all authors',
            seeLessText: 'See fewer authors'
          });
        } catch (err) {}
      }

    };
    UX.tocJs = tocJs; // add to global namespace
  })();

  document.addEventListener('DOMContentLoaded', function (event) {
    var SETTINGS = {
      ENDPOINT: 'https://crossmark.crossref.org/dialog',
      SCRIPT_VERSION: 'v2.0',
      // LOGO_URL: 'http://crossmark-cdn.crossref.org/widget/v2.0/logos/crossmark-logo-square.svg',
      STYLESHEET_URL: 'https://crossmark-cdn.crossref.org/widget/v2.0/style.css'
    };
    var touchStarted = false;
    var touchArea;

    var tapEvent = function (element, callback) {
      element.addEventListener('click', function (event) {
        if (event.ctrlKey || event.shiftKey || event.metaKey || event.which !== 1) {
          return;
        }

        return callback(event);
      }, false);
      element.addEventListener('touchstart', function (event) {
        if (event.touches.length > 1) return touchStarted = false;
        touchArea = {
          x: event.touches[0].screenX,
          y: event.touches[0].screenY
        };
        touchStarted = element;
        event.stopPropagation();
      }, false);
      window.addEventListener('touchstart', function (event) {
        touchStarted = false;
      });
      element.addEventListener('touchmove', function (event) {
        if (event.touches.length > 1) return touchStarted = false;
        var newTouchArea = {
          x: event.touches[0].screenX,
          y: event.touches[0].screenY
        };

        if (Math.pow(touchArea.x - newTouchArea.x, 2) + Math.pow(touchArea.y - newTouchArea.y, 2) > 500) {
          touchStarted = false;
        }
      }, false);
      element.addEventListener('touchend', function (event) {
        if (touchStarted) {
          touchStarted = false;
          var x = event.changedTouches[0].pageX - window.pageXOffset;
          var y = event.changedTouches[0].pageY - window.pageYOffset;
          var target = document.elementFromPoint(x, y);
          return callback(event);
        } else {
          event.preventDefault();
        }
      }, false);
    };

    var buildQueryString = function (data) {
      var query = [];

      for (var key in data) {
        query.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key]));
      }

      return '?' + query.join('&');
    };

    var isIos = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Scan for case-insensitive.

    var getDoiMeta = function () {
      var metaTags = document.querySelectorAll("meta");

      for (var i in metaTags) {
        if (metaTags.hasOwnProperty(i)) {
          var tag = metaTags[i];

          if ((tag.name || "").toLowerCase() == "dc.identifier" && tag.scheme == "doi") {
            return tag;
          }
        }
      }
    };

    var doiMeta = getDoiMeta();
    var doi = doiMeta ? doiMeta.getAttribute('content').replace(/^(info:doi\/|doi:)/, '') : null;
    if (doi == null) doi = $("#crossMark").data('doi');
    var queryData = {
      doi: doi,
      domain: window.location.hostname,
      uri_scheme: window.location.protocol,
      cm_version: SETTINGS.SCRIPT_VERSION
    };
    var css = document.createElement('link');
    css.setAttribute('href', SETTINGS.STYLESHEET_URL);
    css.setAttribute('type', 'text/css');
    css.setAttribute('rel', 'stylesheet');
    document.querySelector('head').appendChild(css);
    var widget = document.createElement('div');
    widget.setAttribute('id', 'crossmark-widget'); // Initial display none to avoid a flash on load.

    widget.style.display = 'none';
    widget.innerHTML = '<div class="crossmark-reset crossmark-overlay"></div>' + '<div class="crossmark-reset crossmark-popup">' + '<div class="crossmark-reset crossmark-popup__offset">' + '<div class="crossmark-reset crossmark-popup__inner">' + '<div class="crossmark-reset crossmark-popup__header">' + '<button class="crossmark-reset crossmark-popup__btn-close"><span class="sr-only">Close crossmark popup</span></button>' + '</div>' + '<div class="crossmark-reset crossmark-popup__content-wrapper">' + '<iframe title="Crossmark service - Intentionally blank" aria-hidden="true" class="crossmark-reset crossmark-popup__content"></iframe>' + '</div>' + '</div>' + '</div>' + '</div>';
    var overlay = widget.querySelector('.crossmark-overlay');
    var popup = widget.querySelector('.crossmark-popup');
    var popupOffset = widget.querySelector('.crossmark-popup__offset');
    var popupInner = widget.querySelector('.crossmark-popup__inner');
    var logo = widget.querySelector('.crossmark-popup__logo');
    var content = widget.querySelector('.crossmark-popup__content');
    var closeButton = widget.querySelector('.crossmark-popup__btn-close');
    if (isIos) popupOffset.classList.add('is-ios'); // logo.setAttribute('src', SETTINGS.LOGO_URL);

    document.body.appendChild(widget);
    [overlay, popup, closeButton].map(function (element) {
      tapEvent(element, function (event) {
        widget.style.display = 'none';
        event.preventDefault();
        event.stopPropagation();
      });
    });
    tapEvent(popupInner, function (event) {
      event.stopPropagation();
    });
    var initialised = false; // delete queryData.domain;

    var links = [].slice.call(document.querySelectorAll('[data-target=crossmark]'), 0);
    links.map(function (link) {
      link.style.cursor = 'pointer';
      link.setAttribute('href', SETTINGS.ENDPOINT + buildQueryString(queryData));
      tapEvent(link, function (event) {
        if (!initialised) {
          content.setAttribute('src', SETTINGS.ENDPOINT + buildQueryString(queryData));
          initialised = true;
        }

        widget.style.display = 'block';
        if (isIos) popupInner.style.top = window.scrollY + 'px';
        event.preventDefault();
        event.stopPropagation();
      });
    });
  });

  (function () {
    var adplaceholder = {
      init: function () {
        $(".js__toggleAdForm").on("click", function (e) {
          e.preventDefault();
          var elemToToggle = "#" + $(this).data("toggle");
          $(elemToToggle).slideToggle();
        });
      }
    };
    UX.adplaceholder = adplaceholder; // add to global namespace
  })();

  (function () {
    var $window = $(window),
        $body = $('body');
   // variable use to determine if responsive mode is on or off

    function createAndAppendInput(name, value, form) {
      var inp = document.createElement("input");
      inp.type = "hidden";
      inp.name = name;
      inp.value = value;
      form.append(inp);
    }

    var alerts = {
      $target: null,
      $toggle: null,
      init: function () {
        alerts.$toggle = $("[name='markall']"); //alerts.on.build();

        alerts.control();
      },
      control: function () {
        $body.on('click', '[name="markall"]', function (e) {
          //e.preventDefault();
          alerts.$target = $(this).closest('.alert__list');

          if ($(this).closest('#citationAlerts').length) {
            alerts.$target = $('#citationAlerts');
          }

          if ($(this).prop('checked')) {
            alerts.$target.find('[type="checkbox"]:not(:checked)').click();
          } else {
            alerts.$target.find('[type="checkbox"]:checked').click();
          }
        });
        $body.on('change', '.alert__freq', function (e) {
          alerts.on.frequency_change($(this));
        });
        $body.on('change', '.alert__sort', function (e) {
          alerts.on.sorting_change($(this));
        });
        $body.on('click', '.js__citActions', function (e) {
          alerts.on.cit_actions_change($(this));
        });
        $body.on('click', '.btn--cancel', function (e) {
          e.preventDefault();
          alerts.on.reset_form($(this));
        });
      },
      on: {
        build: function () {},
        error_msg: function () {
          alert('Please select one publication at least');
        },
        frequency_change: function ($el) {
          var form = $el.parents("form"),
              value = $el.find('select').val();
          form.find("input[name=action]").val(""); //clear the delete field

          createAndAppendInput("save", "true", form);
          createAndAppendInput("updateAxa", "true", form);
          form.submit();
        },
        sorting_change: function ($el) {
          var sortBy = $el.find('select').val();
          var activeTab = "#" + $el.closest("li[role='tabpanel']").attr('id');
          sessionStorage.setItem('activeTab', activeTab);
          $('<form action="/action/showAlertSettings">' + '<input type="hidden" name="type" value="citation" />' + '<input type="hidden" name="menuTab" value="Alerts"/>' + '<input type="hidden" name="sortBy" value="' + sortBy + '"/>' + '</form>').appendTo('body').submit();
        },
        cit_actions_change: function ($el) {
          var form = $el.parents("form"),
              val = $el.attr('data-value');
          if (!val) return;

          if (!$('input[type=checkbox][name="citId"]:checked').length) {
            alerts.on.error_msg();
            return;
          }

          form.find("input[name=action]").val(val);
          if ($el.parents('.dropBlock__holder').length) UX.dropBlock.on.hide();
          var activeTab = "#" + $el.closest("li[role='tabpanel']").attr('id');
          sessionStorage.setItem('activeTab', activeTab);
          form.get(0).submit();
        },
        reset_form: function ($el) {
          var $form = $el.closest('form');
          $form.trigger('reset');
          $form.find('input[name=pubCode], input[name=markall]').prop('checked', false);
          $form.find('input[name=format][value=T]').prop('checked', true);
        }
      }
    };
    UX.alerts = alerts; // add to global namespace
  })();

  (function () {
    var favorites = {
      actions_select: ".favoritePublicationsOptions",
      sort_select: ".sortOptions",
      actions_activator: ".js__favActions",
      sort_activator: ".js__favSort",
      tabs_nav: '.account-tab__nav a',
      $body: $('body'),
      lastModfied: '',
      vPort: '',
      type: 'Article',
      init: function () {
        favorites.controller();
        favorites.addEventsToActions();
        favorites.additionalController();
        favorites.manipulateUrl();
      },
      controller: function () {
        favorites.$body.on('click', favorites.actions_activator, function () {
          $(this).closest(favorites.actions_select).val($(this).data("value"));
          $(this).closest(favorites.actions_select).trigger("change");
        });
        $(favorites.sort_select).change(function () {
          favorites.fav_sort(this);
        });
        favorites.$body.on('click', favorites.sort_activator, function () {
          $(this).closest(favorites.sort_select).val($(this).data("value"));
          $(this).closest(favorites.sort_select).trigger("change");
        });
        favorites.$body.on('click', '[name="markall"]', function (e) {
          var $target = $(this).parents('form').find('tbody .table__mark'),
              $target_input = $target.find('[type="checkbox"]'),
              $target_jcf_span = $target.find('.jcf-checkbox'),
              check = $(this).prop('checked');
          $target_input.prop('checked', check);

          if (check) {
            $target_jcf_span.removeClass('jcf-unchecked');
            $target_jcf_span.addClass('jcf-checked');
          } else {
            $target_jcf_span.removeClass('jcf-checked');
            $target_jcf_span.addClass('jcf-unchecked');
          }
        });
        favorites.$body.on('click', favorites.tabs_nav, function () {
          favorites.type = $(this).attr('data-type');
        });
      },
      additionalController: function () {},
      addEventsToActions: function () {
        $(favorites.actions_select).change(function () {
          favorites.fav_actions(this);
        });
      },
      error_msg: function () {
        alert('Please select one publication at least');
      },
      fav_actions: function (el) {
        if (!$('input[type=checkbox][name="doi"]:checked').length) {
          favorites.error_msg();
          $(el).val('');
          return;
        }

        var val = $(el).val();
        var form = $(el).parents("form");
        var action = '';
        if (!val) return;

        if (val == 'alert') {
          action = '/action/doUpdateAlertSettings';
          $('option[value=' + val + ']', el).val('addJournalBookAlert');
        } else if (val == 'delete') {
          action = form.attr('action');
        } else if (val == 'publicationAddJournalBookAlert') {
          action = '/action/doUpdateAlertSettings';
          $('option[value=' + val + ']', el).val('addJournalBookAlert');
          $("input[type=checkbox][name=doi]").each(function () {
            $(this).val($(el).parent("td").attr("serialDoi"));
          });
        } else {
          action = val;
        }

        form.attr('action', action);
        var activeTab = "#" + $(el).closest("li[role='tabpanel']").attr('id');
        sessionStorage.setItem('activeTab', activeTab);
        form.get(0).submit();
      },
      fav_sort: function (el) {
        var val = $(el).val();
        if (!val) return;
        var action = $('[name="currentUrl"]').val();
        var form = ['<form method="GET" action="' + action + '">'];
        form.push('<input type="hidden" name="' + 'menuTab' + '" value="' + 'favorites' + '"/>');
        form.push('<input type="hidden" name="' + 'sortBy' + '" value="' + val + '"/>');
        form.push('<input type="hidden" name="' + 'publicationSortBy' + '" value="' + $(".js__favSort").val() + '"/>');
        form.push('<input type="hidden" name="' + 'type' + '" value="' + favorites.type + '"/>');
        form.push('</form>');
        var activeTab = "#" + $(el).closest("li[role='tabpanel']").attr('id');
        sessionStorage.setItem('activeTab', activeTab);
        $(form.join('')).appendTo('body')[0].submit();
        form.submit();
        $(form).remove();
      },
      manipulateUrl: function () {
        var pathname = favorites.getLocationUrl();
        $('[name="href"]').val(pathname);
        var strippedPathname = favorites.stripParam(pathname, 'sortBy');
        $('[name="currentUrl"]').val(strippedPathname);
        var favType = favorites.getParam(pathname, 'type');

        if (favType) {
          favorites.type = favType;

          if ($(favorites.tabs_nav + "[data-type='" + favType + "']").length) {
            $(favorites.tabs_nav + "[data-type='" + favType + "']").trigger('click');
          }
        }
      },
      getLocationUrl: function () {
        var pathname = window.location.pathname,
            url = window.location.href,
            originalRequestUri = pathname + url.split(pathname)[1];
        return originalRequestUri;
      },
      stripParam: function (originalRequestUri, param) {
        var newPathname = '';
        var arr = originalRequestUri.split('&');
        $.each(arr, function (key, value) {
          var indexOfParam = this.indexOf(param);

          if (indexOfParam == 0) {
            arr[key] = '';
          }

          newPathname += arr[key];
          if (key < arr.length - 1 && indexOfParam != 0) newPathname += '&';
        });
        return newPathname;
      },
      getParam: function (originalRequestUri, param) {
        var arr = originalRequestUri.split('&');
        var type = '';
        $.each(arr, function (key, value) {
          var keyVal = this.split('=');

          if (keyVal[0] === param) {
            type = keyVal[1];
            return false;
          }
        });
        return type;
      }
    };
    UX.favorites = favorites; // add to global namespace
  })();

  (function () {
    var $body = $('body');
    var profileMain = {
      $select: null,
      init: function () {
        profileMain.control();
      },
      control: function () {
        $body.on('change', '#institutionList', function (e) {
          e.preventDefault();
          profileMain.$select = $(this);
          var href = profileMain.$select.val();
          location.href = href;
        });

        if ($("#institutionList option").length <= 2) {
          $("#institutionList").val($("#institutionList option").eq(1).val());
        } else {
          if ($("#institutionList").find("option[value='" + location.toString() + "']").length) $("#institutionList").val(location.toString());else $("#institutionList").val("#");
        }
      }
    };
    UX.profileMain = profileMain; // add to global namespace
  })();

  (function () {
    var reports = {
      $form: $("#institutionUsageReport"),
      report_input_name: "counterIds",
      submitActor: null,
      $submitActors: null,
      init: function () {
        this.$submitActors = this.$form.find('button[type=submit]');
        reports.controller();
      },
      controller: function () {
        reports.$submitActors.click(function (event) {
          reports.submitActor = this;
        });
        reports.$form.submit(function (event) {
          event.preventDefault();

          if (null === reports.submitActor) {
            // If no actor is explicitly clicked, the browser will
            // automatically choose the first in source-order
            // so we do the same here
            reports.submitActor = reports.$submitActors[0];
          }

          $('<input />').attr('type', 'hidden').attr('name', reports.submitActor.name).attr('value', "").appendTo(reports.$form);
          var error_msg = $(this).children('.error_msg');
          var dateRangeCheck = reports.check.dateRange();
          var reportsRange = reports.check.selectedReports();

          if (dateRangeCheck && reportsRange) {
            $(this).unbind('submit').submit();
            error_msg.hide();
          } else {
            var notifyEmail_error_msg = $('[name="notify"]').next('.error_msg');
            notifyEmail_error_msg.hide();
            error_msg.hide();

            if (reports.submitActor.name == "notify") {
              notifyEmail_error_msg.html("Please fix the errors below in order to complete your request.");
              notifyEmail_error_msg.show();
            } else {
              error_msg.html("Please fix the errors in order to complete report request.");
              error_msg.show();
            }
          }
        });
        reports.$form.on('click change', '.ranges-selects select', function () {
          reports.on.selectRange();
        });
        reports.$form.on('click change', '.year-select select', function () {
          reports.on.selectYear();
        });
      },
      error_msg: function (msg) {
        alert("Errors:\n" + msg);
      },
      on: {
        selectRange: function () {
          var el = reports.$form.find("#dateRange");
          el.find('input[type="radio"]').prop('checked', false);
          el.find('input#range-date').prop('checked', true);
        },
        selectYear: function () {
          var el = reports.$form.find("#dateRange");
          el.find('input[type="radio"]').prop('checked', false);
          el.find('input#year-date').prop('checked', true);
        }
      },
      check: {
        dateRange: function () {
          var el = reports.$form.find('#dateRange');

          if (el.find('input#range-date:checked').length) {
            // start date
            var month = el.find('select#startMonthId').val();
            var year = el.find('select#startYear').val();
            var start = new Date(year, month, 1); // end date

            month = el.find('select#endMonthId').val();
            year = el.find('select#endYear').val();
            var end = new Date(year, month, 1);
            var msg = [];
            if (start > end) msg.push('This is not a valid month range');
            var numMonths = reports.monthDiff(start, end);
            if (numMonths > 12) msg.push('Number of report months must be less than or equal to 12');
            var error_msg = el.find('.error_msg');

            if (msg.length) {
              error_msg.html(msg.join('<br>'));
              error_msg.show();
              return false;
            } else {
              error_msg.html('');
              error_msg.hide();
              return true;
            }
          }

          return true;
        },
        selectedReports: function () {
          var el = reports.$form.find('#reports');
          var error_msg = el.find('.error_msg');

          if (!el.find('input[name="' + reports.report_input_name + '"]:checked').length) {
            error_msg.html("Please select at least one report");
            error_msg.show();
            return false;
          } else {
            error_msg.html("");
            error_msg.hide();
            return true;
          }
        }
      },
      monthDiff: function (d1, d2) {
        var months;
        months = (d2.getFullYear() - d1.getFullYear()) * 12;
        months -= d1.getMonth() + 1;
        months += d2.getMonth();
        return months <= 0 ? 0 : months;
      }
    };
    UX.reports = reports; // add to global namespace
  })();

  (function () {
    var cookiePolicyPopupWidget = {
      $element: $('.cookiePolicy-popup'),
      acceptUrl: '/action/cookiePolicy?response=accept',
      init: function () {
        cookiePolicyPopupWidget.control();
      },
      control: function () {
        cookiePolicyPopupWidget.additionalControl();
        cookiePolicyPopupWidget.$element.on('click', '.cookiePolicy-popup__close, #accept-cookie-policy', function (e) {
          e.preventDefault();
          $.get(cookiePolicyPopupWidget.acceptUrl, function () {
            console.log("Cookies Accepted!");
          });
          cookiePolicyPopupWidget.$element.slideUp('fast', function () {
            cookiePolicyPopupWidget.$element.remove();
            cookiePolicyPopupWidget.cookieRemoved(); // @TODO: This fix is to be removed after the fix that Haitham Athamneh will apply

            if (UX.coolbar) {
              UX.coolbar.headerHeight = $('header').outerHeight() || 0;
              $('.coolBar--res').addClass('trans').css('top', UX.coolbar.headerHeight);
            }

            if (UX.pageBody && UX.pageBody.on && UX.pageBody.on.setContentTopPadding) {
              UX.pageBody.on.setContentTopPadding(true);
            }
          });
        });
      },
      cookieRemoved: function () {},
      additionalControl: function () {}
    };
    UX.cookiePolicyPopupWidget = cookiePolicyPopupWidget;
  })();

  (function () {
    var administrators = {
      $removeBtn: $('.js__removeAdmins'),
      init: function () {
        administrators.controller();
      },
      controller: function () {
        administrators.$removeBtn.on('click', function (e) {
          e.preventDefault();
          e.stopPropagation();
          administrators.form.submit();
        });
      },
      form: {
        submit: function () {
          var hasUserChecked = administrators.form.conflictCheck();

          if (!hasUserChecked) {
            administrators.form.error_msg();
            return;
          } else {
            administrators.$removeBtn.closest('form').submit();
          }
        },
        conflictCheck: function () {
          return administrators.$removeBtn.closest('form').find('[type="checkbox"]:checked').length !== 0;
        },
        error_msg: function () {
          alert('Please select an administrator to remove.');
        }
      }
    };
    UX.administrators = administrators; // add to global namespace
  })();

  (function () {
    var $body = $('body'),
        $dropblock__holder,
        $multi_search; // get the 'data-widget-id' attribute from the current generated widget

    function getWidgetId(elem) {
      var widgetEl = elem.parents('[data-widget-id]')[0];
      var widgetId = widgetEl ? $(widgetEl).data('widget-id') : '';
      return widgetId;
    } // get The content attribute from the meta tag in the head


    function getPbContext() {
      var pbContext = $('[name="pbContext"]').attr('content');
      return pbContext ? pbContext : '';
    }

    var multiSearch = {
      init: function () {
        $dropblock__holder = $('.multi-search__dropblock__holder'); //$multi_search = $('.multi-search');

        multiSearch.control();
      },
      control: function () {
        $body.on('click', '.multi-search__dropblock__holder a', function () {
          var el = $(this);
          multiSearch.set.parent(el);
          multiSearch.on.select.dropdown(el);
        });
        $body.on('click', 'a.remove-topic', function () {
          var el = $(this);
          var widgetID = getWidgetId(el);
          multiSearch.set.parent(el);
          multiSearch.topic.remove(widgetID);
        });
      },
      on: {
        select: {
          dropdown: function (elem) {
            var tagLabel = elem.data('label');
            var tagId = elem.data('value');
            var widgetID = getWidgetId(elem);
            multiSearch.topic.add(tagLabel, tagId, widgetID);
          }
        }
      },
      topic: {
        add: function (label, id, widgetID) {
          var params = {
            'multiSearchAction': 'applyTopic',
            'tagId': id,
            'tagLabel': label,
            'widgetId': widgetID
          };
          multiSearch.ajax(params);
        },
        remove: function (widgetID) {
          var params = {
            'multiSearchAction': 'removeTopic',
            'widgetId': widgetID
          };
          multiSearch.ajax(params);
        },
        lazyload: function () {
          function lazyLoad() {
            $('.lazy-load').remove();
            $('.delayLoad').removeClass('delayLoad').addClass('delayedLoad');
          }

          $('.creative-work .loa').not("[data-truncate='none']").truncate({
            lines: 2,
            type: 'list',
            addClass: 'loa-height'
          });
          $('.card .creative-work .loa').not("[data-truncate='none']").truncate({
            lines: 1,
            type: 'list',
            addClass: 'loa-height'
          });
          setTimeout(lazyLoad, 10);
        }
      },
      set: {
        parent: function (elem) {
          $multi_search = $(elem.parents('.multi-search')[0]);
        }
      },
      ajax: function (params) {
        params['pbContext'] = getPbContext();
        $.ajax({
          type: 'GET',
          url: '/pb/widgets/multiSearch/updateTopic',
          dataType: 'html',
          data: params,
          async: true,
          success: function (html) {
            multiSearch.render(html);
            multiSearch.topic.lazyload();
          },
          error: function (error) {
            console.log(error);
          }
        });
      },
      render: function (html) {
        $multi_search.html('');
        $multi_search.replaceWith(html);
      }
    };
    UX.multiSearch = multiSearch;
  })();

  $(document).ready(function () {
    // display user login popup - loginBar
    $(document).on('click', '#indivLogin, #guestLogin', function (event) {
      event.preventDefault();
      event.stopPropagation();
      $(this).toggleClass("active");
      $(".navigation-login-dropdown-container:not(.login-options)").toggleClass('hidden');

      if ($('.search-open').is(":visible")) {
        toggleQuickSearch();
      }
    });
    $(document).on('click', function (e) {
      if ($(e.target).attr('id') !== 'indivLogin' && $(e.target).attr('id') !== 'guestLogin' && !$('.navigation-login-dropdown-container').hasClass('hidden')) {
        $('.navigation-login-dropdown-container').addClass('hidden');
      }
    }); // enable sumbit btn for access token widget

    $('#accessTokenForm div.input-group input[type=text]').on('keyup input change', function () {
      !$('#accessTokenForm div.input-group #tokenAccess').val().length ? $('#accessTokenForm input[type=submit]').attr('disabled', 'disabled') : $('#accessTokenForm input[type=submit]').removeAttr('disabled');
    }); // enable sumbit btn for access token widget

    $('.registration-popup input[type=submit]').attr('disabled', 'disabled');
    $('.registration-popup input[type=text]').on('keyup input change', function () {
      !$(this).val().length ? $('.registration-form input[type=submit]').attr('disabled', 'disabled') : $('.registration-form input[type=submit]').removeAttr('disabled');
    }); // display verification code hidden msg after 3m

    if ($('#check-if-exist')) {
      setTimeout(function () {
        $('#hidden-message').css('visibility', 'visible');
      }, 30000);
    } // enable sumbit btn for 2-step widget


    $('#check-if-exist input[type=input]').on('keyup input change', function () {
      !$('#check-if-exist input[type=input]').val().length ? $('#check-if-exist input[type=submit]').attr('disabled', 'disabled') : $('#check-if-exist input[type=submit]').removeAttr('disabled');
    });
  });
  $(window).on('load', function () {
    // recaptcha load
    if ($('.g-recaptcha').length) {
      loadRecaptcha();
    }
  });

  function loadInstitutionPage(selectDom) {
    var href = $(selectDom).val();
    location.href = href;
  }

  window.loadInstitutionPage = loadInstitutionPage; // add to global namespace

  (function () {
    var $window = $(window);
    var transplant = {
      $element: null,
      $target: null,
      $order: null,
      $cloneData: null,
      init: function () {
        var transArray = $('[data-toggle="transplant"]');
        transArray.each(function (index) {
          transplant.$element = $(this).data('transplant');
          transplant.$target = $($(this).data('target'));
          transplant.$direction = $($(this).data('direction'));
          transplant.$order = $(this).data('transplant-order');
          transplant.$remove = $(this).data('remove');
          transplant.$targetClass = $(this).data('target-class');
          transplant.$classNames = $(this).data('class-names');

          if (transplant.$direction == "to" || typeof transplant.$direction == 'undefined') {
            if (transplant.$element === 'self') {
              transplant.$element = $(this);
            } else {
              transplant.$element = $(this).find(transplant.$element);
            }

            transplant.$cloneData = transplant.$element.clone(true, true).removeAttr('data-toggle').attr('data-transplant-order', transplant.$order);
            transplant.clone();

            if (transplant.$targetClass) {
              transplant.$target.find('.transplanted-clone').addClass(transplant.$targetClass);
            }

            if (transplant.$classNames) {
              transplant.$element.addClass(transplant.$classNames);
            }

            if (transplant.$remove == true) {
              transplant.remove();
            }
          } else {
            transplant.$target = $(this);
            var array = $(this).data('target').split(",");
            $.each(array, function (index, item) {
              // go through selectors
              transplant.$element = $(item);
              transplant.$cloneData = transplant.$element.clone(true, true).attr('data-transplant-order', transplant.$order);
              transplant.clone();

              if (transplant.$targetClass) {
                transplant.$element.addClass(transplant.$targetClass);
              }

              if (transplant.$classNames) {
                transplant.$target.find(".transplanted-clone").addClass(transplant.$classNames);
              }

              if (transplant.$remove == true) {
                transplant.remove();
              }
            });
          }
        });
        transplant.order();
      },
      clone: function () {
        if (transplant.$element.hasClass('cloned')) return;

        if (transplant.$target.find('.transplanted-clone').length <= 0) {
          transplant.$target.append('<div class="transplanted-clone"></div>');
        }

        transplant.$target.find('.transplanted-clone').append(transplant.$cloneData);
        transplant.$element.addClass('cloned');
      },
      order: function () {
        var clonedItems = transplant.$target.find('.transplanted-clone').children();
        clonedItems.sort(function (a, b) {
          return $(a).data("transplant-order") - $(b).data("transplant-order");
        });
        transplant.$target.find('.transplanted-clone').html(clonedItems);
      },
      remove: function () {
        if (transplant.$target) {
          transplant.$element.remove();
        } else {
          transplant.$source.remove();
        }
      }
    };
    UX.transplant = transplant; // add to global namespace
  })();

  (function () {
    var $body = $('body'),
        $document = $(document);
    var authorIndex = {
      init: function () {
        authorIndex.on.build();
      },
      on: {
        build: function () {
          //author-index__filters
          var selectedletter = authorIndex.get.letter("alphabetRange");
          if (selectedletter && selectedletter != null) $(".author-index__filters .alphanumeric-title[title=" + selectedletter + "]").addClass('is--selected');
          var $alpha_letters = $('#alphaFace .is--selected');
          $alpha_letters.each(function () {
            $(".author-index__alphanumeric").append("<span class='letter'>" + $(this).text() + "</span>");
          });
        }
      },
      get: {
        letter: function (name) {
          name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
          var regexS = "[\\?&]" + name + "=([^&#]*)";
          var regex = new RegExp(regexS);
          var results = regex.exec(location.href);
          return results == null ? null : results[1];
        }
      }
    };
    UX.authorIndex = authorIndex; // add to global namespace
  })();

  (function () {
    var $window = $(window),
        $body = $('body');
    var devicePairing = {
      $pairedDevicesTable: $(".device-pairing__devices table"),
      $noPairedDevicesResult: $(".device-pairing__devices .no-result"),
      $pairingHistoryTable: $(".device-pairing__history table"),
      pairingHistoryTableRow: '.device-pairing__history tbody tr',
      $noPairedDevicesHistoryResult: $(".device-pairing__history .no-result"),
      $instAdminUnpairSelectedBtn: $("#instAdminUnpairSelected"),
      $instAdminUnpairAllBtn: $("#instAdminUnpairAll"),
      $unpairDialogForm: $("#unpairDevicesDialogForm"),
      selectedDevicesArray: [],
      $deviceSelectedList: $(".device-pairing__selectedList"),
      $unpairButtonsPanel: $(".unpairButtonsPanel"),
      paginationContainer: '.device-pairing__pagination',
      widgetId: $("#widgetId").text(),
      pbContext: encodeURI($("[name='pbContext']").attr("content")),
      $selectEmailInstButton: $(".selectEmailInstButton"),
      $confirmAddEmailButton: $('.confirmAddEmailButton'),
      $continueInstButton: $('.continueInstButton'),
      isInstitutionMode: $('.dp-institution-template').length > 0,
      clientPagination: null,
      init: function () {
        if (!$('.device-pairing-demo').length) {
          devicePairing.initialization();
        }

        devicePairing.clientPagination = jQuery.extend(true, {}, UX.clientPagination);
        devicePairing.clientPagination.set.containerName(devicePairing.paginationContainer);
        devicePairing.clientPagination.set.tableRowName(devicePairing.pairingHistoryTableRow);
        devicePairing.clientPagination.init();
        devicePairing.control();
        devicePairing.additionalControl();
      },
      initialization: function () {
        if (devicePairing.$pairedDevicesTable.length > 0) {
          if (devicePairing.isInstitutionMode) {
            $.get("/pb/widgets/ux3/DevicePairingManagementController/pairedDevicesOfUser?widgetId=" + devicePairing.widgetId + "&pbContext=" + devicePairing.pbContext, {
              serviceName: $(".serviceNameHidden").text(),
              userEmail: $(".userEmailHidden").text()
            }).done(function (html) {
              devicePairing.on.fillPairedDevicesTable(html);
            }).fail(function (jqXHR, textStatus, errorThrown) {
              devicePairing.on.displayErrorDialog("error occure on the server : " + errorThrown);
            });
          } else {
            $.get("/pb/widgets/ux3/DevicePairingController/pairedDevices?widgetId=" + devicePairing.widgetId + "&pbContext=" + devicePairing.pbContext, {}).done(function (html) {
              devicePairing.on.fillPairedDevicesTable(html);
            }).fail(function (jqXHR, textStatus, errorThrown) {
              devicePairing.on.displayErrorDialog("error occure on the server : " + errorThrown);
            });
          }
        }

        if (devicePairing.$pairingHistoryTable.length > 0) {
          $.get("/pb/widgets/ux3/DevicePairingManagementController/pairingHistory?widgetId=" + devicePairing.widgetId + "&pbContext=" + devicePairing.pbContext, {
            serviceName: $(".serviceNameHidden").text(),
            userEmail: $(".userEmailHidden").text()
          }).done(function (html) {
            if (html.indexOf("device-pairing__row") >= 0) {
              devicePairing.$pairingHistoryTable.find("tbody").html(html);
              devicePairing.$pairingHistoryTable.trigger("update");
              devicePairing.clientPagination.buildPagination();
              devicePairing.$pairingHistoryTable.removeClass('hidden');
              devicePairing.$noPairedDevicesHistoryResult.addClass('hidden');
            } else {
              devicePairing.$pairingHistoryTable.addClass('hidden');
              devicePairing.$noPairedDevicesHistoryResult.removeClass('hidden');
            }
          }).fail(function (jqXHR, textStatus, errorThrown) {
            devicePairing.on.displayErrorDialog("error occure on the server : " + errorThrown);
          });
        }
      },
      control: function () {
        $body.on('change', '.institutionId-radio', function (e) {
          devicePairing.$continueInstButton.prop("disabled", false);
        });
        $body.on('change', '.instEmailSelected-checkbox', function (e) {
          if ($("input[name=instEmailSelected]:checked").length > 0) {
            devicePairing.$selectEmailInstButton.prop("disabled", false);
          } else {
            devicePairing.$selectEmailInstButton.prop("disabled", true);
          }
        });
        $body.on('keyup', '.instEmailSelected-textbox', function (e) {
          $(".device-pairing__add-instEmail .error").addClass('hidden');

          if ($(this).val() != '') {
            if (!devicePairing.check.isValidEmail($(this).val())) devicePairing.$confirmAddEmailButton.prop("disabled", true);else devicePairing.$confirmAddEmailButton.prop("disabled", false);
          } else {
            devicePairing.$confirmAddEmailButton.prop("disabled", true);
          }
        });
        $body.on('focusout', '.instEmailSelected-textbox', function (e) {
          if ($(this).val() != '') {
            if (!devicePairing.check.isValidEmail($(this).val())) {
              $(".device-pairing__add-instEmail .error").removeClass('hidden');
            } else {
              devicePairing.$confirmAddEmailButton.prop("disabled", false);
            }
          }
        });
        $body.on('change', 'input[name=deviceId]', function (e) {
          if ($("input[name=deviceId]:checked").length > 0) {
            devicePairing.$instAdminUnpairSelectedBtn.prop("disabled", false);
          } else {
            devicePairing.$instAdminUnpairSelectedBtn.prop("disabled", true);
          }
        });
        $body.on('click', '#instAdminUnpairSelected', function (e) {
          e.preventDefault();
          devicePairing.selectedDevicesArray = [];
          devicePairing.$deviceSelectedList.empty();
          devicePairing.$pairedDevicesTable.find("input[name='deviceId']:checked").each(function () {
            devicePairing.selectedDevicesArray.push($(this).attr('id'));
            devicePairing.$deviceSelectedList.append("<li>" + $(this).val() + "</li>");
          });
        });
        $body.on('click', '#instAdminUnpairAll', function (e) {
          e.preventDefault();
          devicePairing.selectedDevicesArray = [];
          devicePairing.$deviceSelectedList.empty();
          devicePairing.$pairedDevicesTable.find("input[name='deviceId']").each(function () {
            devicePairing.selectedDevicesArray.push($(this).attr('id'));
            devicePairing.$deviceSelectedList.append("<li>" + $(this).val() + "</li>");
          });
        });
        $body.on('click', '#ConfirmUnpairDevices', function (e) {
          e.preventDefault();

          if (devicePairing.isInstitutionMode) {
            $.get("/pb/widgets/ux3/DevicePairingManagementController/unpairSelected?widgetId=" + devicePairing.widgetId + "&pbContext=" + devicePairing.pbContext, {
              serviceName: $(".serviceNameHidden").text(),
              userEmail: $(".userEmailHidden").text(),
              devices: JSON.stringify(devicePairing.selectedDevicesArray),
              antiForgeryToken: $(".antiForgeryToken").text()
            }).done(function (html) {
              devicePairing.on.fillPairedDevicesTable(html);
            }).fail(function (jqXHR, textStatus, errorThrown) {
              devicePairing.on.displayErrorDialog("error occure on the server : " + errorThrown);
            });
          } else {
            $.get("/pb/widgets/ux3/DevicePairingController/unpairSelected?widgetId=" + devicePairing.widgetId + "&pbContext=" + devicePairing.pbContext, {
              devices: JSON.stringify(devicePairing.selectedDevicesArray)
            }).done(function (html) {
              devicePairing.on.fillPairedDevicesTable(html);
            }).fail(function (jqXHR, textStatus, errorThrown) {
              devicePairing.on.displayErrorDialog("error occure on the server : " + errorThrown);
            });
          }

          devicePairing.selectedDevicesArray = [];
          devicePairing.$unpairDialogForm.modal('toggle');
        });
      },
      additionalControl: function () {},
      on: {
        fillPairedDevicesTable: function (html) {
          devicePairing.$pairedDevicesTable.find("tbody").html(html);
          devicePairing.$pairedDevicesTable.trigger("update");
          devicePairing.$instAdminUnpairSelectedBtn.prop("disabled", true);

          if (html.indexOf("device-pairing__row") >= 0) {
            devicePairing.$pairedDevicesTable.removeClass('hidden');
            devicePairing.$unpairButtonsPanel.removeClass('hidden');
            devicePairing.$noPairedDevicesResult.addClass('hidden');
          } else {
            devicePairing.$pairedDevicesTable.addClass('hidden');
            devicePairing.$unpairButtonsPanel.addClass('hidden');
            devicePairing.$noPairedDevicesResult.removeClass('hidden');
          }
        },
        displayErrorDialog: function (message) {
          $("#devicePairingError").find(".message").html(message);
          $("#devicePairingError").modal('toggle');
        }
      },
      check: {
        isValidEmail: function (value) {
          var emailPattern = /^\b[A-Z0-9._%-]+@[A-Z0-9.-]+\.[A-Z]{2,4}\b$/i;

          if (!emailPattern.test(value)) {
            return false;
          }

          return true;
        }
      }
    };
    UX.devicePairing = devicePairing;
  })();

  (function () {
    var $window = $(window),
        $body = $('body');
    var pairingManagment = {
      widgetId: $("#pairingManagmentWidgetId").text(),
      pbContext: encodeURI($("[name='pbContext']").attr("content")),
      $pairedEmailsTable: $(".pairedEmailsTable"),
      emailsTableRow: ".pairing-management__row",
      paginationContainer: '.pairing-management__pagination',
      clientPagination: null,
      init: function () {
        pairingManagment.initialization();
        pairingManagment.addtionalInitialization();
        pairingManagment.control();
      },
      initialization: function () {
        pairingManagment.on.setDatePickers();

        if (!$(".pairing-management-demo").length) {
          pairingManagment.on.refreshPairedDevices();
        }

        pairingManagment.clientPagination = jQuery.extend(true, {}, UX.clientPagination);
        pairingManagment.clientPagination.set.containerName(pairingManagment.paginationContainer);
        pairingManagment.clientPagination.set.tableRowName(pairingManagment.emailsTableRow);
        pairingManagment.clientPagination.init();
      },
      addtionalInitialization: function () {},
      control: function () {
        $body.on('click', '.dateFilter .calendar', function (e) {
          e.preventDefault();
          $(this).siblings('.datepicker').datepicker('show');
        });
        $body.on('click', pairingManagment.paginationContainer + ' .prev, ' + pairingManagment.paginationContainer + ' .next, ' + pairingManagment.paginationContainer + ' .page', function (e) {
          e.preventDefault();
          $("input[name=userEmail]").prop("checked", false);
          pairingManagment.on.disableActionButtons();
        });
        $body.on('click', '#refreshButton', function (e) {
          e.preventDefault();
          pairingManagment.on.refreshPairedDevices();
        });
        $body.on('click', '#addExternalEmailButton', function (e) {
          e.preventDefault();
          pairingManagment.clear.dialog($("#externalEmailDialogForm"));
        });
        $body.on('click', '#confirmAddExternalEmail', function (e) {
          e.preventDefault();
          pairingManagment.on.addExternalEmail();
        });
        $body.on('click', '#confirmExtendReinstate', function (e) {
          e.preventDefault();
          pairingManagment.on.extendReinstateEmail();
        });
        $body.on('click', '#confirmRevokeAccess', function (e) {
          e.preventDefault();
          pairingManagment.on.revokeEmail();
        });
        $("#viewDetailButton").click(function () {
          var userEmail = $("input[name=userEmail]:checked").attr("id");
          $(this).closest("form").append("<input type='hidden' name='userEmail' value='" + userEmail + "'/>");
        });
        $body.on('click', '#extendReinstateButton', function (e) {
          e.preventDefault();
          pairingManagment.clear.dialog($("#extendReinstateAccessDialogForm"));
          var selectedEmail = $("input[name=userEmail]:checked").val();
          $("#extendEmail").val(selectedEmail);
        });
        $body.on('click', '#revokeButton', function (e) {
          e.preventDefault();
          pairingManagment.clear.dialog($("#revokeAccessDialogForm"));
          var selectedEmail = $("input[name=userEmail]:checked").val();
          $("#revokeAccessEmail").val(selectedEmail);
        });
        $body.on('change', 'input[name=userEmail]', function (e) {
          $("#extendReinstateButton").prop("disabled", false);
          $("#revokeButton").prop("disabled", false);
          $("#viewDetailButton").prop("disabled", false);
          $('.pairing-management__actions .withSelected').removeClass('disabled');
        });
      },
      check: {
        expirationDays: function (expirationDaysField) {
          // validate expiration days to ensure it is an integer
          var intRegex = /^\d+$/;

          if (!intRegex.test(expirationDaysField.val())) {
            expirationDaysField.addClass("ui-state-error");
            return false;
          }

          return true;
        },
        reason: function (reasonField) {
          // ensure reason field has text
          if (!reasonField.val()) {
            reasonField.addClass("ui-state-error");
            return false;
          }

          return true;
        },
        email: function (emailField) {
          //ensure email field isn't empty
          if (!emailField.val() || $.trim($(emailField).val()).length == 0) {
            emailField.addClass("ui-state-error");
            return false;
          }

          return true;
        }
      },
      clear: {
        dialog: function ($dialog) {
          $dialog.find('input').removeClass('ui-state-error').val('');
          $dialog.find('.expdays').val('180');
        },
        filters: function () {
          // reset email filter
          $("input[name=emailFilter]").prop("checked", function () {
            return this.getAttribute("checked") == "checked";
          }); // reset permission filter

          $("input[name=permissionFilter]").prop("checked", function () {
            return this.getAttribute("checked") == "checked";
          }); // reset the text input filters

          $("input[name=emailAddress]").val("");
          $("input[name=name]").val("");
          pairingManagment.on.setDatePickers();
        }
      },
      on: {
        setDatePickers: function () {
          var fromDateElement = $("#fromDate");
          var toDateElement = $("#toDate");
          fromDateElement.datepicker({
            defaultDate: "-1w",
            numberOfMonths: 1,
            onClose: function (selectedDate) {
              $("#toDate").datepicker("option", "minDate", selectedDate);
            }
          });
          fromDateElement.datepicker("setDate", "-180d");
          toDateElement.datepicker({
            defaultDate: "+0",
            numberOfMonths: 1,
            onClose: function (selectedDate) {
              $("#fromDate").datepicker("option", "maxDate", selectedDate);
            }
          });
          toDateElement.datepicker("setDate", "+1d");
        },
        addExternalEmail: function () {
          var addExtEmailEmailField = $("#addExternalEmail");
          var addExtEmailExpDaysField = $("#addExternalEmailExp");
          var addExtEmailReasonField = $("#addExternalEmailReason");
          var valid = true;
          valid = valid && pairingManagment.check.email(addExtEmailEmailField);
          valid = valid && pairingManagment.check.expirationDays(addExtEmailExpDaysField);
          valid = valid && pairingManagment.check.reason(addExtEmailReasonField);

          if (valid) {
            $.get("/pb/widgets/ux3/DevicePairingManagementController/addExternalEmail?widgetId=" + pairingManagment.widgetId + "&pbContext=" + pairingManagment.pbContext, {
              serviceName: $(".serviceNameHidden").text(),
              email: addExtEmailEmailField.val(),
              daysToExpiration: addExtEmailExpDaysField.val(),
              reason: addExtEmailReasonField.val(),
              antiForgeryToken: $(".antiForgeryToken").text()
            }).done(function (html) {
              // check if the response html is not an error page
              if (html.indexOf("externalEmailError") == -1) {
                pairingManagment.$pairedEmailsTable.find("tbody").html(html);
                pairingManagment.$pairedEmailsTable.trigger("update");
                pairingManagment.on.disableActionButtons();
                pairingManagment.clientPagination.buildPagination();
                pairingManagment.clear.filters();
              } else {
                // error trying to add external email
                pairingManagment.on.displayErrorDialog(html);
              }
            }).fail(function (jqXHR, textStatus, errorThrown) {
              pairingManagment.on.displayErrorDialog("error occure on the server : " + errorThrown);
            });
            $("#externalEmailDialogForm").modal("toggle");
          }
        },
        extendReinstateEmail: function () {
          var extendReinstateEmailField = $("#extendEmail");
          var extendReinstateExpDaysField = $("#extendEmailExp");
          var extendReinstateReasonField = $("#extendEmailReason");
          var valid = true;
          valid = valid && pairingManagment.check.expirationDays(extendReinstateExpDaysField);
          valid = valid && pairingManagment.check.reason(extendReinstateReasonField);
          var selectedEmail = extendReinstateEmailField.val();

          if (valid) {
            $.get("/pb/widgets/ux3/DevicePairingManagementController/extendReinstateEmail?widgetId=" + pairingManagment.widgetId + "&pbContext=" + pairingManagment.pbContext, {
              serviceName: $(".serviceNameHidden").text(),
              extendReinstateEmail: selectedEmail,
              daysToExpiration: extendReinstateExpDaysField.val(),
              reason: extendReinstateReasonField.val(),
              // need to send the current filter options as well, so that we maintain the same filters
              emailFilter: $('input[name=emailFilter]:checked').attr("id"),
              permissionFilter: $('input[name=permissionFilter]:checked').attr("id"),
              emailAddress: $('input[name=emailAddress]').val(),
              name: $('input[name=name]').val(),
              fromDate: $('input[name=fromDate]').val(),
              toDate: $('input[name=toDate]').val(),
              antiForgeryToken: $(".antiForgeryToken").text()
            }).done(function (html) {
              pairingManagment.$pairedEmailsTable.find("tbody").html(html);
              pairingManagment.$pairedEmailsTable.trigger("update");
              pairingManagment.clientPagination.buildPagination();
              $("input[value=" + "'" + selectedEmail + "'" + "]").prop("checked", true);
            }).fail(function (jqXHR, textStatus, errorThrown) {
              pairingManagment.on.displayErrorDialog("error occure on the server : " + errorThrown);
            });
            $("#extendReinstateAccessDialogForm").modal("toggle");
          }
        },
        revokeEmail: function () {
          var revokeEmailField = $("#revokeAccessEmail");
          var revokeReasonField = $("#revokeAccessReason");
          var selectedEmail = revokeEmailField.val();
          $.get("/pb/widgets/ux3/DevicePairingManagementController/revokeAccess?widgetId=" + pairingManagment.widgetId + "&pbContext=" + pairingManagment.pbContext, {
            serviceName: $(".serviceNameHidden").text(),
            revokeEmail: selectedEmail,
            reason: revokeReasonField.val(),
            // need to send the current filter options as well, so that we maintain the same filters
            emailFilter: $('input[name=emailFilter]:checked').attr("id"),
            permissionFilter: $('input[name=permissionFilter]:checked').attr("id"),
            emailAddress: $('input[name=emailAddress]').val(),
            name: $('input[name=name]').val(),
            fromDate: $('input[name=fromDate]').val(),
            toDate: $('input[name=toDate]').val(),
            antiForgeryToken: $(".antiForgeryToken").text()
          }).done(function (html) {
            pairingManagment.$pairedEmailsTable.find("tbody").html(html);
            pairingManagment.$pairedEmailsTable.trigger("update");
            pairingManagment.clientPagination.buildPagination();
            $("input[value=" + "'" + selectedEmail + "'" + "]").prop("checked", true);
          }).fail(function (jqXHR, textStatus, errorThrown) {
            pairingManagment.on.displayErrorDialog("error occure on the server : " + errorThrown);
          });
          $("#revokeAccessDialogForm").modal("toggle");
        },
        refreshPairedDevices: function () {
          $.get("/pb/widgets/ux3/DevicePairingManagementController/institutionPairedDevices?widgetId=" + pairingManagment.widgetId + "&pbContext=" + pairingManagment.pbContext, {
            serviceName: $(".serviceNameHidden").text(),
            emailFilter: $('input[name=emailFilter]:checked').attr("id"),
            permissionFilter: $('input[name=permissionFilter]:checked').attr("id"),
            emailAddress: $('input[name=emailAddress]').val(),
            name: $('input[name=name]').val(),
            fromDate: $('input[name=fromDate]').val(),
            toDate: $('input[name=toDate]').val()
          }).done(function (html) {
            pairingManagment.$pairedEmailsTable.find("tbody").html(html);
            pairingManagment.$pairedEmailsTable.trigger("update");
            pairingManagment.on.disableActionButtons();
            pairingManagment.clientPagination.buildPagination();
          }).fail(function (jqXHR, textStatus, errorThrown) {
            pairingManagment.on.displayErrorDialog("error occure on the server : " + errorThrown);
          });
        },
        disableActionButtons: function () {
          $("#extendReinstateButton").prop("disabled", true);
          $("#revokeButton").prop("disabled", true);
          $("#viewDetailButton").prop("disabled", true);
          $('.pairing-management__actions .withSelected').addClass('disabled');
        },
        displayErrorDialog: function (message) {
          $("#externalEmailError").find(".message").html(message);
          $("#externalEmailError").modal('toggle');
        }
      }
    };
    UX.pairingManagment = pairingManagment; // add to global namespace
  })();

  (function () {
    var $body = $('body');
    var pdActionBar = {
      actionBarSelector: ".pd-action-bar",
      defaultCommentsSelector: ".js-defaultComments",
      btnSubmit: "[data-action]",
      btnRedirect: "[data-redirect]",
      confirmationHTML: "<div class=\"toast toast--success\"><i aria-hidden=\"true\" class=\"icon-check\"></i><div class=\"toast__text\">You have successfully submitted the article</div> </div>",
      validReferrer: "/action/showDraft",
      init: function () {
        pdActionBar.controller();
        pdActionBar.on.build();

        if (window.performance && performance.navigation.type == 0) {
          var documentReferrer = document.referrer;

          if (documentReferrer) {
            var urlDocumentReferrer = new URL(documentReferrer);
            var urlDocumentLocation = new URL(document.location);

            if (urlDocumentLocation.hash == "#submission-successful" && urlDocumentReferrer.pathname == pdActionBar.validReferrer) {
              this.showConfirmation(urlDocumentLocation.pathname);
            }
          }
        }
      },
      controller: function () {
        $body.on('click', pdActionBar.btnSubmit, function (e) {
          e.preventDefault();
          var target = e.target;
          var $target = $(target);

          if (target.tagName === "BUTTON") {
            if ($target.is(".btn--reject") && !pdActionBar.validateRejectReasons()) {
              return false;
            }

            var $form = $(pdActionBar.actionBarSelector).find("form");
            $form.attr("action", $target.attr("data-action"));
            $form.submit();
          }
        });
        $body.on('click', pdActionBar.btnRedirect, function (e) {
          e.preventDefault();
          var target = e.target;

          if (target.tagName === "BUTTON") {
            window.location = $(target).attr("data-redirect");
          }
        });
        var $defaultComments = $(pdActionBar.defaultCommentsSelector);

        if ($defaultComments.length) {
          var target = $defaultComments.data("comment-target");
          var $target = $(target);
          $defaultComments.on('change', "[type='radio']", function (e) {
            // enable button
            var $submitCommentBtn = $defaultComments.closest('.modal__dialog').find(pdActionBar.btnSubmit);
            $submitCommentBtn.prop('disabled', !$defaultComments.find(':checked').length);
            $target.prop('disabled', !$defaultComments.find(':checked').length);
            var text = $(this).data("comment-default");
            var updated = $(this).data('comment-changed');

            if (updated != false) {
              $target.val(updated);
            } else {
              $target.val(text);
            }

            $target.focus();
          });
          $target.on('keyup', function () {
            var $selected = $defaultComments.find("[type='radio']:checked");
            var newVal = $(this).val();
            $selected.data('comment-changed', newVal);
            $selected.attr('data-comment-changed', newVal);
          });
        }
      },
      on: {
        build: function () {
          //initialize jqueru ui autocomplete
          var $autocomplete = $(".ux-modal-container").find(".ux3-autocomplete");
          $autocomplete.autocomplete({
            source: function (request, response) {
              $.ajax({
                url: $autocomplete.data("url"),
                dataType: "json",
                data: {
                  query: request.term
                },
                success: function (data) {
                  response($.map(data, function (el) {
                    return {
                      label: el.label,
                      value: el.label,
                      id: el.value
                    };
                  }));
                }
              });
            },
            open: function () {
              $(".ui-menu.ui-autocomplete").width($(this).innerWidth());
            },
            minLength: 2,
            select: function (event, ui) {
              $("[name='submitted-to']").val(ui.item.id);
            }
          });
        }
      },
      showConfirmation: function (redirectionUrl) {
        var el = $(".pdActionBar");
        var delay = 3000;

        if (el) {
          el.prepend(pdActionBar.confirmationHTML);
          var timeoutID = window.setTimeout(function () {
            $(".toast").fadeOut();
            document.location = redirectionUrl;
          }, delay);
        }
      },

      validateRejectReasons() {
        const $defaultComments = $(pdActionBar.defaultCommentsSelector),
              $target = $($defaultComments.data("comment-target")),
              $defaultCommentsError = $defaultComments.closest('.input-group').find('.error'),
              $targetError = $target.closest('.input-group').find('.error');
        let pass = true;
        $defaultCommentsError.addClass('hidden');
        $targetError.addClass('hidden');
        $target.removeClass('not-valid');

        if (!$defaultComments.find("[name='rejection-reason']:checked").length) {
          $defaultCommentsError.removeClass('hidden');
          pass = false;
        }

        if ($target.val().trim() === "") {
          $target.addClass('not-valid');
          $targetError.removeClass('hidden');
          pass = false;
        }

        return pass;
      }

    };
    UX.pdActionBar = pdActionBar; // add to global namespace
  })();

  (function () {
    var $body = $('body');
    var submissionAuthors = {
      list: [],
      affiliationsValues: '.td-affiliations-val',
      $affiliationsInputTemplate: $('.affiliationsInputTemplate'),
      affilationMagicSuggest: null,
      $affiliationsAjaxLink: $('#affiliationAjaxLink'),
      authorAjaxLink: '.authorAjaxLink',
      $container: $('.submission-authors'),
      $affiliationsTypes: $('.affiliations-types'),
      affilationsSplitter: '|#|',
      errText: 'Field is missing',
      errEmailText: 'Please enter a valid email address',
      classes: {
        notValid: 'not-valid'
      },
      selectors: {
        noValid: '.not-valid',
        error: '.error'
      },
      init: function () {
        this.modal.init('#authors-modal');
        this.table.init('.authors__table', '.submission-authors .rowTemplate tr');
        this.controller();
      },
      saveAuthorsToArray: function () {
        // Save all Authors into array for later use
        submissionAuthors.list = [];
        this.table.rows().forEach(row => {
          const fullName = $(row).find(`${this.table.tds.name} .td-text`).text() + ' ' + $(row).find(`${this.table.tds.lastName} .td-text`).text();
          submissionAuthors.list.push(fullName);
        });

        if (UX.funders.fillAuthors) {
          UX.funders.fillAuthors();
        }

        $(document).trigger('autosave');
      },
      controller: function () {
        $body.on('click', submissionAuthors.authorAjaxLink, submissionAuthors.handlers.getAuthor);
        $body.on('click', '#saveAuthor', submissionAuthors.handlers.authorSave);
        $body.on('click', '#addAuthor', submissionAuthors.handlers.authorAdd);
        $body.on('click', '.submission-authors .delete', submissionAuthors.handlers.authorDelete);
        $body.on('click', '.submission-authors .edit', submissionAuthors.handlers.authorEdit);
        this.table.tableElem.addEventListener('click', submissionAuthors.handlers.toggleCorresponding);
        submissionAuthors.nextController();
      },
      nextController: function () {},

      /**
       * fixme: THIS HAS BEEN DISABLED DUE TO LIT-232173 AND IT MAY BE RETURNED SOMEDAY
       */
      saveAffiliations: function () {
        var affiliationsValue = '';
        var affiliationsText = '';
        var $affiliationsValue = $('[name="author-affilation[]"]');
        var $affiliationsText = $('#author-affilation .ms-sel-item');
        var affiliationsHiddenInputs = '';
        var affiliationsTypes = submissionAuthors.$affiliationsTypes.text().split(',');
        $affiliationsValue.each(function (index) {
          var affValue = $(this).val();

          if ($(this).val() == $($affiliationsText[index]).text()) {
            affValue = 'text';
          } else if (affiliationsTypes[index] !== '') {
            if (affiliationsTypes[index] === 'text') affValue = 'text';else {
              var affType = submissionAuthors.getAffiliationsType(affiliationsTypes[index], $(this).val());
              affValue = affType + '|' + $(this).val();
            }
          } else {
            affValue = 'isni|' + $(this).val();
          }

          affValue += '|' + $($affiliationsText[index]).text();
          affiliationsValue += affValue + submissionAuthors.affilationsSplitter;
          affiliationsHiddenInputs += submissionAuthors.$affiliationsInputTemplate.html().replace(/\{\{0\}\}/gi, affValue).replace(/\{\{1\}\}/gi, rowNum).replace(/fakedinput/gi, 'input');
        });
        $affiliationsText.each(function (index) {
          affiliationsText += $(this).text();
          if (index != $affiliationsText.length - 1) affiliationsText += ', ';
        });
        if (affiliationsValue != '') affiliationsValue = affiliationsValue.substring(0, affiliationsValue.lastIndexOf(submissionAuthors.affilationsSplitter));
      },
      handlers: {
        getAuthor: function (e) {
          e.preventDefault();
          submissionAuthors.modal.validation_message = '';

          if (submissionAuthors.modal.$orcid.val() === '') {
            submissionAuthors.modal.validation_message = 'Please enter ORCID number';
          } else {
            var url = $(submissionAuthors.authorAjaxLink).attr('href') + '?orcid=' + submissionAuthors.modal.$orcid.val();
            $.ajax({
              type: 'GET',
              url: url,
              success: function (data) {
                if (data) {
                  var emptyRes = Object.keys(data).length === 0 && data.constructor === Object;

                  if (emptyRes) {
                    submissionAuthors.modal.validation_message = 'No results from ORCID server';
                  }

                  if (data.message && data.message.text) {
                    submissionAuthors.modal.validation_message = data.message.text;
                  } //fill inputs with json data


                  let aff_names = [];

                  if (data.author) {
                    if (data.author.affiliations && data.author.affiliations.length > 0) {
                      data.author.affiliations.forEach(function (item) {
                        if (item.name) aff_names.push(item.name);
                      });
                    }

                    submissionAuthors.modal.fields = {
                      'name': data.author.firstName,
                      'lastName': data.author.lastName,
                      'affiliations': aff_names.join(','),
                      'email': data.author.email
                    };
                  }
                } else {
                  submissionAuthors.modal.validation_message = 'Error occurred when check ORCID in the server';
                }
              },
              error: function (e) {
                submissionAuthors.modal.validation_message = 'Error occurred when check ORCID in the server';
              }
            });
          }
        },
        toggleCorresponding: function (e) {
          if (!e.target.matches(".corresponding-toggle") && !e.target.closest(".corresponding-toggle")) return;
          e.preventDefault();
          const new_row = e.target.closest('.author__row');
          submissionAuthors.table.changeCorresponding(new_row);
          $(document).trigger('autosave');
        },
        authorAdd: function (e) {
          e.preventDefault();
          submissionAuthors.on.beforeValidate();
          submissionAuthors.$affiliationsTypes.text('');
          submissionAuthors.modal.clear();
          submissionAuthors.modal.title = 'Add Author';
          submissionAuthors.modal.mode = 'add';
          submissionAuthors.modal.row_number = submissionAuthors.table.rows(true).length;
          submissionAuthors.modal.toggle();
        },
        authorSave: function (e) {
          e.preventDefault();
          submissionAuthors.on.beforeValidate();

          if (submissionAuthors.on.validate()) {
            var rowNum = submissionAuthors.modal.row_number;

            if (submissionAuthors.modal.mode === 'add') {
              //add new row
              submissionAuthors.table.add_row(rowNum, submissionAuthors.modal.fields);
            } else {
              //edit row
              submissionAuthors.table.update_row(rowNum, submissionAuthors.modal.fields);
            }

            submissionAuthors.modal.toggle(true);
            submissionAuthors.saveAuthorsToArray();
          }
        },
        authorDelete: function (e) {
          e.preventDefault();
          let authorRow = e.target.closest('tr');
          submissionAuthors.table.destroy(authorRow);
          submissionAuthors.saveAuthorsToArray();
        },
        authorEdit: function (e) {
          e.preventDefault();
          let $this = $(e.target);
          submissionAuthors.on.beforeValidate();
          let rowNumber = $this.closest('tr').data('row-num');
          submissionAuthors.modal.mode = 'edit';
          submissionAuthors.modal.row_number = rowNumber;
          submissionAuthors.modal.validation_message = ' ';
          submissionAuthors.modal.fields = submissionAuthors.table.extract_values(e.target.closest("tr"));
          submissionAuthors.modal.title = 'Edit Author';
          submissionAuthors.modal.toggle();
        }
      },
      getAffiliationsType: function (text, val) {
        var affArray = text.split(',');
        var type = '';
        $.each(affArray, function (i, arrayVal) {
          if (arrayVal.indexOf(val) >= 0) {
            type = arrayVal.replace(val + '=', '');
            return false;
          }
        });
        return type;
      },
      getAffiliationsSelectedItems: function (values) {
        var selectedValues = [];

        if (values) {
          var valuesArr = values.split(submissionAuthors.affilationsSplitter);
          $.each(valuesArr, function (i, arrayVal) {
            var itemvals = arrayVal.split('|');

            if (itemvals[0] == 'text') {
              selectedValues.push({
                label: itemvals[1],
                value: itemvals[1]
              });
            } else {
              selectedValues.push({
                label: itemvals[2],
                value: itemvals[1]
              });
            }
          });
        }

        return selectedValues;
      },
      getAffiliationsTypes: function ($row) {
        var $affiValus = $row.find('.affiliations__hidden-inputs input');
        var types = '';
        $affiValus.each(function (index) {
          if ($(this).val().indexOf('|') >= 0) {
            if ($(this).val().split('|')[0] != 'text') {
              types += $(this).val().split('|')[1] + '=' + $(this).val().split('|')[0] + ',';
            }
          }
        });
        if (types !== '') types = types.slice(0, -1);
        return types;
      },
      on: {
        doSuggest: function () {
          var affilationMagicSuggest = submissionAuthors.modal.find('.aff-magicsuggest');
          submissionAuthors.affilationMagicSuggest = affilationMagicSuggest.magicSuggest({
            data: submissionAuthors.$affiliationsAjaxLink.val(),
            method: 'GET',
            valueField: 'value',
            autoSelect: false,
            allowFreeEntries: false,
            mode: 'remote',
            displayField: 'label',
            hideTrigger: 'true',
            useCommaKey: false
          });
        },
        beforeValidate: function () {
          submissionAuthors.modal.find(submissionAuthors.selectors.error).text('');
          submissionAuthors.modal.find(submissionAuthors.selectors.notValid).removeClass(submissionAuthors.classes.notValid);
        },
        validate: function () {
          var re = /[A-Z0-9._%+-]+@[A-Z0-9.-]+.[A-Z]{2,4}/igm;
          var result = true;
          submissionAuthors.modal.find(submissionAuthors.selectors.error).text('');
          submissionAuthors.modal.find(submissionAuthors.selectors.notValid).removeClass(submissionAuthors.classes.notValid); // required fields

          const requiredFields = ['name', 'lastName', 'affiliations', 'email'];
          requiredFields.forEach(item => {
            const $field = submissionAuthors.modal[`$${item}`],
                  $error = submissionAuthors.modal[`$${item}_err`];

            if ($field.val() === '') {
              submissionAuthors.showError($field, $error, submissionAuthors.errText);
              result = false;
            }

            if (item === 'email' && !re.test($field.val())) {
              submissionAuthors.showError($field, $error, submissionAuthors.errEmailText);
              result = false;
            }
          });
          return result;
        }
      },

      showError($field, $error, message) {
        $field.addClass(this.classes.notValid);
        $error.text(message);
      },

      table: {
        tableElem: null,
        templateRow: null,
        tds: {
          orcid: '.author-orcid-td',
          name: '.author-name-td',
          lastName: '.author-surname-td',
          affiliations: '.author-affiliation-td',
          email: '.author-email-td'
        },

        init(table_selector, row_template) {
          this.tableElem = document.querySelector(table_selector);
          this.templateRow = document.querySelector(row_template);
        },

        add_row(row_num, values) {
          let row_html = this.templateRow.outerHTML;
          row_html = row_html.replace(/\{\{0\}\}/gi, values.orcid).replace(/\{\{1\}\}/gi, values.name).replace(/\{\{2\}\}/gi, values.lastName).replace(/\{\{3\}\}/gi, values.affiliations).replace(/\{\{4\}\}/gi, values.email).replace(/\{\{5\}\}/gi, row_num).replace(/fakedinput/gi, "input");
          this.tableElem.querySelector("tbody").insertAdjacentHTML('beforeend', row_html);

          if (Array.isArray(values.affiliations)) {
            this.add_affiliations_array(values.affiliations, row_num);
          }
        },

        /**
         * @param row_num
         * @return {HTMLElement}
         */
        get_row(row_num) {
          return this.tableElem.querySelector(`tr[data-row-num="${row_num}"]`);
        },

        update_row(row_num, values) {
          const row = this.get_row(row_num);

          for (let tdsKey in this.tds) {
            if (!this.tds.hasOwnProperty(tdsKey) || !values.hasOwnProperty(tdsKey)) continue;
            const td = row.querySelector(this.tds[tdsKey]);
            const input = td.querySelector("input:not(hidden)");
            td.querySelector(".td-text").textContent = values[tdsKey]; // if the affiliations are an array add multiple hidden input

            if (tdsKey === "affiliations" && Array.isArray(values[tdsKey])) {
              this.add_affiliations_array(values[tdsKey], row_num);
            } else {
              input.value = values[tdsKey];
            }
          }

          row.classList.remove(submissionAuthors.classes.notValid);
          row.closest('.submission-authors').classList.remove(submissionAuthors.classes.notValid);
        },

        add_affiliations_array(values, row_num) {
          const parentNode = this.get_row(row_num).querySelector(".affiliations__hidden-inputs");
          parentNode.innerHTML = "";
          const input = document.createElement("input");
          input.type = "hidden";
          input.name = `authors[${row_num}].affiliations[]`;

          for (let i = 0; i < values.length; i++) {
            const clonedInput = input.cloneNode(true);
            clonedInput.value = values[i];
            parentNode.append(clonedInput);
          }

          input.remove();
        },

        destroy(row) {
          row.classList.add("deleted", "hidden");
          row.innerHTML = "";
        },

        extract_values(row) {
          const values = {};

          for (let tdsKey in this.tds) {
            if (!this.tds.hasOwnProperty(tdsKey)) continue;
            values[tdsKey] = row.querySelector(`${this.tds[tdsKey]} .td-text`).html();
          }

          return values;
        },

        rows(withDeleted) {
          let selector = "tbody tr";
          if (!withDeleted) selector += ":not(.deleted)";
          return [...this.tableElem.querySelectorAll(selector)];
        },

        changeCorresponding: function (newCorresponding) {
          // toggle old corresponding off
          const oldCorresponding = this.tableElem.querySelector(".author__corresponding");

          if (oldCorresponding) {
            oldCorresponding.querySelector("[name*='corresponding']").value = "false";
            oldCorresponding.classList.remove("author__corresponding");
            const deleteBtn = oldCorresponding.querySelector(".btn--action.delete");
            if (deleteBtn) deleteBtn.classList.remove("hidden", "disabled");
          }

          newCorresponding.querySelector("[name*='corresponding']").value = "true";
          newCorresponding.classList.add("author__corresponding");
          const deleteBtn = newCorresponding.querySelector(".btn--action.delete");
          if (deleteBtn) deleteBtn.classList.add("hidden", "disabled");
        }
      },
      modal: {
        $modal: null,
        $orcid: null,
        $orcid_err: null,
        $name: null,
        $name_err: null,
        $lastName: null,
        $lastName_err: null,
        $affiliations: null,
        $affiliations_err: null,
        $email: null,
        $email_err: null,
        $modalValidationMessage: null,
        $modalTitle: null,

        init(modal_selector) {
          this.$modal = $(modal_selector);
          this.$orcid = this.$modal.find('#author-orcid');
          this.$orcid_err = this.$modal.find('#author-orcid + .error');
          this.$name = this.$modal.find('#author-name');
          this.$name_err = this.$modal.find('#author-name + .error');
          this.$lastName = this.$modal.find('#author-last-name');
          this.$lastName_err = this.$modal.find('#author-last-name + .error');
          this.$affiliations = this.$modal.find('#author-affilation');
          this.$affiliations_err = this.$modal.find('#author-affilation + .error');
          this.$email = this.$modal.find('#author-email');
          this.$email_err = this.$modal.find('#author-email + .error');
          this.$modalValidationMessage = this.$modal.find('.modal-validation-message');
          this.$modalTitle = this.$modal.find('#authors-modal .modal__header .modal__title');
        },

        find(selector) {
          return this.$modal.find(selector);
        },

        set mode(mode) {
          this.find('.mode').val(mode);
        },

        /**
         * @return {string}
         */
        get mode() {
          return this.find('.mode').val();
        },

        set row_number(row_number) {
          this.find('.row-num').val(row_number);
        },

        /**
         * @return {number}
         */
        get row_number() {
          return this.find('.row-num').val();
        },

        set title(title) {
          this.$modalTitle.text(title);
        },

        set validation_message(message) {
          if (message === "") {
            this.$modalValidationMessage.hide();
          } else {
            this.$modalValidationMessage.show();
          }

          this.$modalValidationMessage.text(message);
        },

        set_fields(values) {
          if (typeof values['orcid'] !== 'undefined') this.$orcid.val(values['orcid']);
          if (typeof values['name'] !== 'undefined') this.$name.val(values['name']);
          if (typeof values['lastName'] !== 'undefined') this.$lastName.val(values['lastName']);
          if (typeof values['affiliations'] !== 'undefined') this.$affiliations.val(values['affiliations']);
          if (typeof values['email'] !== 'undefined') this.$email.val(values['email']);
        },

        get_fields() {
          return {
            'orcid': this.$orcid.val(),
            'name': this.$name.val(),
            'lastName': this.$lastName.val(),
            'affiliations': this.$affiliations.val(),
            'email': this.$email.val()
          };
        },

        set fields(values) {
          this.set_fields(values);
        },

        get fields() {
          return this.get_fields();
        },

        clear() {
          this.$orcid.val('');
          this.$name.val('');
          this.$lastName.val('');
          this.$affiliations.val('');
          this.$email.val('');
          this.validation_message = '';
        },

        toggle(close) {
          if (close) this.$modal.modal('hide');else this.$modal.modal({
            backdrop: 'static',
            keyboard: false
          }, 'toggle');
        }

      }
    };
    UX.submissionAuthors = submissionAuthors; // add to global namespace
  })();

  /**
   * Polyfill to add support to NodeList forEach in IE
   *
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach#Polyfill}
   */
  if (window.NodeList && !NodeList.prototype.forEach) {
    NodeList.prototype.forEach = Array.prototype.forEach;
  }

  (function () {
    var $body = $('body');
    var basicMetadata = {
      posterMeetingName: null,
      typeName: null,
      container: null,
      $additionalInformation: null,
      $submittedInput: null,
      $dateInput: null,
      init: function () {
        this.posterMeetingName = '.basic-metadata__meeting-name';
        this.$additionalInformation = $('.meeting-additional-information');
        this.typeName = '[name="basic-metadata.type"]'; // this.posterMeetingDate = ".basic-metadata__meeting-date";

        this.container = '.basic-metadata';
        this.$submittedInput = $('[name="basic-metadata.preprint-submitted-to"]');
        this.$dateInput = $('input.datepicker');
        basicMetadata.on.build();
        basicMetadata.on.alignDropZones();

        if ($(basicMetadata.posterMeetingName).length > 0) {
          basicMetadata.controller();
          basicMetadata.on.handleAdditional();
        }
      },
      on: {
        build: function () {
          basicMetadata.autocomplete.submittedTo();
          basicMetadata.autocomplete.meetings();
        },
        handleAdditional: function (item) {
          $('.meeting-additional-information__location').text('');
          $('.meeting-additional-information__date').text('');

          if (item) {
            $('.meeting-additional-information__location').text(item.location);
            $('.meeting-additional-information__date').text(item.date);
            basicMetadata.$additionalInformation.removeClass('hidden');
          } else {
            basicMetadata.$additionalInformation.addClass('hidden');
          }
        },
        alignDropZones: function () {
          var hasDropZones = document.querySelectorAll('.has-extra-dropzone');
          hasDropZones.forEach(function (item) {
            var textarea = item.querySelector('textarea');
            var dropZone = item.querySelector('.extra-dropzone');
            if (!textarea || !dropZone) return;

            var fixItemPadding = function () {
              if (textarea.scrollHeight > textarea.clientHeight) {
                // has scrollBar
                // set `right` to be the scrollbar width
                dropZone.style.right = textarea.offsetWidth - textarea.clientWidth + 'px';
              } else {
                // does'nt have scrollBar
                dropZone.style.right = 0;
              }
            };

            fixItemPadding();
            textarea.addEventListener('keyup', fixItemPadding);
          });
        }
      },
      controller: function () {
        $body.on('click', basicMetadata.typeName, function (e) {
          if ($(this).val() == 'poster') {
            $('.poster').show();
            $('.preprint').hide();
          } else {
            $('.poster').hide();
            $('.preprint').show();
          }
        });
        basicMetadata.$dateInput.keyup(function (e) {
          if (e.keyCode == 8 || e.keyCode == 46) {
            $.datepicker._clearDate(this);
          }
        });
      },
      autocomplete: {
        $submittedToAutocomplete: null,
        $meetingsAutocomplete: null,

        submittedTo() {
          //initialize jqueru ui autocomplete
          this.$submittedToAutocomplete = $(basicMetadata.container).find('.submittedTo-field.ux3-autocomplete');
          this.$submittedToAutocomplete.autocomplete({
            source: (request, response) => {
              this.sources.journals(this.$submittedToAutocomplete.data('url'), request, response);
            },
            open: function () {
              $('.ui-menu.ui-autocomplete').width($(this).innerWidth());
            },
            minLength: 2,
            select: function (event, ui) {
              basicMetadata.$submittedInput.val(ui.item.id);
            },
            change: function (event, ui) {
              if (!ui.item) basicMetadata.$submittedInput.val('');
            }
          });
        },

        meetings() {
          this.$meetingsAutocomplete = $(basicMetadata.container).find('.meetings-field.ux3-autocomplete');
          const $target = $(basicMetadata.container).find('[name="basic-metadata.poster-meeting"]');
          const meetings = this.sources.meetings();
          this.$meetingsAutocomplete.autocomplete({
            source: (request, response) => {
              let matcher = new RegExp($.ui.autocomplete.escapeRegex(request.term), 'i');
              response($.grep(meetings, function (item) {
                return matcher.test(item.label);
              }));
            },
            open: function () {
              $('.ui-menu.ui-autocomplete').width($(this).innerWidth());
            },
            minLength: 2,
            select: function (event, ui) {
              $target.val(ui.item.name);
              basicMetadata.on.handleAdditional(ui.item);
            },
            change: function (event, ui) {
              if (!ui.item) $target.val('');else basicMetadata.on.handleAdditional(ui.item);
            }
          });
        },

        sources: {
          journals(url, request, response) {
            $.ajax({
              url: url,
              dataType: 'json',
              data: {
                query: request.term
              },
              success: function (data) {
                response($.map(data, function (el) {
                  return {
                    label: el.label,
                    value: el.label,
                    id: el.value
                  };
                }));
              }
            });
          },

          meetings() {
            let meetings = basicMetadata.autocomplete.$meetingsAutocomplete.data('source');
            if (!meetings) return [];
            basicMetadata.autocomplete.$meetingsAutocomplete.data('source', null);
            basicMetadata.autocomplete.$meetingsAutocomplete.removeAttr('data-source');
            return meetings.sort((a, b) => a.label > b.label ? 1 : -1);
          }

        }
      }
    };
    UX.basicMetadata = basicMetadata; // add to global namespace
  })();

  (function () {
    var $body = $('body');
    var funders = {
      magicSuggestData: null,
      $modal: null,
      $modalName: null,
      $modalValidationMessage: null,
      $modalNumber: null,
      $modalRecipient: null,
      $funderAjaxLink: null,
      td1: null,
      td2: null,
      td3: null,
      $table: null,
      $templateRow: null,
      $modalTitle: null,
      magicSuggest: null,
      fundersValues: null,
      $funderInputTemplate: null,
      init: function () {
        this.$modal = $('#funders-modal');
        this.$funderAjaxLink = $("#funderAjaxLink");
        this.$modalName = $("#funder-name");
        this.$modalNumber = $("#funder-grant-number");
        this.$modalRecipient = $("#funder-recipient");
        this.td1 = ".funder-td";
        this.td2 = ".grant-number-td";
        this.td3 = ".recipient-funder-td";
        this.$modalValidationMessage = $(".modal-validation-message");
        this.$table = $('.funders__table');
        this.$templateRow = $('.funders .rowTemplate tr');
        this.$modalTitle = $("#funders-modal .modal__header .modal__title");
        this.fundersValues = ".td-funders-val";
        this.$funderInputTemplate = $(".funderInputTemplate");
        funders.controller();
        funders.on.doSuggest();
      },
      fillAuthors: function () {
        if (UX.submissionAuthors.list && funders.$modalRecipient) {
          funders.$modalRecipient.find("option").remove();
          var authors = UX.submissionAuthors.list;
          funders.$modalRecipient.append('<option value="Other">Other</option>');

          for (var index = 0; index < authors.length; index++) {
            funders.$modalRecipient.append('<option value="' + authors[index] + '">' + authors[index] + '</option>');
          }

          if ($(funders.$modalRecipient).length > 0) $(funders.$modalRecipient)[0].selectedIndex = 0;
        }
      },
      controller: function () {
        $body.on('click', '#saveFunder', function (e) {
          e.preventDefault();

          if (funders.$modalNumber.val() == "" || funders.$modalRecipient.val() == "") {
            funders.$modalValidationMessage.text("Please fill all fields ");
          } else {
            var fundersValue = "";
            var fundersText = "";
            var $fundersValue = $('[name="funder-name[]"]');
            var $fundersText = $('#funder-name .ms-sel-item');
            var rowNum = funders.$modal.find(".row-num").val();
            var funderHiddenInputs = "";
            $fundersValue.each(function (index) {
              fundersValue += $(this).val();
              if (index != $fundersValue.length - 1) fundersValue += ",";
              funderHiddenInputs += funders.$funderInputTemplate.html().replace(/\{\{0\}\}/gi, $(this).val()).replace(/\{\{1\}\}/gi, rowNum).replace(/fakedinput/gi, "input");
            });
            $fundersText.each(function (index) {
              fundersText += $(this).text();
              if (index != $fundersText.length - 1) fundersText += ",";
            });

            if (funders.$modal.find(".mode").val() == 'add') {
              //add new row
              var rowHtml = funders.$templateRow[0].outerHTML;
              rowHtml = rowHtml.replace(/\{\{0\}\}/gi, fundersText).replace(/\{\{0_val\}\}/gi, fundersValue).replace(/\{\{0_inputs\}\}/gi, funderHiddenInputs).replace(/\{\{1\}\}/gi, funders.$modalNumber.val()).replace(/\{\{2\}\}/gi, funders.$modalRecipient.val()).replace(/\{\{3\}\}/gi, rowNum).replace(/fakedinput/gi, "input");
              funders.$table.find("tbody").append(rowHtml);
            } else {
              //edit row
              var $rowToEdit = funders.$table.find("tr[data-row-num=" + rowNum + "]");
              var $td1 = $rowToEdit.find(funders.td1);
              $td1.find('.td-text').text(fundersText);
              $td1.find('.funder__hidden-inputs').html(funderHiddenInputs);
              $td1.find(funders.fundersValues).html(fundersValue);
              var $td2 = $rowToEdit.find(funders.td2);
              $td2.find('.td-text').text(funders.$modalNumber.val());
              $td2.find('input').val(funders.$modalNumber.val());
              var $td3 = $rowToEdit.find(funders.td3);
              $td3.find('.td-text').text(funders.$modalRecipient.val());
              $td3.find('input').val(funders.$modalRecipient.val());
            }

            funders.$modal.modal('toggle');
            $(document).trigger('autosave');
          }
        });
        $body.on('click', '#addGrant', function (e) {
          e.preventDefault();
          funders.$modal.find(".mode").val('add');
          funders.$modal.find(".row-num").val(funders.$table.find('tbody tr').length);
          funders.magicSuggest.clear();
          funders.$modalNumber.val('');
          $(funders.$modalRecipient)[0].selectedIndex = 0;
          funders.$modalValidationMessage.text('');
          funders.$modalTitle.text('Add Funder');
          funders.$modal.modal({
            backdrop: 'static',
            keyboard: false
          }, 'toggle');
        });
        $body.on('click', '.funders .delete', function (e) {
          e.preventDefault();
          $(this).closest("tr").addClass('deleted hidden');
          $(this).closest("tr").html('');
        });
        $body.on('click', '.funders .edit', function (e) {
          e.preventDefault();
          var rowNumber = $(this).closest("tr").data("row-num");
          funders.$modal.find(".mode").val('edit');
          funders.$modal.find(".row-num").val(rowNumber);
          funders.$modalValidationMessage.text(' ');
          funders.$modalNumber.val($(this).closest("tr").find(funders.td2 + ' .td-text').html());
          var selectedFunders = $(this).closest("tr").find(funders.fundersValues).html().split(",");
          funders.magicSuggest.clear();
          if (selectedFunders != "") funders.magicSuggest.setValue(selectedFunders); //if problem occure here you can use "setSelection" check pd-author.js

          var selectedRecipient = $(this).closest("tr").find(funders.td3 + ' .td-text').html();
          var selectRecipientsOptions = $(funders.$modalRecipient).find("option");
          $(funders.$modalRecipient)[0].selectedIndex = 0;
          selectRecipientsOptions.each(function (index, option) {
            if ($(option).val() == selectedRecipient) {
              $(funders.$modalRecipient)[0].selectedIndex = index;
            }
          });
          funders.$modalTitle.text('Edit Funder');
          funders.$modal.modal({
            backdrop: 'static',
            keyboard: false
          }, 'toggle');
        });
      },
      on: {
        doSuggest: function () {
          funders.$modal.find('.magicsuggest').each(function () {
            if (funders.magicSuggestData == null) funders.magicSuggestData = funders.$funderAjaxLink.val();
            funders.magicSuggest = $(this).magicSuggest({
              data: funders.magicSuggestData,
              method: 'GET',
              valueField: 'value',
              autoSelect: false,
              allowFreeEntries: false,
              displayField: 'label',
              hideTrigger: 'true',
              useCommaKey: false,
              mode: "remote"
            });
          });
        }
      }
    };
    UX.funders = funders; // add to global namespace
  })();

  (function () {
    var $body = $('body');
    var draftForm = {
      $form: null,
      btnSubmit: null,
      btnRedirect: null,
      $notValid: null,
      autosaveEnabled: false,
      selectors: {
        basicMetadaType: '[name="basic-metadata.type"]',
        basicMetadaTypeSelected: '[name="basic-metadata.type"]:checked',
        hasExtraDropzone: '.has-extra-dropzone'
      },
      init: function () {
        draftForm.$form = $("#draftForm");
        draftForm.btnSubmit = '#draftForm [data-action]';
        draftForm.btnRedirect = '#draftForm [data-redirect]';
        draftForm.$notValid = $('.not-valid');
        draftForm.autosaveEnabled = draftForm.$form.hasClass('autosave-form');
        draftForm.controller();
      },
      classes: {
        hidden: 'hidden',
        notValid: 'not-valid',
        hasError: 'has-error',
        errorInput: 'error-input'
      },
      isValid: true,
      controller: function () {
        draftForm.$form.on('keyup keypress', function (e) {
          var keyCode = e.keyCode || e.which;

          if (keyCode === 13) {
            e.preventDefault();
            return false;
          }
        });
        $body.on('click', draftForm.btnSubmit, function (e) {
          e.preventDefault();
          var target = e.target;

          if (target.tagName === 'BUTTON') {
            draftForm.$form.attr('action', $(target).attr('data-action'));

            if (target.id == 'draft-form__submit') {
              draftForm.validate();
            } else {
              if (draftForm.validateFilesAndLinks()) {
                draftForm.submitForm();
              }
            }
          }
        });
        $body.on('click', draftForm.btnRedirect, function (e) {
          e.preventDefault();
          var target = e.target;

          if (target.tagName === 'BUTTON') {
            window.location = $(target).attr('data-redirect');
          }
        });
        $(draftForm.selectors.basicMetadaType).on('change', function (e) {
          $('[data-related-field="basic-metadata.type"]').addClass(draftForm.classes.hidden);
        });
      },
      validateBasicMetaData: function () {
        //basic metadata
        var selectedType = $(draftForm.selectors.basicMetadaTypeSelected).val();
        var requiredFields = [];
        requiredFields.push('basic-metadata.title');
        requiredFields.push('basic-metadata.abstract');
        requiredFields.push('basic-metadata.license'); //LICENSE

        requiredFields.push('editorial-category.uri'); //CATEGORY

        requiredFields.push('search-categories.uris[]'); //TAGS

        requiredFields.push('pdf.path__validator'); //PDF

        switch (selectedType) {
          case 'poster':
            requiredFields.push('basic-metadata.poster-meeting');
            requiredFields.push('basic-metadata.poster-first-presented-date-ui');
            break;

          case 'preprint':
            break;

          default:
            $('[data-related-field="basic-metadata.type"]').removeClass(draftForm.classes.hidden);
            draftForm.isValid = false;
        }

        requiredFields.forEach(function (field) {
          var $element = $('[name="' + field + '"]');
          var tempSelector = '[data-related-field="' + field + '"]';
          $element.removeClass(draftForm.classes.notValid);

          if (!$element.val() || !$element.val().length || $element.val() == 0) {
            draftForm.isValid = false;
            $(tempSelector).removeClass(draftForm.classes.hidden);
            $element.addClass(draftForm.classes.notValid);
            $element.closest(draftForm.selectors.hasExtraDropzone).addClass(draftForm.classes.hasError);
          }
        });
      },
      validate: function () {
        draftForm.isValid = true;
        $('.metadata-form__message').addClass(draftForm.classes.hidden);
        draftForm.validateBasicMetaData();
        draftForm.validateTaxonomies();
        draftForm.validatePdf();
        draftForm.validateAuthors();
        draftForm.isValid = draftForm.validateFilesAndLinks() && draftForm.isValid;

        if (draftForm.isValid === true) {
          draftForm.submitForm();
        } else {
          var $firstErrorMessage = $('.error:visible').eq(0);
          $(document).scrollTop($firstErrorMessage.closest('.submission-card').offset().top - $('header').height());
          $.each($('.not-valid, .error-input'), function () {
            let $this = $(this);
            $this.on('focus', function (e) {
              $this.removeClass(draftForm.classes.notValid);
              $this.closest(draftForm.selectors.hasExtraDropzone).removeClass(draftForm.classes.hasError);
              $('[data-related-field="' + $this.attr("name") + '"]').addClass(draftForm.classes.hidden);
              if ($this.is('.tags-input')) $this.closest('.categories-widget').find('.error').addClass(draftForm.classes.hidden);
              $this.off('focus');
            });
          });
          return false;
        }
      },
      validateFilesAndLinks: function () {
        var $rows = $('.uploaded-files tbody tr, .supplemental-links__table tbody tr');
        var _isValid = true;

        if ($rows.length) {
          $rows.find('.submission__select, .td-text textarea').each(function () {
            let $this = $(this);

            if ($this.hasClass(draftForm.classes.notValid) || $this.hasClass(draftForm.classes.errorInput)) {
              _isValid = false;
            }

            if ($this.val() === '' || $this.val() === 'unspecified') {
              $this.closest('td').find('.error').show();
              $this.addClass(draftForm.classes.notValid); // on focus hide error

              $this.on('focus', function () {
                $this.closest('td').find('.error').hide();
                $this.removeClass(draftForm.classes.notValid);
                $this.off('focus');
              });
              _isValid = false;
            }
          });
        }

        return _isValid;
      },
      submitForm: function () {
        if (draftForm.autosaveEnabled) {
          $(draftForm.btnSubmit).prop('disabled', true);
          $(document).trigger('autosave:now');
          draftForm.$form.on('autosave:saved', function () {
            draftForm.$form.submit();
          });
          draftForm.$form.on('autosave:complete', function () {
            $(draftForm.btnSubmit).prop('disabled', false);
          });
        } else {
          draftForm.$form.submit();
          $(draftForm.btnSubmit).prop('disabled', false);
        }
      },

      validateTaxonomies() {
        if (!$('[name="search-categories.uris[]"]').length) {
          $('.taxonomies-input-group .tags-input').addClass(draftForm.classes.notValid);
          $('[data-related-field="search-categories.uris"]').removeClass(draftForm.classes.hidden);
        } else {
          $('.taxonomies-input-group .tags-input').removeClass(draftForm.classes.notValid);
          $('[data-related-field="search-categories.uris"]').addClass(draftForm.classes.hidden);
        }
      },

      validatePdf() {
        $('input[name="pdf.path__validator"].not-valid').closest('.uploader__input-wrapper').addClass(draftForm.classes.errorInput);
      },

      validateAuthors() {
        const $submissionAuthors = $('.submission-authors'); // name, affiliations and email of authors

        const $fields = $submissionAuthors.find('input[name$="first-name"], input[name$="last-name"], input[name$="affiliations"], input[name$="email"]');
        $fields.closest('tr').removeClass(draftForm.classes.notValid);
        $fields.each(function () {
          const $field = $(this);
          $field.removeClass(draftForm.classes.notValid);

          if (!$field.val() || !$field.val().length || $field.val() == 0) {
            draftForm.isValid = false;
            $submissionAuthors.find('> .error').text('Author name, affiliations and email are required.');
            $submissionAuthors.addClass(draftForm.classes.notValid);
            $field.closest('tr').addClass(draftForm.classes.notValid);
          }
        }); // corresponding author validation

        if (!$submissionAuthors.find('.author__row.author__corresponding').length) {
          draftForm.isValid = false;
          $submissionAuthors.find('> .error').text('Please select corresponding author.');
          $submissionAuthors.addClass(draftForm.classes.notValid);
        }
      }

    };
    UX.draftForm = draftForm; // add to global namespace
  })();

  (function () {
    var $body = $('body');
    var pdPdf = {
      $uploader: null,
      $uploaderInput: null,
      $filenameInput: null,
      validateKey: "pdf.path__validator",
      $validator: null,
      currentItem: null,
      init: function () {
        pdPdf.$uploader = $('.pd-pdf .ajax-uploader');
        pdPdf.$uploaderContainer = $('.pd-pdf .uploader__input');
        pdPdf.$uploaderInputWrapper = $('.pd-pdf .uploader__input-wrapper');
        pdPdf.$uploaderInput = $('.pd-pdf .uploader__file');
        pdPdf.$filenameInput = $('.pd-pdf input[name="pdf_filename"]');
        pdPdf.$uploaderItem = $('.pd-pdf .files-list__item');
        pdPdf.$validator = pdPdf.$uploader.find('[name="' + pdPdf.validateKey + '"]');
        pdPdf.controller();
        if (pdPdf.$uploader.length) pdPdf.ajaxUploader.init();
      },
      controller: function () {
        pdPdf.$uploaderItem.on('click', '.remove-file', function () {
          if (pdPdf.currentItem) pdPdf.currentItem.abort();
          pdPdf.on.reset();
          setTimeout(() => {
            $(document).trigger('autosave'); // todo: get rid of jQuery trigger
          }, 500);
        });
      },
      on: {
        invalidate: function () {
          pdPdf.$validator.val('');
          pdPdf.$uploader.find("[data-related-field='" + pdPdf.validateKey + "']").addClass("hidden");
        },
        setValid: function () {
          pdPdf.$validator.val('success');
          $(document).trigger('autosave');
        },
        reset: function () {
          pdPdf.$uploaderInputWrapper.removeClass('error-input');
          pdPdf.$uploaderItem.find('.uploader__message span').text("");
          pdPdf.$uploaderItem.data('state', '');
          pdPdf.$uploaderItem.removeAttr('data-state');
          pdPdf.$uploaderContainer.css("display", '');
          pdPdf.$uploaderInput.val('');
          pdPdf.$filenameInput.val('');
          pdPdf.currentItem = null;
        }
      },
      ajaxUploader: {
        init: function () {
          var ajaxUploaderOptions = {
            dropzone: '.pd-pdf.uploader__wrapper',
            ajax: {
              url: pdPdf.$uploader.data('upload-url'),
              data: {
                "type": "pdf",
                "doi": pdPdf.$uploader.data('doi'),
                "signature": pdPdf.$uploader.data('signature'),
                "anti-forgery-token": pdPdf.$uploader.data('forgery')
              }
            },
            handlers: {
              start: function () {
                pdPdf.on.invalidate();
              },
              beforeUpload: pdPdf.ajaxUploader.on.processFile,
              validationError: function (exception, item) {
                pdPdf.ajaxUploader.showError(item.getState(), exception.message);
                pdPdf.on.invalidate();
              },
              progress: function (value, item) {
                var $progress = pdPdf.$uploaderItem.find(".uploader__progress progress");
                $progress.val(value);
              },
              success: function (item) {
                pdPdf.$uploaderItem.data("state", item.getState());
                pdPdf.$uploaderItem.attr("data-state", item.getState());
                pdPdf.$filenameInput.val(item.fileName());
                pdPdf.on.setValid();
              },
              error: function (item, message) {
                pdPdf.ajaxUploader.showError(item.getState(), message);
                pdPdf.on.invalidate();
              }
            }
          };
          new AjaxUploader(pdPdf.$uploader, ajaxUploaderOptions);
        },
        on: {
          processFile: function (item) {
            pdPdf.on.reset();
            pdPdf.currentItem = item;
            var filename = item.fileName();
            var fileSize = item.fileSizeHuman();
            pdPdf.$uploaderItem.find('.file-name').text(filename);
            pdPdf.$uploaderItem.find('.file-size').text("(" + fileSize + ")");
            pdPdf.$uploaderContainer.css("display", "none");
            pdPdf.$uploaderItem.attr('data-state', item.getState());
          }
        },
        showError: function (state, errorMessage) {
          pdPdf.$uploaderInputWrapper.addClass('error-input');

          if (errorMessage) {
            pdPdf.$uploaderItem.find('.uploader__message span').text(errorMessage);
          }

          pdPdf.$uploaderItem.data('state', state);
          pdPdf.$uploaderItem.attr('data-state', state);
        }
      }
    };
    UX.pdPdf = pdPdf; // add to global namespace
  })();

  (function () {
    var $body = $('body');
    var pdSearchCategories = {
      $element: null,
      $categoriesBlock: null,
      $tagsInput: null,
      $toggleButton: null,
      vPort: 'screen-sm',
      hideClasses: ['hidden-sm', 'hidden-xs'],
      init: function () {
        this.$element = $(".taxonomies-input-group");
        this.$dropdown = pdSearchCategories.$element.find('[data-db-target-for]');
        this.$categoriesBlock = this.$element.find(".taxonomies-dropblock");
        this.$tagsInput = this.$element.find(".tags-input");
        this.$toggleButton = $('.taxonomies__toggle');
        this.controller();
        this.slideController();
      },
      responsive: function () {
        $(document).on(pdSearchCategories.vPort + '-on');
      },
      slideController: function () {
        $(document).on('slide:opened', (e, slide) => {
          pdSearchCategories.$categoriesBlock = slide.$contents.find(".taxonomies-dropblock");
          pdSearchCategories.$tagsInput.find(".tags-input__item").each(function () {
            pdSearchCategories.$categoriesBlock.find("input[value='" + $(this).data('value') + "']").prop('checked', true);
          });
          this.on.slideToggleButton();
          slide.$contents.find('input[type=checkbox]').on("change", pdSearchCategories.on.checkboxClick);
        });
        $(document).on('slide:closed', function (e, slide) {
          pdSearchCategories.$categoriesBlock = pdSearchCategories.$element.find(".taxonomies-dropblock");
        });
      },
      controller: function () {
        this.$tagsInput.on("click", function (e) {
          if ($(e.target).is('.tags-input__item, .tags-input__item *')) return false;
        });
        this.$tagsInput.on("click", ".tags-input__remove", function (e) {
          e.stopPropagation();
          var val = $(this).closest('.tags-input__item').data('value');
          var $checkbox = pdSearchCategories.$categoriesBlock.find('input[id="' + val + '"]');
          pdSearchCategories.on.removeTag($checkbox);
          pdSearchCategories.on.toggleInput();
          if (!pdSearchCategories.$tagsInput.hasClass('js--open')) $(document).trigger('autosave');
        });
        this.$categoriesBlock.on("change", "input[type=checkbox]", pdSearchCategories.on.checkboxClick);
        this.on.slideToggleButton();
        pdSearchCategories.$dropdown.on('dropBlock:close', function (event, controller, target) {
          $(document).trigger('autosave');
        });
      },
      on: {
        slideToggleButton() {
          $(document).off('click', '.taxonomies__toggle');
          $(document).on('click', '.taxonomies__toggle', function (e) {
            e.preventDefault();
            let $list = $(this).siblings('.taxonomies__list');
            $list.slideToggle();
            $(this).toggleClass('js--open');
          });
        },

        checkboxClick: function (e) {
          e.stopPropagation();
          var $checkbox = $(this);
          if ($checkbox.is(":checked")) pdSearchCategories.on.addTag($checkbox);else pdSearchCategories.on.removeTag($checkbox);
          pdSearchCategories.on.toggleInput();
        },
        removeTag: function ($checkbox) {
          var category = $checkbox.val();
          var $tag = pdSearchCategories.$tagsInput.find('[data-value="' + category + '"]');
          var parent = $checkbox.data("parent-id");

          if (!parent) {
            // I'm parent and my children should be removed with me.
            var selectedChildren = pdSearchCategories.$categoriesBlock.find('input[data-parent-id="' + category + '"]:checked');

            if (selectedChildren.length) {
              selectedChildren.each(function () {
                pdSearchCategories.on.removeTag($(this));
              });
            }
          }

          $checkbox.prop('checked', false);
          $tag.remove();
        },
        addTag: function ($checkbox) {
          var category = $checkbox.val();
          var label = $checkbox.siblings('.label-txt').text();
          var tag = pdSearchCategories.buildTag(category, label);
          var parent = $checkbox.data("parent-id");

          if (parent) {
            // I'm child and my parent should be selected with me.
            var $parentTag = pdSearchCategories.$tagsInput.find('[data-value="' + parent + '"]');

            if (!$parentTag.length) {
              var $parent = pdSearchCategories.$categoriesBlock.find('input[id="' + parent + '"]');
              $parent.prop('checked', true);
              $parentTag = pdSearchCategories.on.addTag($parent);
            }

            return $(tag).appendTo($parentTag.find('> ul'));
          }

          return $(tag).appendTo(pdSearchCategories.$tagsInput.find('.tags-input__list'));
        },
        toggleInput: function () {
          if (pdSearchCategories.$tagsInput.find('> .tags-input__list').is(":empty")) {
            pdSearchCategories.$tagsInput.addClass(pdSearchCategories.hideClasses.join(" "));
          } else {
            pdSearchCategories.$tagsInput.removeClass(pdSearchCategories.hideClasses.join(" "));
          }
        }
      },
      buildTag: function (category, label) {
        return '<li class="tags-input__item" data-value="' + category + '"><span>' + label + '</span><input type="hidden" name="search-categories.uris[]" value="' + category + '"><ul></ul><span title="Remove" class="tags-input__remove"></span></li>';
      }
    };
    UX.pdSearchCategories = pdSearchCategories; // add to global namespace
  })();

  // fallback for {string}.includes()
  if (!String.prototype.includes) {
    String.prototype.includes = function (search, start) {

      if (typeof start !== 'number') {
        start = 0;
      }

      if (start + search.length > this.length) {
        return false;
      } else {
        return this.indexOf(search, start) !== -1;
      }
    };
  }

  (function (thisVar, undefined) {

    var main = typeof window === 'object' && window || typeof global === 'object' && global || typeof self === 'object' && self || thisVar;
    var hasSetImmediate = typeof setImmediate === 'function';
    var hasNextTick = typeof process === 'object' && !!process && typeof process.nextTick === 'function';
    var index = 0;

    function getNewIndex() {
      if (index === 9007199254740991) {
        return 0;
      }

      return ++index;
    }

    var setAsap = function () {
      var hiddenDiv, scriptEl, timeoutFn, callbacks; // Modern browsers, fastest async

      if (main.MutationObserver) {
        return function setAsap(callback) {
          hiddenDiv = document.createElement("div");
          new MutationObserver(function () {
            callback();
            hiddenDiv = null;
          }).observe(hiddenDiv, {
            attributes: true
          });
          hiddenDiv.setAttribute('i', '1');
        }; // Browsers that support postMessage
      } else if (!hasSetImmediate && main.postMessage && !main.importScripts && main.addEventListener) {
        var MESSAGE_PREFIX = "com.setImmediate" + Math.random();
        callbacks = {};

        var onGlobalMessage = function (event) {
          if (event.source === main && event.data.indexOf(MESSAGE_PREFIX) === 0) {
            var i = +event.data.split(':')[1];
            callbacks[i]();
            delete callbacks[i];
          }
        };

        main.addEventListener("message", onGlobalMessage, false);
        return function setAsap(callback) {
          var i = getNewIndex();
          callbacks[i] = callback;
          main.postMessage(MESSAGE_PREFIX + ':' + i, "*");
        }; // IE browsers without postMessage
      } else if (!hasSetImmediate && main.document && 'onreadystatechange' in document.createElement('script')) {
        return function setAsap(callback) {
          scriptEl = document.createElement("script");

          scriptEl.onreadystatechange = function onreadystatechange() {
            scriptEl.onreadystatechange = null;
            scriptEl.parentNode.removeChild(scriptEl);
            scriptEl = null;
            callback();
          };

          document.body.appendChild(scriptEl);
        }; // All other browsers and node
      } else {
        timeoutFn = hasSetImmediate && setImmediate || hasNextTick && process.nextTick || setTimeout;
        return function setAsap(callback) {
          timeoutFn(callback);
        };
      }
    }();

    if (typeof module !== 'undefined' && module.exports) {
      module.exports = setAsap;
    } else if (typeof require !== 'undefined' && require.amd) {
      define(function () {
        return setAsap;
      });
    } else {
      main.setAsap = setAsap;
    }
  })(window);

  (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory() : typeof define === 'function' && define.amd ? define(factory) : factory();
  })(window, function () {
    /**
     * @this {Promise}
     */

    function finallyConstructor(callback) {
      var constructor = this.constructor;
      return this.then(function (value) {
        return constructor.resolve(callback()).then(function () {
          return value;
        });
      }, function (reason) {
        return constructor.resolve(callback()).then(function () {
          return constructor.reject(reason);
        });
      });
    } // Store setTimeout reference so promise-polyfill will be unaffected by
    // other code modifying setTimeout (like sinon.useFakeTimers())


    var setTimeoutFunc = setTimeout;

    function noop() {} // Polyfill for Function.prototype.bind


    function bind(fn, thisArg) {
      return function () {
        fn.apply(thisArg, arguments);
      };
    }
    /**
     * @constructor
     * @param {Function} fn
     */


    function Promise(fn) {
      if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');
      if (typeof fn !== 'function') throw new TypeError('not a function');
      /** @type {!number} */

      this._state = 0;
      /** @type {!boolean} */

      this._handled = false;
      /** @type {Promise|undefined} */

      this._value = undefined;
      /** @type {!Array<!Function>} */

      this._deferreds = [];
      doResolve(fn, this);
    }

    function handle(self, deferred) {
      while (self._state === 3) {
        self = self._value;
      }

      if (self._state === 0) {
        self._deferreds.push(deferred);

        return;
      }

      self._handled = true;

      Promise._immediateFn(function () {
        var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;

        if (cb === null) {
          (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
          return;
        }

        var ret;

        try {
          ret = cb(self._value);
        } catch (e) {
          reject(deferred.promise, e);
          return;
        }

        resolve(deferred.promise, ret);
      });
    }

    function resolve(self, newValue) {
      try {
        // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
        if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');

        if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
          var then = newValue.then;

          if (newValue instanceof Promise) {
            self._state = 3;
            self._value = newValue;
            finale(self);
            return;
          } else if (typeof then === 'function') {
            doResolve(bind(then, newValue), self);
            return;
          }
        }

        self._state = 1;
        self._value = newValue;
        finale(self);
      } catch (e) {
        reject(self, e);
      }
    }

    function reject(self, newValue) {
      self._state = 2;
      self._value = newValue;
      finale(self);
    }

    function finale(self) {
      if (self._state === 2 && self._deferreds.length === 0) {
        Promise._immediateFn(function () {
          if (!self._handled) {
            Promise._unhandledRejectionFn(self._value);
          }
        });
      }

      for (var i = 0, len = self._deferreds.length; i < len; i++) {
        handle(self, self._deferreds[i]);
      }

      self._deferreds = null;
    }
    /**
     * @constructor
     */


    function Handler(onFulfilled, onRejected, promise) {
      this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
      this.onRejected = typeof onRejected === 'function' ? onRejected : null;
      this.promise = promise;
    }
    /**
     * Take a potentially misbehaving resolver function and make sure
     * onFulfilled and onRejected are only called once.
     *
     * Makes no guarantees about asynchrony.
     */


    function doResolve(fn, self) {
      var done = false;

      try {
        fn(function (value) {
          if (done) return;
          done = true;
          resolve(self, value);
        }, function (reason) {
          if (done) return;
          done = true;
          reject(self, reason);
        });
      } catch (ex) {
        if (done) return;
        done = true;
        reject(self, ex);
      }
    }

    Promise.prototype['catch'] = function (onRejected) {
      return this.then(null, onRejected);
    };

    Promise.prototype.then = function (onFulfilled, onRejected) {
      // @ts-ignore
      var prom = new this.constructor(noop);
      handle(this, new Handler(onFulfilled, onRejected, prom));
      return prom;
    };

    Promise.prototype['finally'] = finallyConstructor;

    Promise.all = function (arr) {
      return new Promise(function (resolve, reject) {
        if (!arr || typeof arr.length === 'undefined') throw new TypeError('Promise.all accepts an array');
        var args = Array.prototype.slice.call(arr);
        if (args.length === 0) return resolve([]);
        var remaining = args.length;

        function res(i, val) {
          try {
            if (val && (typeof val === 'object' || typeof val === 'function')) {
              var then = val.then;

              if (typeof then === 'function') {
                then.call(val, function (val) {
                  res(i, val);
                }, reject);
                return;
              }
            }

            args[i] = val;

            if (--remaining === 0) {
              resolve(args);
            }
          } catch (ex) {
            reject(ex);
          }
        }

        for (var i = 0; i < args.length; i++) {
          res(i, args[i]);
        }
      });
    };

    Promise.resolve = function (value) {
      if (value && typeof value === 'object' && value.constructor === Promise) {
        return value;
      }

      return new Promise(function (resolve) {
        resolve(value);
      });
    };

    Promise.reject = function (value) {
      return new Promise(function (resolve, reject) {
        reject(value);
      });
    };

    Promise.race = function (values) {
      return new Promise(function (resolve, reject) {
        for (var i = 0, len = values.length; i < len; i++) {
          values[i].then(resolve, reject);
        }
      });
    }; // Use polyfill for setImmediate for performance gains


    Promise._immediateFn = typeof setImmediate === 'function' && function (fn) {
      setImmediate(fn);
    } || function (fn) {
      setTimeoutFunc(fn, 0);
    };

    Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
      if (typeof console !== 'undefined' && console) {
        console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
      }
    };
    /** @suppress {undefinedVars} */


    var globalNS = function () {
      // the only reliable means to get the global object is
      // `Function('return this')()`
      // However, this causes CSP violations in Chrome apps.
      if (typeof self !== 'undefined') {
        return self;
      }

      if (typeof window !== 'undefined') {
        return window;
      }

      if (typeof global !== 'undefined') {
        return global;
      }

      throw new Error('unable to locate global object');
    }();

    if (!('Promise' in globalNS)) {
      globalNS['Promise'] = Promise;
    } else if (!globalNS.Promise.prototype['finally']) {
      globalNS.Promise.prototype['finally'] = finallyConstructor;
    }
  });

  (function () {
    let $body = $('body'),
        isMobile = false;
    /**
     * Submission List Model
     *
     */

    var submissionList = {
      submissionListItem: null,
      $submissionListItems: null,
      submissionListWrapper: null,
      submissionListItself: null,
      dashboardMain: null,
      $toolsDropBlocks: null,
      $loadingTarget: null,
      loaderStatus: false,
      doi: null,
      widgets: [{
        class: '.pdActionBar',
        url: '/pb/widgets/preprint/submissionActionBar'
      }, {
        class: '.pbArticleView',
        url: '/pb/widgets/preprint/submissionContent'
      }, {
        class: '.pbActionRecords',
        url: '/pb/widgets/preprint/actionRecords'
      }, {
        class: '.pbAuthorsHistory',
        url: '/pb/widgets/preprint/authorHistory'
      }],
      selectors: {
        submissionListItemNotSelected: '.submission-list-item:not(.selected)'
      },
      classes: {
        loading: 'loading',
        hidden: 'hidden'
      },
      htmlMarkups: {
        loadingWrapper: '<div class="loading-wrapper"> <svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.0" width="64px" height="64px" viewBox="0 0 128 128" xml:space="preserve"> <g transform="rotate(222.589 64 64)"> <path d="M75.4 126.63a11.43 11.43 0 0 1-2.1-22.65 40.9 40.9 0 0 0 30.5-30.6 11.4 11.4 0 1 1 22.27 4.87h.02a63.77 63.77 0 0 1-47.8 48.05v-.02a11.38 11.38 0 0 1-2.93.37z" fill="#999999" fill-opacity="1"></path> <animateTransform attributeName="transform" type="rotate" from="0 64 64" to="360 64 64" dur="1000ms" repeatCount="indefinite"></animateTransform> </g> </svg> </div>',
        ajaxError: '<div class="warning-text-color">Oops. Something went wrong!</div>'
      },
      vPort: 'screen-sm',
      dashboardActions: {
        'admin': "showAdminDashboard",
        'advisor': "showAdvisorDashboard",
        'author': "showAuthorDashboard"
      },

      init() {
        this.submissionListItem = '.submission-list-item';
        this.$submissionListItems = $(this.submissionListItem);
        this.$toolsDropBlocks = $('.pd-list-tools .dropBlock');
        this.$loadingTarget = $('body');
        this.submissionListWrapper = document.querySelector('.submission-list');
        this.submissionListItself = document.querySelector('.submission-list__list');
        this.dashboardMain = document.querySelector('.dashboard-main');
        this.prepare();
        this.responsive();
        this.controller();
        this.additionalInit();
      },

      additionalInit() {},

      responsive() {
        $(document).on(`${submissionList.vPort}-on`, () => {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          isMobile = true;
          submissionList.methods.resetListStyle();
        });
        $(document).on(`${submissionList.vPort}-off`, () => {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          isMobile = false;
          submissionList.methods.prepareListStyle();
        });
      },

      prepare() {
        this.methods.prepareListStyle();
        this.methods.truncateTitles();
        this.methods.selectFirstItem();
      },

      controller() {
        this.$submissionListItems.on('click', e => e.preventDefault());
        $(this.submissionListItself).on('click', submissionList.selectors.submissionListItemNotSelected, this._clickHandler);
        $(document).on('slide:opened', (e, slide) => {
          let el = slide.$toggle.closest(this.submissionListItem)[0];
          if (el) this.on.click(el).then(this.on.widgetsLoaded);
        });
        this.additionalController();
      },

      additionalController: function () {},
      _clickHandler: e => {
        e.preventDefault();

        if (!isMobile) {
          let el = e.target.closest(submissionList.submissionListItem);
          submissionList.on.click(el).then(submissionList.on.widgetsLoaded);
        }
      },
      on: {
        /**
         *
         * @param {HTMLElement} el
         * @return Promise
         */
        click(el) {
          submissionList.methods.setLoading(true);
          document.querySelectorAll(`${submissionList.submissionListItem}.selected`).forEach(item => {
            item.classList.remove("selected");
          });
          el.classList.add("selected");
          submissionList.doi = el.dataset.doi;
          return submissionList.on.loadWidgets();
        },

        /**
         * Load Widgets
         * @return Promise
         */
        loadWidgets() {
          let promises = [];

          const loadWidget = (widget, resolve) => {
            let $widget = $(widget.class);
            let replace = widget.replace !== false;
            $widget.html('');
            let widgetId = $widget.data('widget-id');
            let pbContext = $("[name='pbContext']").attr('content');
            return new Promise(function (resolve, reject) {
              $.ajax({
                type: 'GET',
                url: widget.url,
                dataType: 'html',
                data: {
                  doi: submissionList.doi,
                  widgetId: widgetId,
                  pbContext: pbContext,
                  dashboard: submissionList.methods.currentDashboard(),
                  currentTab: submissionList.methods.currentState()
                },

                success(html) {
                  if (replace) {
                    if (html.trim() === '') html = `<div class="${widget.class.substr(1)}" data-widget-id="${widgetId}"></div>`;
                    $widget.replaceWith(html);
                  } else {
                    $widget.html(html);
                  }

                  if (widget.onSuccess && widget.onSuccess.length) {
                    widget.onSuccess.forEach(item => {
                      promises.push(loadWidget(item));
                    });
                  }
                },

                error() {
                  $widget.replaceWith(submissionList.htmlMarkups.ajaxError);
                },

                complete() {
                  submissionList.methods.setLoading(false);
                  resolve(widget.class);
                }

              });
            });
          };

          submissionList.widgets.forEach(widget => {
            promises.push(loadWidget(widget));
          });
          return new Promise(function (resolve, reject) {
            Promise.all(promises).then(function () {
              resolve('all');
            });
          });
        },

        widgetsLoaded() {
          setTimeout(() => {
            submissionList.methods.refreshWidgets();
          }, 0);
        }

      },
      methods: {
        /**
         * Truncate Submissions titles in the list
         */
        truncateTitles() {
          $('.submission-list-item__title').not('[data-truncate="none"]').truncate({
            lines: 2
          });
        },

        prepareListStyle() {
          this.setListHeight();
          this.setDashboardMainHeight();
          this.makeListSticky();
        },

        resetListStyle() {
          this.setListHeight(true);
          this.setDashboardMainHeight(true);
          this.makeListSticky(true);
        },

        /**
         * Set List height to fill the page
         * @param {boolean} [destroy]
         * @param {number} [exclude]
         */
        setListHeight(destroy, exclude) {
          if (destroy) {
            submissionList.submissionListItself.style.height = '';
            return;
          }

          if (submissionList.submissionListWrapper && submissionList.submissionListItself) {
            let excludeHeight = typeof exclude !== "undefined" ? exclude : 25;
            excludeHeight += submissionList.submissionListWrapper.querySelector('.pd-list-tools').parentElement.getBoundingClientRect().height;
            excludeHeight += this.mainPaddingTop;
            submissionList.submissionListItself.style.height = `calc(100vh - ${excludeHeight}px)`;
          }
        },

        /**
         * Set the `dashboard-main` height to be fixed with page height
         * @param {boolean} [destroy]
         */
        setDashboardMainHeight(destroy) {
          let target;

          if (submissionList.submissionListWrapper && submissionList.dashboardMain && submissionList.dashboardMain.dataset.fixedHeight !== 'false') {
            target = submissionList.dashboardMain.closest('[class*="col-"]');
          }

          if (target) {
            if (destroy) {
              target.style.height = '';
              target.style.overflowY = '';
            } else {
              target.style.height = `${submissionList.submissionListWrapper.getBoundingClientRect().height}px`;
              target.style.overflowY = 'auto';
            }
          }
        },

        /**
         * Make the list sticky while scrolling
         * @param {boolean} [destroy]
         */
        makeListSticky(destroy) {
          const stickyWrapper = submissionList.submissionListWrapper.parentElement;

          if (destroy) {
            stickyWrapper.style.position = '';
            stickyWrapper.style.top = '';
            return;
          }

          stickyWrapper.style.position = 'sticky';
          stickyWrapper.style.top = `${this.mainPaddingTop}px`;
        },

        /**
         * Select First item in the list on page load
         */
        selectFirstItem() {
          let firstItem = document.querySelector(`${submissionList.submissionListItem}:first-child`);
          if (!firstItem) return; // setTimeout trick to let the browser execute this after it finishes rendering

          setTimeout(() => {
            $(firstItem).trigger('click');
          }, 0);
        },

        get mainPaddingTop() {
          const main = document.querySelector('main.content');

          if (main) {
            return parseInt(window.getComputedStyle(main).getPropertyValue('padding-top'));
          }

          return 0;
        },

        setLoading(state) {
          if (state === true) {
            submissionList.loaderStatus = true;
            let loadingEl = submissionList.htmlMarkups.loadingWrapper;
            if (document.querySelector(".loading-wrapper")) loadingEl = loadingEl.outerHTML;
            submissionList.$loadingTarget.append(loadingEl);
            submissionList.$loadingTarget.addClass(submissionList.classes.loading);
          } else {
            submissionList.loaderStatus = false;
            submissionList.$loadingTarget.find("> .loading-wrapper").remove();
            submissionList.$loadingTarget.removeClass(submissionList.classes.loading);
          }
        },

        checkIncomplete() {
          $(".submission-card").each((index, element) => {
            if ($(element).find(".incomplete").length) $(element).find('.badge').removeClass(submissionList.classes.hidden);
          });
        },

        refreshWidgets() {
          if ($('.pd-action-bar').length) {
            UX.pdActionBar.init();
          }

          if ($('.pbArticleView').length) {
            UX.accordion.init();
            submissionList.methods.checkIncomplete();
          }

          if ($('.pbActionRecords').length) {
            UX.advisorActionRecords.init();
          }

          if ($('.pbAuthorsHistory').length) {
            UX.authorsHistory.init();
          }

          if ($('.dashboard-toolbar').length) {
            UX.dashboardToolbar.init();
          }
        },

        currentDashboard() {
          const pathname = window.location.pathname;

          for (let dashboard in submissionList.dashboardActions) {
            if (!submissionList.dashboardActions.hasOwnProperty(dashboard)) continue;
            const action = submissionList.dashboardActions[dashboard];
            if (pathname.indexOf(action) !== -1) return dashboard;
          }

          return '';
        },

        currentState() {
          const statusNameElem = document.querySelector(".status-tabs .active");
          if (!statusNameElem) return false;
          const statusName = statusNameElem.textContent.toLowerCase();
          return statusName.replace(/\s+/g, "-");
        }

      }
    };
    UX.submissionList = submissionList; // add to global namespace
  })();

  (function () {
    var $body = $('body'),
        isMobile = false;
    var supplementalFiles = {
      $container: null,
      tdDesc: null,
      tdPath: null,
      $table: null,
      $templateRow: null,
      $uploaderElement: null,
      vPort: 'screen-sm',
      $selector: null,
      $condition: null,
      $fileName: null,
      $lastElement: null,
      $this: null,
      files: {},
      selectors: {
        submissionSubmit: 'select.submission__select',
        errorNotImage: '.error--not-image'
      },
      init: function () {
        this.$container = $('.supplemental-files');
        this.tdDesc = '.description-td';
        this.tdPath = '.path-td';
        this.$table = this.$container.find('.uploaded-files');
        this.$templateRow = this.$container.find('.rowTemplate tr');
        this.$uploaderElement = this.$container.find('.ajax-uploader');
        this.modal.init();
        this.controller();
      },
      controller: function () {
        this.$table.on('click', '.edit', supplementalFiles.on.edit);
        this.$table.on('change', supplementalFiles.selectors.submissionSubmit, function () {
          $(document).trigger('autosave');
          let $this = $(this);
          $this.removeClass('not-valid');
          $this.removeClass('error-input');
          $(this).closest('td').find(supplementalFiles.selectors.errorNotImage).hide();
          supplementalFiles.on.fileTypeChange($this);
        });
        let uploaderElement = supplementalFiles.$uploaderElement[0];
        if (uploaderElement) uploaderElement.addEventListener('success:uploader', supplementalFiles.on.success); // popup

        this.$table.on('mouseenter', '.js-editable:not(.js--open) .js-editable__text', supplementalFiles.on.showPopup);
        this.$table.on('mouseleave', '.js-editable', supplementalFiles.on.hidePopup);
        this.$table.on('click', '.remove-file', function () {
          const rowIndex = $(this).closest('tr').data('index');
          delete supplementalFiles.files[rowIndex];
        });
      },

      /**
       * Determine if I am in mobile
       */
      responsive: function () {
        $(document).on(supplementalFiles.vPort + '-off', function () {
          // Waiting for custom event that will be triggered by controller.js to deactivate responsive effects
          isMobile = false;
        });
        $(document).on(supplementalFiles.vPort + '-on', function () {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          isMobile = true;
        });
      },
      isFileImage: function ($this) {
        const index = $this.closest('tr').data('index');

        if (!supplementalFiles.files[index].getType().includes('image/')) {
          $this.addClass('not-valid');
          $this.closest('td').find(supplementalFiles.selectors.errorNotImage).show();
        }
      },
      on: {
        add: function (item) {
          // show table
          supplementalFiles.$table.show();
          var $row = supplementalFiles.$templateRow.clone();
          var html = $row.html();
          html = html.replace(/fakedinput/gi, 'input').replace(/fakedtextarea/gi, 'textarea').replace(/fakedselect/gi, 'select').replace(/\{\{filenameTruncated\}\}/gi, item.fileNameTruncated()).replace(/\{\{filename\}\}/gi, item.fileName()).replace(/{{index}}/gi, item.getIndex());
          $row.html(html);
          $row.data("index", item.getIndex());
          $row.attr("data-index", item.getIndex());
          $row.appendTo(supplementalFiles.$table.find('tbody'));
          var selectors = $row.find('.future-jcf');

          if (selectors) {
            selectors.removeClass('future-jcf');
            selectors.addClass('jcf');
            jcf.replace(selectors);
          }

          if (UX.editInPlace) {
            UX.editInPlace.init();
          }

          if (UX.charCounter) {
            UX.charCounter.init();
          }

          setTimeout(() => {
            $(document).trigger('autosave'); // todo: get rid of jQuery trigger
          }, 500);
        },
        edit: function () {
          var index = $(this).closest('tr').data('index');
          supplementalFiles.modal.show(index);
        },

        /**
         * Show popup on row cell
         */
        showPopup: function () {
          if (!isMobile) {
            var content = $(this).text();
            var hasHover = $(this).closest(".js-editable").find('.hover-popup').length;

            if (content !== "" && !hasHover) {
              var html = "<div class='hover-popup'>" + content + "</div>";
              var $hover = $(html);
              $hover.width($(this).outerWidth());
              $hover.insertAfter($(this));
            }
          }
        },

        /**
         * Hide popup on row cell
         */
        hidePopup: function () {
          if (!isMobile) {
            $(this).find(".hover-popup").remove();
          }
        },
        success: function (ev) {
          /**
           * @var {UploaderFile}
           */
          var item = ev.detail.item;
          var $item = supplementalFiles.$uploaderElement.find(`.files-list__item[data-index=${item.getIndex()}]`);
          supplementalFiles.on.add(item);
          $item.remove();
        },
        fileTypeChange: function ($this) {
          const selectedVal = $this.val();

          if (selectedVal === 'image') {
            supplementalFiles.isFileImage($this);
          }
        }
      },
      modal: {
        $modal: null,
        $row: null,
        $filename: null,
        $description: null,
        $type: null,
        $saveBtn: null,
        init: function () {
          this.$modal = $("#suppfiles-modal");
          this.$filename = this.$modal.find('.suppfile-filename');
          this.$description = this.$modal.find('.suppfile-description');
          this.$type = this.$modal.find('.suppfile-type');
          this.$saveBtn = this.$modal.find('#saveSuppFile');
          this.controller();
        },
        controller: function () {
          this.$modal.on('show.bs.modal', function () {
            supplementalFiles.modal.refreshPlugins();
          });
          this.$saveBtn.on('click', function () {
            supplementalFiles.modal.save();
            supplementalFiles.modal.hide();
          });
        },
        show: function (rowNum) {
          if (rowNum !== false) {
            this.$row = supplementalFiles.$table.find(`tr[data-index="${rowNum}"]`);
            this.prepare();
          }

          this.$modal.modal({
            backdrop: 'static',
            keyboard: false
          }, 'show');
        },
        hide: function () {
          this.$modal.modal('hide');
        },
        refreshPlugins: function () {
          jcf.getInstance(this.$type).refresh();
          UX.charCounter.init();
        },
        prepare: function () {
          var data = this.getDataFromRow();
          if (data.filename) this.$filename.html(data.filename);
          if (data.description) this.$description.val(data.description);
          if (data.type) this.$type.val(data.type);
        },
        getDataFromRow: function () {
          var data = {};
          data.filename = this.$row.find('.path-td .td-text').html();
          data.description = this.$row.find('.description-td textarea').val();
          data.type = this.$row.find('.file-type-td select').val();
          return data;
        },
        save: function () {
          var newDescription = this.$description.val();
          this.$row.find('.description-td .js-editable__text').text(newDescription);
          this.$row.find('.description-td textarea').val(newDescription);
          var newType = this.$type.val();
          var newTypeLabel = this.$type.find(`option[value="${newType}"]`).text();
          var $select = this.$row.find('.file-type-td select');
          $select.val(newType);
          this.$row.find('.file-type-td .td-text').text(newTypeLabel);
          jcf.getInstance($select).refresh();
        }
      }
    };
    UX.supplementalFiles = supplementalFiles; // add to global namespace
  })();

  (function (UX) {
    var $body = $('body'),
        isMobile = false;
    var supplementalLinks = {
      $table: null,
      $templateRow: null,
      $newLinkInput: null,
      $validationMessage: null,
      $saveLink: null,
      $addLink: null,
      $form: null,
      vPort: 'screen-sm',
      tds: {
        url: '.url-doi-td',
        description: '.description-td',
        type: '.content-type-td'
      },
      strings: {
        "notUrl": "Please enter a valid URL ",
        "empty": "This field can't be empty ",
        "emptyUrl": "URL can't be empty ",
        "emptyDescription": "Description can't be empty ",
        "add": "Add Supplemental Link",
        "edit": "Edit Supplemental Link"
      },
      // For validating URLS
      urlPattern: /(?:https?|ftp):\/\/(?:\([-A-Z0-9+&@#\/%=~_|$?!:,.]*\)|[-A-Z0-9+&@#\/%=~_|$?!:,.])*(?:\([-A-Z0-9+&@#\/%=~_|$?!:,.]*\)|[A-Z0-9+&@#\/%=~_|$])/i,
      init: function () {
        this.$table = $('.supplemental-links__table');
        this.$templateRow = $('.supplemental-links .rowTemplate tr');
        this.$form = $(".supplemental-links__form");
        this.$saveLink = $("#saveSuppLink");
        this.$addLink = $("#addSuppLink");
        this.$newLinkInput = $("#supp-link-url");
        this.$validationMessage = $(".supplemental-links .validation-message");
        this.modal.init();
        supplementalLinks.responsive();
        supplementalLinks.controller();
      },

      /**
       * Determine if I am in mobile
       */
      responsive: function () {
        $(document).on(supplementalLinks.vPort + '-off', function () {
          // Waiting for custom event that will be triggered by controller.js to deactivate responsive effects
          isMobile = false;
        });
        $(document).on(supplementalLinks.vPort + '-on', function () {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          isMobile = true;
        });
      },

      /**
       * Events handlers for thew widget
       */
      controller: function () {
        // mobile Add link button -> opens the modal
        supplementalLinks.$addLink.on('click', function (e) {
          e.preventDefault();
          supplementalLinks.modal.show();
        }); // desktop Save link button -> add link directly from input with defaults

        supplementalLinks.$saveLink.on('click', supplementalLinks.on.saveLinkClick); // Save on enter && toggle desktop add link button state

        supplementalLinks.$newLinkInput.on('input keyup', function (e) {
          if (e.keyCode === 13) supplementalLinks.$saveLink.trigger('click');else supplementalLinks.methods.toggleState();
        }); // rows events

        supplementalLinks.rowControllers(this.$table.find('tbody tr'));
      },
      on: {
        /**
         * Handler for desktop add link button
         */
        saveLinkClick: function (e) {
          e.preventDefault();
          var data = {
            url: supplementalLinks.$newLinkInput.val(),
            description: supplementalLinks.$newLinkInput.val()
          };
          var validationResult = supplementalLinks.methods.validate(data);

          if (!validationResult.success) {
            supplementalLinks.methods.showError(validationResult.message);
            return;
          }

          supplementalLinks.methods.save(data); // return to first state

          supplementalLinks.$newLinkInput.val("");
          supplementalLinks.methods.toggleState();
        }
      },
      methods: {
        /**
         * Show error in desktop
         * @param message
         */
        showError: function (message) {
          supplementalLinks.$validationMessage.text(message);
          var vmWidth = supplementalLinks.$validationMessage.outerWidth();
          supplementalLinks.$newLinkInput.css('padding-right', vmWidth);
          supplementalLinks.$form.addClass('error-input');
        },

        /**
         * Hide error in desktop
         */
        hideError: function () {
          supplementalLinks.$validationMessage.text("");
          supplementalLinks.$newLinkInput.css('padding-right', false);
          supplementalLinks.$form.removeClass('error-input');
        },

        /**
         * Check the validation of URL
         * @param url
         * @returns {boolean}
         */
        validateUrl: function (url) {
          return supplementalLinks.urlPattern.test(url);
        },

        /**
         * Validate Input Data
         * @param data
         * @returns {*}
         */
        validate: function (data) {
          if (!data.url || data.url === "") {
            return {
              success: false,
              message: supplementalLinks.strings["emptyUrl"]
            };
          }

          if (!this.validateUrl(data.url)) {
            return {
              success: false,
              message: supplementalLinks.strings["notUrl"]
            };
          }

          if (!data.description || data.description === "") {
            return {
              success: false,
              message: supplementalLinks.strings["emptyDescription"]
            };
          }

          return {
            success: true
          };
        },

        /**
         * Save input data to new table row
         * @param data
         */
        save: function (data) {
          supplementalLinks.methods.hideError();
          var index = supplementalLinks.$table.find("tbody tr").length;

          if (index === 0) {
            supplementalLinks.$table.removeClass("hidden");
          } //add new row


          supplementalLinks.newRow.make(index, data); // auto-save the form

          $(document).trigger('autosave');
        },

        /**
         * Toggle desktop add link disabled state
         */
        toggleState: function () {
          if (supplementalLinks.$newLinkInput.val() === "") supplementalLinks.$saveLink.prop('disabled', true);else supplementalLinks.$saveLink.prop('disabled', false);
        }
      },

      /**
       * Events handlers for table rows
       * @param $row
       */
      rowControllers: function ($row) {
        var $urlTd = $row.find(this.tds.url);
        $urlTd.on('editInPlace:onSave', '.js-editable', supplementalLinks.newRow.handlers.onUpdateUrl);
        $urlTd.on('keydown', '.js-editable.validation-error textarea', supplementalLinks.newRow.handlers.cleanURLEditableErrors); // remove

        $row.find('.remove-link').on('click', supplementalLinks.newRow.handlers.remove); // popup

        $row.on('mouseenter', '.js-editable:not(.js--open) .js-editable__text', supplementalLinks.newRow.handlers.showPopup);
        $row.on('mouseleave', '.js-editable', supplementalLinks.newRow.handlers.hidePopup); // When edit button is clicked for one row

        $row.on('click', '.btn--action.edit', supplementalLinks.newRow.handlers.edit);
      },

      /**
       * New Row functions
       */
      newRow: {
        $row: null,
        data: {},

        /**
         * Make new row
         * @param index
         * @param data
         */
        make: function (index, data) {
          this.data = data;
          this.render(index);
          this.init();
        },

        /**
         * Generate new row html and append
         * @param index
         */
        render: function (index) {
          var rowHtml = supplementalLinks.$templateRow[0].outerHTML;
          rowHtml = rowHtml.replace(/\{\{url\}\}/gi, this.data.url).replace(/\{\{description\}\}/gi, this.data.description).replace(/\{\{index\}\}/gi, index).replace(/fakedinput/gi, "input").replace(/fakedtextarea/gi, "textarea").replace(/fakedselect/gi, "select");
          this.$row = $(rowHtml).appendTo(supplementalLinks.$table.find("tbody"));
        },

        /**
         * Initialize the new row
         */
        init: function () {
          this.plugins();
          this.controller();
        },

        /**
         * Run the plugins used in the new row
         */
        plugins: function () {
          var selectors = this.$row.find(".future-jcf");

          if (selectors.length) {
            if (this.data.type) {
              if (this.data.type.value) selectors.val(this.data.type.value);
              if (this.data.type.label) this.$row.find(supplementalLinks.tds.type + " .td-text").text(this.data.type.label);
            }

            selectors.addClass("jcf").removeClass("future-jcf");
            jcf.replace(selectors);
          }

          if (!isMobile && UX.editInPlace) {
            UX.editInPlace.init();
          }

          if (UX.charCounter) {
            UX.charCounter.init();
          }
        },

        /**
         * Attach events handlers to the new row
         */
        controller: function () {
          supplementalLinks.rowControllers(this.$row);
        },

        /**
         * Row Events Handlers
         */
        handlers: {
          /**
           * Remove the row
           */
          remove: function () {
            var $row = $(this).closest('tr');
            $row.remove();

            if (!supplementalLinks.$table.find("tbody tr").length) {
              supplementalLinks.$table.addClass("hidden");
            }
          },

          /**
           * Edit the row
           * @param e
           */
          edit: function (e) {
            e.preventDefault();
            var index = $(this).closest('tr').data("index");
            supplementalLinks.modal.show(index);
          },

          /**
           * Show popup on row cell
           */
          showPopup: function () {
            if (!isMobile) {
              var content = $(this).text();
              var hasHover = $(this).closest(".js-editable").find('.hover-popup').length;

              if (content !== "" && !hasHover) {
                var html = "<div class='hover-popup'>" + content + "</div>";
                var $hover = $(html);
                $hover.width($(this).outerWidth());
                $hover.insertAfter($(this));
              }
            }
          },

          /**
           * Hide popup on row cell
           */
          hidePopup: function () {
            if (!isMobile) {
              $(this).find(".hover-popup").remove();
            }
          },

          /**
           * On Updating the url using edit-in-place plugin
           * @param e
           */
          onUpdateUrl: function (e) {
            var value = $(this).find('.js-editable__input textarea').val();
            $(this).removeClass("validation-error");
            $(this).find(".js-editable__validate").text("");

            if (!supplementalLinks.methods.validateUrl(value)) {
              e.preventDefault();
              $(this).find(".js-editable__validate").text(supplementalLinks.strings["notUrl"]);
              $(this).find('.btn-save').prop('disabled', true);
              $(this).addClass("validation-error");
            }
          },

          /**
           * Clear the edit-in-place errors
           */
          cleanURLEditableErrors: function () {
            var $item = $(this).closest('.js-editable');
            $item.removeClass("validation-error");
            $item.find('.btn-save').prop('disabled', false);
          }
        }
      },

      /**
       * Supplemental Links Modal
       */
      modal: {
        $modal: null,
        $row: null,
        $mode: null,
        $url: null,
        $description: null,
        $type: null,
        $title: null,
        $saveBtn: null,
        $validation: null,
        init: function () {
          this.$modal = $("#supplemental-links-modal");
          this.$mode = this.$modal.find("input.mode");
          this.$url = this.$modal.find(".link-url");
          this.$description = this.$modal.find(".link-description");
          this.$type = this.$modal.find(".link-type");
          this.$title = this.$modal.find(".modal__title");
          this.$saveBtn = this.$modal.find("#saveLink");
          this.$validation = this.$modal.find(".modal-validation-message");
          this.controller();
        },

        /**
         * Modal events handlers
         */
        controller: function () {
          this.$modal.on('show.bs.modal', function () {
            supplementalLinks.modal.refreshPlugins();
          });
          this.$saveBtn.on("click", function () {
            if (supplementalLinks.modal.save() !== false) supplementalLinks.modal.hide();
          });
        },

        /**
         * Show modal either for adding or editing
         * @param rowNum
         */
        show: function (rowNum) {
          if (typeof rowNum !== "undefined" && rowNum !== false) {
            this.$row = supplementalLinks.$table.find('tr[data-index="' + rowNum + '"]');
            this.prepare();
            this.$title.text(supplementalLinks.strings.edit);
            this.$mode.val("update");
          } else {
            this.$title.text(supplementalLinks.strings.add);
            this.$mode.val("store");
          }

          this.$modal.modal({
            backdrop: 'static',
            keyboard: false
          }, 'show');
        },

        /**
         * Hide the modal
         */
        hide: function () {
          this.$modal.modal('hide');
        },

        /**
         * Refresh the plugins in the modal
         */
        refreshPlugins: function () {
          jcf.getInstance(this.$type).refresh();
          UX.charCounter.init();
        },

        /**
         * Prepare modal inputs from current row
         */
        prepare: function () {
          var data = this.getDataFromRow();
          if (data.url) this.$url.val(data.url);
          if (data.description) this.$description.val(data.description);
          if (data.type && data.type.value) this.$type.val(data.type.value);
        },

        /**
         * Get data from the current row
         */
        getDataFromRow: function () {
          var data = {};
          data.url = this.$row.find(supplementalLinks.tds.url + ' textarea').val();
          data.description = this.$row.find(supplementalLinks.tds.description + ' textarea').val();
          data.type = {};
          data.type.value = this.$row.find(supplementalLinks.tds.type + ' select').val();
          data.type.label = this.$row.find(supplementalLinks.tds.type + ' select').find('option[value="' + data.type.value + '"]').text();
          return data;
        },

        /**
         * Get data from modal inputs
         */
        getDataFromModal: function () {
          var data = {};
          data.url = this.$url.val();
          data.description = this.$description.val();
          data.type = {};
          data.type.value = this.$type.val();
          data.type.label = this.$type.find('option[value="' + data.type.value + '"]').text();
          return data;
        },

        /**
         * Save the supplemental link
         */
        save: function () {
          var mode = this.$mode.val();
          var newData = this.getDataFromModal(); // clear previous errors

          supplementalLinks.modal.showError(""); // validate

          var validationResult = supplementalLinks.methods.validate(newData);

          if (!validationResult.success) {
            supplementalLinks.modal.showError(validationResult.message);
            return false;
          }

          switch (mode) {
            case "store":
              this.store(newData);
              break;

            case "update":
              this.update(newData);
              break;
          } // clear inputs


          this.clear();
        },

        /**
         * Save new Link
         * @param newData
         */
        store: function (newData) {
          supplementalLinks.methods.save(newData);
        },

        /**
         * Update old Link
         * @param newData
         */
        update: function (newData) {
          this.$row.find(supplementalLinks.tds.url + ' .js-editable__text').text(newData.url);
          this.$row.find(supplementalLinks.tds.url + ' textarea').val(newData.url);
          this.$row.find(supplementalLinks.tds.description + ' .js-editable__text').text(newData.description);
          this.$row.find(supplementalLinks.tds.description + ' textarea').val(newData.description);
          var $select = this.$row.find(supplementalLinks.tds.type + ' select');
          $select.val(newData.type.value);
          this.$row.find(supplementalLinks.tds.type + ' .td-text').text(newData.type.label);
          jcf.getInstance($select).refresh();
        },

        /**
         * Show modal error
         * @param message
         */
        showError: function (message) {
          this.$validation.text(message);
        },

        /**
         * Clear modal inputs
         */
        clear: function () {
          this.$url.val("");
          this.$description.val("");
          this.$type.val("");
          this.refreshPlugins();
        }
      }
    };
    UX.supplementalLinks = supplementalLinks; // add to global namespace
  })(UX);

  (function () {
    var $window = $(window),
        $body = $('body'),
        isMobile = false; // variable use to determine if responsive mode is on or off

    var dropblockUl = {
      $target: null,
      $toggle: null,
      $ul: null,
      $li: null,
      vPort: "screen-sm",
      // default responsive break point
      classes: {
        iconChevronDown: 'icon-arrow_d_n pull-right'
      },
      init: function () {
        dropblockUl.$target = $('.profile-menu');
        dropblockUl.on.build();
        dropblockUl.control();
      },
      control: function () {
        $body.on('click', '.profile-menu--res a', function (e) {
          dropblockUl.on.select.dropdown($(this));
        });
        $(document).on(dropblockUl.vPort + '-on', function () {
          // Waiting for custom event that will be triggered by controller.js to activate responsive effects
          isMobile = true;
          $('.profile-menu').addClass("profile-menu--res"); // class will be used in our scss (to replace media queries)

          dropblockUl.on.build();
        });
        $(document).on(dropblockUl.vPort + '-off', function () {
          // Waiting for custom event that will be triggered by controller.js to deactivate responsive effects
          isMobile = false;
          $('.profile-menu').removeClass("profile-menu--res");
          dropblockUl.on.build();
        });
      },
      on: {
        select: {
          dropdown: function (elem) {
            var dataAttr = elem.closest('ul').data('mobile-toggle');

            if (dataAttr === 'dropdown' || elem.closest('ul').hasClass('dropblock--tab')) {
              var dropdownContainer = elem.closest('.dropBlock');
              dropdownContainer.children('a').find('span').text(elem.text());
            }
          }
        },
        dropdownBuild: function (elem) {
          // rebuild tabs to be as drop down
          if (UX.dropBlock) {
            UX.dropBlock.init();
          }

          elem.wrap('<div class="profile-menu--dropBlock" data-db-parent-of="dbTab-profile-menu"></div>');
          var $dropdownContainer = elem.closest('.profile-menu--dropBlock');
          var $activeTab = dropblockUl.get.activeTab(elem);
          $dropdownContainer.prepend('<a href="#" data-db-target-for="dbTab-profile-menu"><span>' + $activeTab.text() + '</span><i class="' + dropblockUl.classes.iconChevronDown + '" aria-hidden="true"></i></a>');
          elem.attr('data-db-target-of', 'dbTab-profile-menu');
        },
        dropdownDestroy: function (elem) {
          // return tabs to default
          var dropdownContainer = elem.closest('.profile-menu--dropBlock');
          dropdownContainer.children('a').remove();
          elem.removeAttr('data-db-target-of').removeClass('js--open').removeAttr('style').unwrap('.profile-menu--dropBlock');
        },
        build: function () {
          if (isMobile) {
            dropblockUl.on.dropdownBuild(dropblockUl.$target);
          } else {
            dropblockUl.on.dropdownDestroy(dropblockUl.$target);
          }
        }
      },
      get: {
        activeTab: function (elem) {
          return elem.find('a.active,.active a');
        }
      }
    };
    UX.dropblockUl = dropblockUl; // add to global namespace
  })();

  (function () {
    var remoteAccessEmail = {
      $modal: $('#emailDomainsConfirmationDialog'),
      init: function () {
        var showConfirmation = $('.showConfirmation').text().trim();

        if (showConfirmation == 'true') {
          remoteAccessEmail.$modal.modal({
            backdrop: 'static',
            keyboard: false
          }, 'toggle');
        }
      }
    };
    UX.remoteAccessEmail = remoteAccessEmail; // add to global namespace
  })();

  (function () {
    var examCertificate = {
      $body: $('body'),
      $examCertificateMessage: $('.exam-certificate-message'),
      printCertificate: function () {
        examCertificate.$body.empty();
        examCertificate.$body.append(examCertificate.$examCertificateMessage);
        window.print();
      }
    };
    UX.examCertificate = examCertificate; // add to global namespace
  })();

  (function () {
    var $body = $("body");
    var reponsiveMenu = {
      vPort: "screen-sm",
      elementvPort: null,
      isMobile: false,
      // variable use to determine if responsive mode is on or off
      $menuContainer: $(".responsive-menu-container"),
      leftSectionWidth: null,
      rightSectionWidth: null,
      maxMenuItemWidth: 135,
      $moreDropsown: $('.responsive-menu-nav .menubar > .dropdown-more'),
      $menu: $(".responsive-menu-nav >.drawer__nav"),
      $menuWrapper: $('.responsive-menu-nav'),
      init: function () {
        reponsiveMenu.elementvPort = reponsiveMenu.vPort;
        reponsiveMenu.vPort = [];
        $(".responsive-menu-container").each(function (index) {
          reponsiveMenu.check.viewPort(index, $(this));
          reponsiveMenu.responsive(index);
        });
        reponsiveMenu.control();
        reponsiveMenu.on.build();
      },
      responsive: function (index) {
        $(document).on(reponsiveMenu.vPort[index] + '-on', function () {
          reponsiveMenu.isMobile = true;
          $(".responsive-menu-container").each(function () {
            if ($(this).data('ctrl-res') === reponsiveMenu.vPort[index]) {
              $(this).addClass("js--disabled-responsive-menu"); // class will be used in our scss (to replace media queries)
            }
          });
        });
        $(document).on(reponsiveMenu.vPort[index] + '-off', function () {
          reponsiveMenu.isMobile = false;
          $(".responsive-menu-container").each(function () {
            if ($(this).data('ctrl-res') === reponsiveMenu.vPort[index]) {
              $(this).removeClass("js--disabled-responsive-menu"); // class will be used in our scss (to replace media queries)
            }
          });
        });
      },
      control: function () {
        $(window).on('resize', function () {
          reponsiveMenu.modifyMenu();
        });
        $body.on('touchend', '.dropdown-more >a, .dropdown.menu-parent>a ', function (e) {
          if ($(this).parents(".dropdown-more").length > 0 && !$(this).parent().hasClass(".dropdown-more")) {
            $(".responsive-menu-nav .js--opened:not(.dropdown-more)").not($(this).parent()).removeClass('js--opened');
          } else {
            $(".responsive-menu-nav .js--opened").not($(this).parent()).removeClass('js--opened');
          }

          $(this).parent().toggleClass('js--opened');

          if (!$(this).parent().hasClass('js--opened')) {
            $(this).parent().addClass('js--forceClose');
          } else {
            $(this).parent().removeClass('js--forceClose');
          }
        });
        $body.click(function (e) {
          $('.responsive-menu-nav .js--opened:not(:hover)').removeClass('js--opened');
        });
      },
      on: {
        build: function () {
          reponsiveMenu.$menuWrapper.show();
          reponsiveMenu.modifyMenu();
          setTimeout(function () {
            reponsiveMenu.modifyMenu();
          }, 800);
        }
      },
      modifyMenu: function () {
        $(".responsive-menu-container").each(function () {
          reponsiveMenu.$menuContainer = $(this);
          reponsiveMenu.$moreDropsown = reponsiveMenu.$menuContainer.find(".dropdown-more");

          if (!reponsiveMenu.$menuContainer.hasClass('js--disabled-responsive-menu')) {
            reponsiveMenu.leftSectionWidth = reponsiveMenu.$menuContainer.find(".left-section").width();
            reponsiveMenu.rightSectionWidth = reponsiveMenu.$menuContainer.find(".right-section").width();
            reponsiveMenu.$menu = reponsiveMenu.$menuContainer.find(".drawer__nav");
            reponsiveMenu.$menuWrapper = reponsiveMenu.$menuContainer.find(".responsive-menu-nav");
            var availableMenuWidth = reponsiveMenu.$menuContainer.width() - (reponsiveMenu.leftSectionWidth + reponsiveMenu.rightSectionWidth + 35);
            var menuWidth = reponsiveMenu.$menu.width();

            if (availableMenuWidth > 0 && menuWidth > 0) {
              if (menuWidth > availableMenuWidth) {
                while (menuWidth > availableMenuWidth) {
                  var $lastMenuItem = reponsiveMenu.$menu.find('.menubar > [role="menuitem"]:not(.dropdown-more)').last();

                  if ($lastMenuItem.length > 0) {
                    reponsiveMenu.$moreDropsown.removeClass('hidden');
                    reponsiveMenu.$moreDropsown.find('>.dropdown__menu').prepend($lastMenuItem[0].outerHTML);
                    $lastMenuItem.remove();
                    menuWidth = reponsiveMenu.$menu.width();
                  } else {
                    break;
                  }
                }
              } else if (availableMenuWidth > menuWidth + reponsiveMenu.maxMenuItemWidth && !reponsiveMenu.$moreDropsown.hasClass('hidden')) {
                var $moreItems = reponsiveMenu.$moreDropsown.find('.dropdown__menu [role="menuitem"]');
                var $firstMoreItem = $moreItems.first();

                if ($firstMoreItem.length > 0) {
                  reponsiveMenu.$moreDropsown.before($firstMoreItem[0].outerHTML);

                  if ($moreItems.length <= 1) {
                    reponsiveMenu.$moreDropsown.addClass('hidden');
                  }

                  $firstMoreItem.remove();
                  menuWidth = reponsiveMenu.$menu.width();

                  if (menuWidth > availableMenuWidth) {
                    reponsiveMenu.modifyMenu();
                  }
                }
              }
            }
          } else {
            if (!reponsiveMenu.$moreDropsown.hasClass('hidden')) {
              reponsiveMenu.$moreDropsown.addClass('hidden');
              reponsiveMenu.$moreDropsown.before(reponsiveMenu.$moreDropsown.find('.dropdown__menu').html());
              reponsiveMenu.$moreDropsown.find('.dropdown__menu').empty();
            }
          }
        });
      },
      check: {
        viewPort: function (index, $el) {
          if (typeof $el.data('ctrl-res') != 'undefined' || $el.data('ctrl-res') == '') {
            reponsiveMenu.vPort[index] = $el.data('ctrl-res');
          } else {
            $el.data('ctrl-res', reponsiveMenu.elementvPort);
            reponsiveMenu.vPort[index] = reponsiveMenu.elementvPort;
          }
        }
      }
    };
    UX.reponsiveMenu = reponsiveMenu; // add to global namespace
  })();

  (function (UX) {

    let showRecommended = {
      selectors: {
        placeholder: '.show-recommended-placeholder'
      },
      init: () => {
        $(showRecommended.selectors.placeholder).each((index, widget) => {
          showRecommended.getContent(widget);
        });
      },
      getContent: widget => {
        let $widget = $(widget);
        $widget.load($widget.attr('data-ajaxurl'), function () {
          showRecommended.truncate($widget);
          setTimeout(() => {
            showRecommended.checkIfClosed($widget);
            showRecommended.hideSkeletons($widget);
          }, 10);
        });
      },
      truncate: $widget => {
        $('.creative-work__title', $widget).not("[data-truncate='none']").truncate({
          lines: 3,
          addClass: 'min-height'
        });
        $('.creative-work .loa', $widget).not("[data-truncate='none']").truncate({
          lines: 2,
          type: 'list',
          addClass: 'loa-height'
        });
      },
      checkIfClosed: $widget => {
        let $accordionTab = $widget.closest('.accordion-tabbed__tab');

        if (!$accordionTab.hasClass('js--open')) {
          $accordionTab.find('.accordion-tabbed__control').attr("aria-expanded", "false");
          $accordionTab.find('.accordion-tabbed__content').hide();
        }
      },
      hideSkeletons: $widget => {
        $('.lazy-load', $widget).remove();
        $('.delayLoad', $widget).removeClass('delayLoad').addClass('delayedLoad');
        $widget.replaceWith($widget.children());
      }
    };
    UX.showRecommended = showRecommended;
  })(UX);

  // Import widgets

  function setMinContentHeight() {
    $('main').css('min-height', $(window).height() - ($('footer').height() + parseInt($('footer').css('margin-top'))));
  }

  $(document).ready(function () {
    setMinContentHeight();
    $(window).on('resized', setMinContentHeight);
  });

  (function () {
    $(document).on('click', '.add-new-address,.cancle-new-address', function () {
      addAddress();
    });

    function addAddress() {
      $('.new-address').toggle();
      $('.user-addresses').toggle();
    }
  })();

  //

  /**
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill}
   */
  (function () {
    if (typeof window.CustomEvent === "function") return false; //If not IE

    function CustomEvent(event, params) {
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: undefined
      };
      var evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    }

    CustomEvent.prototype = window.Event.prototype;
    window.CustomEvent = CustomEvent;
  })();

  var resizedEvent = (() => {
    var timer;
    var windowWidth = $(window).width();
    window.addEventListener('resize', event => {
      if (timer) clearTimeout(timer);
      timer = setTimeout(() => {
        if ($(window).width() !== windowWidth) {
          // fix for mobile devices - scrolling triggers resize events when the action bar disappears
          windowWidth = $(window).width();
          window.dispatchEvent(new CustomEvent('resized'));
          $(window).trigger('resized');
        }
      }, 100, event);
    });
  });

  (function () {
    var enquireIt = {
      init: function () {
        // console.log("max-width:"+  (parseInt(UX.grid.screenSm) -1) +"px");
        // Responsive behavior controllers ( media query listeners )
        UX.controller.enabled = true;
        enquire.register("screen and (max-width:" + (parseInt(UX.grid.screenXs) - 1) + "px)", {
          match: function () {
            $(document).trigger("screen-xs-on"); // screen is xs

            $(document).trigger("smartResize"); // resize have been made
          },
          unmatch: function () {
            $(document).trigger("screen-xs-off"); // screen is not xs anymore

            $(document).trigger("smartResize"); // resize have been made
          }
        }).register("screen and (max-width:" + (parseInt(UX.grid.screenSm) - 1) + "px)", {
          match: function () {
            $(document).trigger("screen-sm-on"); // screen is sm

            $(document).trigger("smartResize"); // resize have been made
          },
          unmatch: function () {
            $(document).trigger("screen-sm-off"); // screen is not sm anymore

            $(document).trigger("smartResize"); // resize have been made
          }
        }).register("screen and (max-width:" + (parseInt(UX.grid.screenMd) - 1) + "px)", {
          match: function () {
            $(document).trigger("screen-md-on"); // screen is md

            $(document).trigger("smartResize"); // resize have been made
          },
          unmatch: function () {
            $(document).trigger("screen-md-off"); // screen is not md anymore

            $(document).trigger("smartResize"); // resize have been made
          }
        }).register("screen and (max-width:" + (parseInt(UX.grid.screenLg) - 1) + "px)", {
          match: function () {
            $(document).trigger("screen-lg-on"); // screen is md

            $(document).trigger("smartResize"); // resize have been made
          },
          unmatch: function () {
            $(document).trigger("screen-lg-off"); // screen is not md anymore

            $(document).trigger("smartResize"); // resize have been made
          }
        }).register("screen and (min-width:0px)", {
          match: function () {
            $(document).trigger("screen-xlg-on"); // screen is md

            $(document).trigger("smartResize"); // resize have been made
          }
          /*unmatch : function() {
              $(document).trigger("screen-xlg-off"); // screen is not md anymore
              $(document).trigger("smartResize"); // resize have been made
           }*/

        });
        resizedEvent();
      }
    };
    UX.enquireIt = enquireIt; // add to global namespace
  })();

  $(document).ready(function () {
    if ($('.colors-palette').length) {
      $.each($(".rlist--inline.bg-colors li"), function (index, value) {
        var backgroundColor = rgb2hex($(value).find('.block').css("background-color"));
        $(value).append('<p> [' + backgroundColor + ']</p>');
      });
      $.each($(".rlist--inline.text-colors li"), function (index, value) {
        var color = rgb2hex($(value).find('.block').css("color"));
        $(value).append('<p> [' + color + ']</p>');
      });
      $.each($(".rlist--inline.border-colors li"), function (index, value) {
        var color = rgb2hex($(value).find('> div').css("border-top-color"));
        $(value).append('<p> [' + color + ']</p>');
      });
    }

    function rgb2hex(rgb) {
      var colors = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);

      if (colors) {
        return "#" + hex(colors[1]) + hex(colors[2]) + hex(colors[3]);
      } else {
        return rgb;
      }
    }

    function hex(x) {
      var hexDigits = new Array("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F");
      return isNaN(x) ? "00" : hexDigits[(x - x % 16) / 16] + hexDigits[x % 16];
    }
  });

  (function () {
    UX.funders.magicSuggestData = [{
      "value": "v1",
      "label": "Secretary of Defense"
    }, {
      "value": "v2",
      "label": "Defense"
    }, {
      "value": "v3",
      "label": "Department of Energy"
    }];
  })();

  UX.submissionAuthors.on.doSuggest = function () {
    var affilationMagicSuggest = UX.submissionAuthors.$modal.find('.aff-magicsuggest'); // $(UX.submissionAuthors.authorAjaxLink).attr("href", '//localhost:8080/specs/ux3/widgets/pd-authors/js/orcid-author.json');

    UX.submissionAuthors.affilationMagicSuggest = affilationMagicSuggest.magicSuggest({
      data: [{
        "value": "0001",
        "label": "Test Inst"
      }, {
        "value": "0002",
        "label": "AAA Inst"
      }],
      method: 'GET',
      valueField: 'value',
      autoSelect: false,
      allowFreeEntries: false,
      displayField: 'label',
      hideTrigger: 'true',
      useCommaKey: false,
      mode: "remote"
    });
  };

  UX.basicMetadata.autocomplete.sources.journals = function (url, request, response) {
    $.ajax({
      url: 'https://jsonplaceholder.typicode.com/posts',
      dataType: 'json',
      data: {
        query: request.term
      },
      success: function (data) {
        response($.map(data, function (el) {
          return {
            label: el.title,
            value: el.title,
            id: el.id
          };
        }));
      }
    });
  };

  UX.pdActionBar.on.build = function () {
    var $autocomplete = $(".ux-modal-container").find(".ux3-autocomplete");

    if (typeof $autocomplete.autocomplete !== 'undefined') {
      $autocomplete.autocomplete({
        source: function (request, response) {
          $.ajax({
            url: "https://jsonplaceholder.typicode.com/posts",
            dataType: "json",
            data: {
              query: request.term
            },
            success: function (data) {
              response($.map(data, function (el) {
                return {
                  label: el.title,
                  value: el.title,
                  id: el.id
                };
              }));
            }
          });
        },
        minLength: 2,
        open: function () {
          $(".ui-menu.ui-autocomplete").width($(this).innerWidth());
        },
        select: function (event, ui) {
          $("[name='submitted-to']").val(ui.item.id);
        }
      });
    }
  };

  (function () {
    UX.loader.getContent = function () {
      // get content using ajax request
      $('.tab__spinner').show(); // show spinner pane

      var loadUrl = "/specs/ux3/widgets/publication-content/ajax/figures.html";

      if (UX.loader.target.indexOf("pane-pcw-references") >= 0) {
        loadUrl = "/specs/ux3/widgets/publication-content/ajax/references.html";
      }

      $(UX.loader.target).load(loadUrl, function (response, status, xhr) {
        if (status == 'error') {
          var msg = 'Sorry but there was an error: ';
          console.log(msg + xhr.status + ' ' + xhr.statusText);
        }

        $('.tab__spinner').hide(); // hide spinner pane

        $(UX.loader.target).removeClass('empty');
        UX.loader.attach();
        $(UX.loader.target).trigger('content-loaded');
      });
    };
  })();

  /*!
   * jQuery UI Core 1.10.2
   * http://jqueryui.com
   *
   * Copyright 2013 jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/category/ui-core/
   */
  (function ($, undefined) {
    var uuid = 0,
        runiqueId = /^ui-id-\d+$/; // $.ui might exist from components with no dependencies, e.g., $.ui.position

    $.ui = $.ui || {};
    $.extend($.ui, {
      version: "1.10.2",
      keyCode: {
        BACKSPACE: 8,
        COMMA: 188,
        DELETE: 46,
        DOWN: 40,
        END: 35,
        ENTER: 13,
        ESCAPE: 27,
        HOME: 36,
        LEFT: 37,
        NUMPAD_ADD: 107,
        NUMPAD_DECIMAL: 110,
        NUMPAD_DIVIDE: 111,
        NUMPAD_ENTER: 108,
        NUMPAD_MULTIPLY: 106,
        NUMPAD_SUBTRACT: 109,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        PERIOD: 190,
        RIGHT: 39,
        SPACE: 32,
        TAB: 9,
        UP: 38
      }
    }); // plugins

    $.fn.extend({
      focus: function (orig) {
        return function (delay, fn) {
          return typeof delay === "number" ? this.each(function () {
            var elem = this;
            setTimeout(function () {
              $(elem).focus();

              if (fn) {
                fn.call(elem);
              }
            }, delay);
          }) : orig.apply(this, arguments);
        };
      }($.fn.focus),
      scrollParent: function () {
        var scrollParent;

        if ($.ui.ie && /(static|relative)/.test(this.css("position")) || /absolute/.test(this.css("position"))) {
          scrollParent = this.parents().filter(function () {
            return /(relative|absolute|fixed)/.test($.css(this, "position")) && /(auto|scroll)/.test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
          }).eq(0);
        } else {
          scrollParent = this.parents().filter(function () {
            return /(auto|scroll)/.test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
          }).eq(0);
        }

        return /fixed/.test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
      },
      zIndex: function (zIndex) {
        if (zIndex !== undefined) {
          return this.css("zIndex", zIndex);
        }

        if (this.length) {
          var elem = $(this[0]),
              position,
              value;

          while (elem.length && elem[0] !== document) {
            // Ignore z-index if position is set to a value where z-index is ignored by the browser
            // This makes behavior of this function consistent across browsers
            // WebKit always returns auto if the element is positioned
            position = elem.css("position");

            if (position === "absolute" || position === "relative" || position === "fixed") {
              // IE returns 0 when zIndex is not specified
              // other browsers return a string
              // we ignore the case of nested elements with an explicit value of 0
              // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
              value = parseInt(elem.css("zIndex"), 10);

              if (!isNaN(value) && value !== 0) {
                return value;
              }
            }

            elem = elem.parent();
          }
        }

        return 0;
      },
      uniqueId: function () {
        return this.each(function () {
          if (!this.id) {
            this.id = "ui-id-" + ++uuid;
          }
        });
      },
      removeUniqueId: function () {
        return this.each(function () {
          if (runiqueId.test(this.id)) {
            $(this).removeAttr("id");
          }
        });
      }
    }); // selectors

    function focusable(element, isTabIndexNotNaN) {
      var map,
          mapName,
          img,
          nodeName = element.nodeName.toLowerCase();

      if ("area" === nodeName) {
        map = element.parentNode;
        mapName = map.name;

        if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
          return false;
        }

        img = $("img[usemap=#" + mapName + "]")[0];
        return !!img && visible(img);
      }

      return (/input|select|textarea|button|object/.test(nodeName) ? !element.disabled : "a" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && // the element and all of its ancestors must be visible
      visible(element);
    }

    function visible(element) {
      return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function () {
        return $.css(this, "visibility") === "hidden";
      }).length;
    }

    $.extend($.expr[":"], {
      data: $.expr.createPseudo ? $.expr.createPseudo(function (dataName) {
        return function (elem) {
          return !!$.data(elem, dataName);
        };
      }) : // support: jQuery <1.8
      function (elem, i, match) {
        return !!$.data(elem, match[3]);
      },
      focusable: function (element) {
        return focusable(element, !isNaN($.attr(element, "tabindex")));
      },
      tabbable: function (element) {
        var tabIndex = $.attr(element, "tabindex"),
            isTabIndexNaN = isNaN(tabIndex);
        return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
      }
    }); // support: jQuery <1.8

    if (!$("<a>").outerWidth(1).jquery) {
      $.each(["Width", "Height"], function (i, name) {
        var side = name === "Width" ? ["Left", "Right"] : ["Top", "Bottom"],
            type = name.toLowerCase(),
            orig = {
          innerWidth: $.fn.innerWidth,
          innerHeight: $.fn.innerHeight,
          outerWidth: $.fn.outerWidth,
          outerHeight: $.fn.outerHeight
        };

        function reduce(elem, size, border, margin) {
          $.each(side, function () {
            size -= parseFloat($.css(elem, "padding" + this)) || 0;

            if (border) {
              size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
            }

            if (margin) {
              size -= parseFloat($.css(elem, "margin" + this)) || 0;
            }
          });
          return size;
        }

        $.fn["inner" + name] = function (size) {
          if (size === undefined) {
            return orig["inner" + name].call(this);
          }

          return this.each(function () {
            $(this).css(type, reduce(this, size) + "px");
          });
        };

        $.fn["outer" + name] = function (size, margin) {
          if (typeof size !== "number") {
            return orig["outer" + name].call(this, size);
          }

          return this.each(function () {
            $(this).css(type, reduce(this, size, true, margin) + "px");
          });
        };
      });
    } // support: jQuery <1.8


    if (!$.fn.addBack) {
      $.fn.addBack = function (selector) {
        return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
      };
    } // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)


    if ($("<a>").data("a-b", "a").removeData("a-b").data("a-b")) {
      $.fn.removeData = function (removeData) {
        return function (key) {
          if (arguments.length) {
            return removeData.call(this, $.camelCase(key));
          } else {
            return removeData.call(this);
          }
        };
      }($.fn.removeData);
    } // deprecated


    $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
    $.support.selectstart = "onselectstart" in document.createElement("div");
    $.fn.extend({
      disableSelection: function () {
        return this.bind(($.support.selectstart ? "selectstart" : "mousedown") + ".ui-disableSelection", function (event) {
          event.preventDefault();
        });
      },
      enableSelection: function () {
        return this.unbind(".ui-disableSelection");
      }
    });
    $.extend($.ui, {
      // $.ui.plugin is deprecated.  Use the proxy pattern instead.
      plugin: {
        add: function (module, option, set) {
          var i,
              proto = $.ui[module].prototype;

          for (i in set) {
            proto.plugins[i] = proto.plugins[i] || [];
            proto.plugins[i].push([option, set[i]]);
          }
        },
        call: function (instance, name, args) {
          var i,
              set = instance.plugins[name];

          if (!set || !instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11) {
            return;
          }

          for (i = 0; i < set.length; i++) {
            if (instance.options[set[i][0]]) {
              set[i][1].apply(instance.element, args);
            }
          }
        }
      },
      // only used by resizable
      hasScroll: function (el, a) {
        //If overflow is hidden, the element might have extra content, but the user wants to hide it
        if ($(el).css("overflow") === "hidden") {
          return false;
        }

        var scroll = a && a === "left" ? "scrollLeft" : "scrollTop",
            has = false;

        if (el[scroll] > 0) {
          return true;
        } // TODO: determine which cases actually cause this to happen
        // if the element doesn't have the scroll set, see if it's possible to
        // set the scroll


        el[scroll] = 1;
        has = el[scroll] > 0;
        el[scroll] = 0;
        return has;
      }
    });
  })(jQuery);

  // Import components

  (function () {
    $(document).ready(function () {
      UX.controller.init();

      if ($('[data-toggle="nav"]').length) {
        UX.menu.init();
      }

      if ($(".datepicker").length) {
        UX.datepicker.init();
      }

      if ($('.w-slide__btn').length) {
        UX.slide.init();
      }

      if ($('[data-db-target-for]').length) {
        UX.dropBlock.init();
      }

      if ($('[data-toggle="modal"]').length) {
        UX.modal.init();
      }

      if ($('table').length) {
        UX.toggleTable.init();
      }

      if ($('.facet').length) {
        UX.toggle.init();
      }

      UX.facetDate.init();

      if ($('.accordion').length) {
        UX.accordion.init();
      }

      if ($('.facetDateChart').length) {
        UX.facetDateChart.init();
      }

      if ($('.coolBar').length) {
        UX.coolbar.init();
      }

      if ($('article').length) {
        UX.loader.init();
      }

      if ($('.back-to-top').length) {
        UX.backToTop.init();
      }

      if ($('.refineSearch').length || $('.advanced-search').length) {
        UX.refine.init();
      }

      if ($('.advanced-search').length) {
        UX.searchFieldsCtrl.init();
      }

      if ($(".table-fn").length || $('.ref.fn').length || $(".scroll-to-target").length) {
        UX.scrollo.init();
      }

      if ($('figure').length) {
        UX.figureViewer.init();
      }

      if ($('.tab').length) {
        UX.tab.init();
      }

      if ($('.owl-carousel').length) {
        UX.slider.init();
      }

      if ($('.loi__banner').length) {
        UX.loi.init();
      }

      if ($('.quick-search').length) {
        UX.quickSearch.init();
      }

      UX.fieldsCtrl.init();

      if ($('[data-toggle="transplant"]').length) {
        UX.transplant.init();
      }

      if ($(".js__toggleAdForm").length) {
        UX.adplaceholder.init();
      }

      if ($(".trusted-proxy-form").length) {
        UX.trustedPoxy.init();
      }

      UX.alerts.init();

      if ($("#institutionList").length) {
        UX.profileMain.init();
      }

      UX.dropblockUl.init();
      UX.searchResult.init();

      if ($(".favoriteShortlist").length) {
        UX.favorites.init();
      }

      if ($(".expandable-list").length) {
        UX.list.init();
      }

      if ($(".basic-metadata").length) {
        UX.basicMetadata.init();
      }

      if ($(".supplemental-links").length) {
        UX.supplementalLinks.init();
      }

      if ($(".funders").length) {
        UX.funders.init();
      }

      if ($(".uploader").length) {
        UX.fileUploader.init();
      }

      if ($('.author-index').length) {
        UX.authorIndex.init();
      }

      if ($(".sortable-table").length) {
        UX.sortableTableRow.init();
      }

      if ($(".submission-authors").length) {
        UX.submissionAuthors.init();
      }

      if ($("#institutionUsageReport").length) {
        UX.reports.init();
      }

      if ($('.cookiePolicy-popup').length) {
        UX.cookiePolicyPopupWidget.init();
      }

      if ($(".supplemental-files").length) {
        UX.supplementalFiles.init();
      }

      if ($(".js-editable").length) {
        UX.editInPlace.init();
      }

      if ($(".submission-list").length) {
        UX.submissionList.init();
      }

      if ($(".pd-action-bar").length) {
        UX.pdActionBar.init();
      }

      if ($(".js-counter").length) {
        UX.charCounter.init();
      }

      if ($("#draftForm").length) {
        UX.draftForm.init();
      }

      if ($(".pairing-management").length) {
        UX.pairingManagment.init();
      }

      if ($(".device-pairing").length) {
        UX.devicePairing.init();
      }

      if ($(".categories-widget").length) {
        UX.pdSearchCategories.init();
      }

      if ($('.client-pagination').length) {
        UX.clientPagination.init();
      }

      if ($('.remote-access-email-domains').length) {
        UX.remoteAccessEmail.init();
      }

      if ($('.js__removeAdmins').length) {
        UX.administrators.init();
      }

      if ($('.responsive-menu-nav').length) {
        UX.reponsiveMenu.init();
      }

      if ($('.js__removeAdmins').length) {
        UX.administrators.init();
      }

      if ($('.multi-search').length) {
        UX.multiSearch.init();
      }

      if ($('.sections-block').length) {
        UX.sidebarSections.init();
      }

      if ($('.truncate-text').length || $('.truncate-list').length) {
        UX.genericTruncate.init();
      }

      if ($('.auto-hide-primary-bar').length) {
        UX.autoHideBar.init();
      }

      UX.stickyElements.init();
      UX.pageBody.init();
      UX.tocJs.init();

      if ($(".progress-bar").length) {
        UX.progressBar.init();
      }

      if ($(".js--truncate").length) {
        UX.truncater.init();
      }

      UX.showRecommended.init();
      UX.enquireIt.init(); // important: keep it always last
    });
  })();

}());

//# sourceMappingURL=main.bundle.js.map
